const h=d=>`${d} must be a string`,O=d=>`${d} must be a number`,b=(d,t)=>`${t} pin not found nodeId=${d}`,E=(d,t,e)=>`${b(d,t)} position=${e}`,m=(d,t,e)=>`${b(d,t)} pinId=${e}`;class w{id;kind;types;constructor(t,{id:e,types:s=[]}){this.id=e,this.kind=t,this.types=s}get hasTypeAny(){return this.types.length===0}get hasTypeString(){return this.hasTypeAny||this.types.includes("string")}get hasTypeNumber(){return this.hasTypeAny||this.types.includes("number")}get hasTypeBoolean(){return this.hasTypeAny||this.types.includes("boolean")}get hasTypeNull(){return this.hasTypeAny||this.types.includes("null")}get hasTypeObject(){return this.hasTypeAny||this.types.includes("object")}get hasTypeArray(){return this.hasTypeAny||this.types.includes("array")}}class r{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isObject(t){return!r.isUndefined(t)&&!r.isNull(t)&&!r.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"}static isString(t){return typeof t=="string"}static isUndefined(t){return typeof t=="undefined"}static validate(t,e){return e.length===0?!0:e.some(s=>{switch(s){case"array":return r.isArray(t);case"boolean":return r.isBoolean(t);case"null":return r.isNull(t);case"number":return r.isNumber(t);case"object":return r.isObject(t);case"string":return r.isString(t);default:return!1}},!0)}}class I extends w{#t;constructor({id:t,types:e}){super("input",{id:t,types:e})}connectTo(t){this.#t=t}disconnect(){this.#t=void 0}get data(){return this.#t?.data}toJSON(){return JSON.stringify(this.toObject())}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}class N extends w{#t;constructor({id:t,data:e,types:s}){super("output",{id:t,types:s});this.#t=e}clear(){this.#t=void 0}get data(){return this.#t}set data(t){switch(!0){case r.isUndefined(t):this.clear();break;case this.hasTypeAny:case(r.isString(t)&&this.hasTypeString):case(r.isNumber(t)&&this.hasTypeNumber):case(r.isBoolean(t)&&this.hasTypeBoolean):case(r.isNull(t)&&this.hasTypeNull):case(r.isObject(t)&&this.hasTypeObject):case(r.isArray(t)&&this.hasTypeArray):{this.#t=t;break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toJSON(){return JSON.stringify(this.toObject())}toObject(){const t={id:this.id};return r.isUndefined(this.#t)||(t.data=this.#t),this.types.length>0&&(t.types=this.types),t}}class a{id;kind;meta;inputs=new Map;outputs=new Map;#t=[];#e=[];constructor({id:t,kind:e,inputs:s=[],outputs:n=[]},{isAsync:u=!1,isConstant:o=!1}={}){this.id=t,this.kind=e,this.meta={isAsync:u,isConstant:o};for(const i of s)this.newInput(i);for(const i of n)this.newOutput(i)}getInputById(t){if(typeof t!="string")throw new TypeError(h("inputId"));const e=this.inputs.get(t);if(e instanceof I)return e;throw new Error(m(this.id,"input",t))}getInputByPosition(t){if(typeof t!="number")throw new TypeError(O("position"));const e=this.#t[t];if(typeof e=="undefined")throw new Error(E(this.id,"input",t));return this.getInputById(e)}getOutputById(t){if(typeof t!="string")throw new TypeError(h("outputId"));const e=this.outputs.get(t);if(e instanceof N)return e;throw new Error(m(this.id,"output",t))}getOutputByPosition(t){if(typeof t!="number")throw new TypeError(O("position"));const e=this.#e[t];if(typeof e=="undefined")throw new Error(E(this.id,"output",t));return this.getOutputById(e)}newInput(t){const e=new I(t);this.inputs.set(e.id,e),this.#t.push(e.id)}newOutput(t){const e=new N(t);this.outputs.set(e.id,e),this.#e.push(e.id)}run(){throw new Error(`${this.constructor.name} does not implement a run() method`)}toJSON(){return JSON.stringify(this.toObject())}toObject(){const t={id:this.id,kind:this.kind},e=Object.values(this.inputs).map(n=>n.toObject());e.length>0&&(t.inputs=e);const s=Object.values(this.outputs).map(n=>n.toObject());return s.length>0&&(t.outputs=s),t}}class p extends a{static kind="Unknown";constructor(t){super({...t,kind:p.kind})}run(){}}class g{id;source;target;constructor({id:t,source:e,target:s}){this.id=t;const[n,u]=e,[o,i]=s;if(typeof n!="string")throw new TypeError(h("sourceNodeId"));if(typeof u!="string")throw new TypeError(h("sourcePinId"));if(typeof o!="string")throw new TypeError(h("targetNodeId"));if(typeof i!="string")throw new TypeError(h("targetPinId"));this.source=e,this.target=s}toJSON(){return JSON.stringify(this.toObject())}toObject(){return{id:this.id,source:this.source,target:this.target}}}class y{#t="success";nodes=new Map;edges=new Map;static sort(t,e){const s={},n=o=>e.filter(({targetId:i})=>o===i).map(({sourceId:i})=>i),u=o=>{const i=n(o);if(i.length===0)return 0;let c=0;for(const f of i){const l=u(f);c=Math.max(l,c)}return c+1};for(const o of t)s[o]=u(o);return t.slice().sort((o,i)=>s[o]<=s[i]?-1:1)}clear(){this.nodes.clear(),this.edges.clear()}getNodeById(t){if(typeof t!="string")throw new TypeError(h("nodeId"));const e=this.nodes.get(t);if(e instanceof a)return e;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(h("edgeId"));const e=this.edges.get(t);if(e instanceof g)return e;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.edges.size){const e=`e${t}`;return this.edges.has(e)?this.generateEdgeId(t+1):e}generateNodeId(t=this.nodes.size){const e=`n${t}`;return this.nodes.has(e)?this.generateNodeId(t+1):e}async run(){this.runStatusIsSuccess&&(this.#t="waiting");const t=y.sort([...this.nodes.keys()],[...this.edges.values()].map(e=>({sourceId:e.source[0],targetId:e.target[0]})));for(const e of t){const s=this.nodes.get(e);try{s.meta.isConstant===!1&&(s.meta.isAsync?await s.run():s.run())}catch(n){console.error(n),this.#t="failure"}}this.runStatusIsWaiting&&(this.#t="success")}get runStatusIsSuccess(){return this.#t==="success"}get runStatusIsWaiting(){return this.#t==="waiting"}get runStatusIsFailure(){return this.#t==="failure"}toJSON(){return JSON.stringify(this.toObject())}toObject(){const t=Object.values(this.nodes).map(s=>s.toObject()),e=Object.values(this.edges).map(s=>s.toObject());return{nodes:t,edges:e}}}class T{graph=new y;#t;constructor(t={}){this.#t=t}connect(t,e=0){return{to:(s,n=0)=>{const u=this.graph.generateEdgeId(),o=t.getOutputByPosition(e),i=s.getInputByPosition(n);this.newEdge({id:u,source:[t.id,o.id],target:[s.id,i.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(h("edgeId"));const e=this.graph.getEdgeById(t);if(e instanceof g){const[s,n]=e.target;this.graph.getNodeById(s).getInputById(n).disconnect(),this.graph.edges.delete(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(h("nodeId"));const e=this.graph.getNodeById(t);if(e instanceof a){for(const s of this.graph.edges.values()){const{source:[n],target:[u]}=s;(n===e.id||u===e.id)&&this.deleteEdge(s.id)}this.graph.nodes.delete(t)}else throw new Error(`DflowNode not found, id=${t}`)}newNode(t){const e=this.#t[t.kind]??p,s=typeof t.id=="string"?t.id:this.graph.generateNodeId(),n=new e({...t,id:s});if(this.graph.nodes.has(n.id))throw new Error(`Cannot overwrite DflowNode, id=${n.id}`);return this.graph.nodes.set(n.id,n),n}newEdge(t){const e=typeof t.id=="string"?t.id:this.graph.generateEdgeId(),s=new g({...t,id:e});if(this.graph.edges.has(s.id))throw new Error(`Cannot overwrite DflowEdge, id=${s.id}`);this.graph.edges.set(s.id,s);const[n,u]=s.source,[o,i]=s.target,c=this.graph.getNodeById(n),f=this.graph.getNodeById(o),l=c.getOutputById(u);return f.getInputById(i).connectTo(l),s}newInput(t,e){this.graph.getNodeById(t).newInput(e)}newOutput(t,e){this.graph.getNodeById(t).newOutput(e)}}export{w as DflowPin};export{r as DflowData};export{I as DflowInput};export{N as DflowOutput};export{a as DflowNode};export{p as DflowUnknownNode};export{g as DflowEdge};export{y as DflowGraph};export{T as DflowHost};
