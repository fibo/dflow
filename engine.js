const l=c=>`${c} must be a string`,P=(c,t)=>`unimplemented method ${c} nodeKind=${t}`,E=c=>`${c} must be a number`,b=(c,t)=>`${t} pin not found nodeId=${c}`,A=(c,t,e)=>`${b(c,t)} position=${e}`,S=(c,t,e)=>`${b(c,t)} pinId=${e}`;class r{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowGraph(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&Array.isArray(t.nodes)&&Array.isArray(t.edges)&&a.isDflowGraph(t)}static isDflowId(t){return r.isStringNotEmpty(t)}static isDflowType(t){return typeof t=="string"&&f.types.includes(t)}static isObject(t){return!r.isUndefined(t)&&!r.isNull(t)&&!r.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return r.isString(t)&&t.length>0}static isUndefined(t){return typeof t=="undefined"}static validate(t,e){return e.length===0?!0:e.some(s=>{switch(s){case"array":return r.isArray(t);case"boolean":return r.isBoolean(t);case"null":return r.isNull(t);case"number":return r.isNumber(t);case"object":return r.isObject(t);case"string":return r.isString(t);case"DflowGraph":return r.isDflowGraph(t);case"DflowId":return r.isDflowId(t);case"DflowType":return r.isDflowType(t);default:return!1}},!0)}}class g{id;name;static isDflowItem({id:t,name:e}){return r.isDflowId(t)&&(r.isUndefined(e)||r.isStringNotEmpty(e))}constructor({id:t,name:e}){this.id=t,this.name=e}toJSON(){return JSON.stringify(this.toObject())}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}class f extends g{kind;types;static types=["string","number","boolean","null","object","array","DflowId","DflowGraph","DflowType"];static isDflowPin({types:t=[],...e}){return g.isDflowItem(e)&&t.every(s=>f.isDflowPinType(s))}static isDflowPinType(t){f.types.includes(t)}constructor(t,{types:e=[],...s}){super(s);this.kind=t,this.types=e}get hasTypeAny(){return this.types.length===0}get hasTypeDflowId(){return this.hasTypeAny||this.types.includes("DflowId")}get hasTypeDflowGraph(){return this.hasTypeAny||this.types.includes("DflowGraph")}get hasTypeDflowType(){return this.hasTypeAny||this.types.includes("DflowType")}get hasTypeString(){return this.hasTypeAny||this.types.includes("string")}get hasTypeNumber(){return this.hasTypeAny||this.types.includes("number")}get hasTypeBoolean(){return this.hasTypeAny||this.types.includes("boolean")}get hasTypeNull(){return this.hasTypeAny||this.types.includes("null")}get hasTypeObject(){return this.hasTypeAny||this.types.includes("object")}get hasTypeArray(){return this.hasTypeAny||this.types.includes("array")}addType(t){this.types.push(t)}removeType(t){this.types.splice(this.types.indexOf(t),1)}}class w extends f{#t;static isDflowInput({id:t,types:e}){return f.isDflowPin({id:t,types:e})}constructor(t){super("input",t)}get data(){return this.#t?.data}get isConnected(){return typeof this.#t=="undefined"}connectTo(t){const{hasTypeAny:e,types:s}=this,{types:n}=t;if(e||s.some(i=>n.includes(i)))this.#t=t;else throw new Error(`mismatching pinTypes, source has types [${n.join()}] and target has types [${s.join()}]`)}disconnect(){this.#t=void 0}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}class N extends f{#t;static isDflowOutput({id:t,data:e,types:s=[]}){return f.isDflowPin({id:t,types:s})&&r.validate(e,s)}constructor({data:t,...e}){super("output",e);this.#t=t}clear(){this.#t=void 0}get data(){return this.#t}set data(t){switch(!0){case r.isUndefined(t):this.clear();break;case this.hasTypeAny:case(r.isDflowGraph(t)&&this.hasTypeDflowGraph):case(r.isDflowId(t)&&this.hasTypeDflowId):case(r.isString(t)&&this.hasTypeString):case(r.isNumber(t)&&this.hasTypeNumber):case(r.isBoolean(t)&&this.hasTypeBoolean):case(r.isNull(t)&&this.hasTypeNull):case(r.isObject(t)&&this.hasTypeObject):case(r.isArray(t)&&this.hasTypeArray):{this.#t=t;break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t={...super.toObject()};return r.isUndefined(this.#t)||(t.data=this.#t),this.types.length>0&&(t.types=this.types),t}}class p extends g{#t=new Map;#e=new Map;#s=[];#n=[];#r;kind;meta;host;static Task=class extends p{task(){throw new Error(P("task",this.kind))}run(){for(const{data:e,types:s}of this.inputs)if(r.isUndefined(e)||!r.validate(e,s)){this.output(0).clear();return}this.output(0).data=this.task()}};static kind;static isAsync;static isConstant;static label;static inputs;static outputs;static generateInputIds(t=[]){return t.map((e,s)=>({...e,id:`i${s}`}))}static generateOutputIds(t=[]){return t.map((e,s)=>({...e,id:`o${s}`}))}static in(t=[],e){return[{types:t,...e}]}static ins(t,e=[]){return Array(t).fill(p.in(e)).flat()}static out(t=[],e){return[{types:t,...e}]}static outs(t,e=[]){return Array(t).fill(p.out(e)).flat()}static outputNumber(t){return{...t,types:["number"]}}static isDflowNode({kind:t,inputs:e=[],outputs:s=[],...n}){return g.isDflowItem(n)&&r.isStringNotEmpty(t)&&e.every(i=>w.isDflowInput(i))&&s.every(i=>N.isDflowOutput(i))}constructor({kind:t,inputs:e=[],outputs:s=[],...n},i,{isAsync:o=!1,isConstant:u=!1,label:h}={}){super(n);this.#r=h,this.host=i,this.kind=t,this.meta={isAsync:o,isConstant:u};for(const d of e)this.newInput(d);for(const d of s)this.newOutput(d);this.onCreate()}get label(){return this.#r||this.kind}get inputs(){return this.#t.values()}get outputs(){return this.#e.values()}get numInputs(){return this.#t.size}get numOutputs(){return this.#e.size}generateInputId(t=this.numInputs){const e=`i${t}`;return this.#t.has(e)?this.generateInputId(t+1):e}generateOutputId(t=this.numOutputs){const e=`o${t}`;return this.#e.has(e)?this.generateOutputId(t+1):e}getInputById(t){if(typeof t!="string")throw new TypeError(l("inputId"));const e=this.#t.get(t);if(e instanceof w)return e;throw new Error(S(this.id,"input",t))}input(t){if(typeof t!="number")throw new TypeError(E("position"));const e=this.#s[t];if(r.isUndefined(e))throw new Error(A(this.id,"input",t));return this.getInputById(e)}getOutputById(t){if(typeof t!="string")throw new TypeError(l("outputId"));const e=this.#e.get(t);if(e instanceof N)return e;throw new Error(S(this.id,"output",t))}output(t){if(typeof t!="number")throw new TypeError(E("position"));const e=this.#n[t];if(r.isUndefined(e))throw new Error(A(this.id,"output",t));return this.getOutputById(e)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),this.#t.delete(t),this.#s.splice(this.#s.indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),this.#e.delete(t),this.#n.splice(this.#n.indexOf(t),1)}onBeforeConnectInput(t,e){}onCreate(){}newInput(t){const e=r.isDflowId(t.id)?t.id:this.generateInputId(),s=new w({...t,id:e});return this.#t.set(e,s),this.#s.push(e),s}newOutput(t){const e=r.isDflowId(t.id)?t.id:this.generateOutputId(),s=new N({...t,id:e});return this.#e.set(e,s),this.#n.push(e),s}run(){throw new Error(`${this.constructor.name} does not implement a run() method`)}toObject(){const t={...super.toObject(),kind:this.kind},e=[],s=[];for(const n of this.inputs)e.push(n.toObject());e.length>0&&(t.inputs=e);for(const n of this.outputs)s.push(n.toObject());return s.length>0&&(t.outputs=s),t}}class m extends p{static kind="Unknown";constructor(t,e){super({...t,kind:m.kind},e)}run(){}}class I extends g{source;target;static isDflowEdge({source:t,target:e,...s},n){return g.isDflowItem(s)&&Array.isArray(t)&&t.length===2&&n.nodes.find(({id:i,outputs:o=[]})=>i===t[0]&&o.find(({id:u})=>u===t[1]))&&Array.isArray(e)&&e.length===2&&n.nodes.find(({id:i,inputs:o=[]})=>i===e[0]&&o.find(({id:u})=>u===e[1]))}constructor({source:t,target:e,...s}){super(s);const[n,i]=t,[o,u]=e;if(typeof n!="string")throw new TypeError(l("sourceNodeId"));if(typeof i!="string")throw new TypeError(l("sourcePinId"));if(typeof o!="string")throw new TypeError(l("targetNodeId"));if(typeof u!="string")throw new TypeError(l("targetPinId"));this.source=t,this.target=e}toObject(){return{...super.toObject(),source:this.source,target:this.target}}}class a extends g{#t="success";#e=new Map;#s=new Map;static isDflowGraph(t){return t.nodes.every(e=>p.isDflowNode(e))&&t.edges.every(e=>I.isDflowEdge(e,t))}static childrenOfNodeId(t,e){return e.filter(({sourceId:s})=>t===s).map(({targetId:s})=>s)}static parentsOfNodeId(t,e){return e.filter(({targetId:s})=>t===s).map(({sourceId:s})=>s)}static levelOfNodeId(t,e){const s=a.parentsOfNodeId(t,e);if(s.length===0)return 0;let n=0;for(const i of s){const o=a.levelOfNodeId(i,e);n=Math.max(o,n)}return n+1}static ancestorsOfNodeId(t,e){const s=a.parentsOfNodeId(t,e);return s.length===0?[]:s.reduce((n,i,o,u)=>{const h=a.ancestorsOfNodeId(i,e),d=n.concat(h);return o===u.length-1?Array.from(new Set(u.concat(d))):d},[])}static sort(t,e){const s={};for(const n of t)s[n]=a.levelOfNodeId(n,e);return t.slice().sort((n,i)=>s[n]<=s[i]?-1:1)}get edges(){return this.#s.values()}get nodes(){return this.#e.values()}get nodeConnections(){return[...this.#s.values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...this.#s.keys()]}get nodeIds(){return[...this.#e.keys()]}get numEdges(){return this.#s.size}get numNodes(){return this.#e.size}get runStatusIsSuccess(){return this.#t==="success"}get runStatusIsWaiting(){return this.#t==="waiting"}get runStatusIsFailure(){return this.#t==="failure"}addEdge(t){if(this.#s.has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);this.#s.set(t.id,t)}addNode(t){if(this.#e.has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);this.#e.set(t.id,t)}clear(){this.#e.clear(),this.#s.clear()}deleteEdge(t){this.#s.delete(t)}deleteNode(t){this.#e.delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(l("nodeId"));const e=this.#e.get(t);if(e instanceof p)return e;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(l("edgeId"));const e=this.#s.get(t);if(e instanceof I)return e;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const e=`e${t}`;return this.#s.has(e)?this.generateEdgeId(t+1):e}generateNodeId(t=this.numNodes){const e=`n${t}`;return this.#e.has(e)?this.generateNodeId(t+1):e}nodeIdsInsideFunctions(){const t=[];for(const e of this.nodes)e.kind==="return"&&t.push(a.ancestorsOfNodeId(e.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){this.runStatusIsSuccess&&(this.#t="waiting");const t=this.nodeIdsInsideFunctions(),e=a.sort(this.nodeIds.filter(s=>!t.includes(s)),this.nodeConnections);for(const s of e){const n=this.#e.get(s);try{n.meta.isConstant===!1&&(n.meta.isAsync?await n.run():n.run())}catch(i){console.error(i),this.#t="failure"}}this.runStatusIsWaiting&&(this.#t="success")}toObject(){const t={...super.toObject(),nodes:[],edges:[]};for(const e of this.nodes)t.nodes.push(e.toObject());for(const e of this.edges)t.edges.push(e.toObject());return t}}class B{#t;#e;constructor(t={}){this.#e=t,this.#t=new a({id:"g1"})}get edges(){return this.#t.edges}get nodes(){return this.#t.nodes}get numEdges(){return this.#t.numEdges}get numNodes(){return this.#t.numNodes}get nodeKinds(){return Object.keys(this.#e)}get runStatusIsSuccess(){return this.#t.runStatusIsSuccess}get runStatusIsWaiting(){return this.#t.runStatusIsWaiting}get runStatusIsFailure(){return this.#t.runStatusIsFailure}clearGraph(){this.#t.clear()}connect(t,e=0){return{to:(s,n=0)=>{const i=this.#t.generateEdgeId(),o=t.output(e),u=s.input(n);s.onBeforeConnectInput(t,e),this.newEdge({id:i,source:[t.id,o.id],target:[s.id,u.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(l("edgeId"));const e=this.#t.getEdgeById(t);if(e instanceof I){const[s,n]=e.target;this.getNodeById(s).getInputById(n).disconnect(),this.#t.deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(l("nodeId"));const e=this.getNodeById(t);if(e instanceof p){for(const s of this.#t.edges){const{source:[n],target:[i]}=s;(n===e.id||i===e.id)&&this.deleteEdge(s.id)}this.#t.deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,e]){for(const s of this.edges){const[n,i]=s.source,[o,u]=s.target;(n===t&&i===e||o===t&&u===e)&&this.deleteEdge(s.id)}}async executeFunction(t,e){const s=this.#t.nodeConnections,n=a.childrenOfNodeId(t,s),i=[];for(const h of n){const d=this.getNodeById(h);d.kind==="return"&&i.push(d.id)}const o=i.reduce((h,d,y,O)=>{const D=a.ancestorsOfNodeId(d,s),T=h.concat(D);return y===O.length?Array.from(new Set(T)):T},[]),u=a.sort(o,s);for(const h of u){const d=this.getNodeById(h);try{switch(d.kind){case"argument":{const y=0;d.output(0).data=e[y];break}case"return":return d.input(1).data;default:d.meta.isConstant===!1&&(d.meta.isAsync?await d.run():d.run())}}catch(y){console.error(y)}}}getEdgeById(t){return this.#t.getEdgeById(t)}getNodeById(t){return this.#t.getNodeById(t)}newNode(t){const e=this.#e[t.kind]??m,s=r.isDflowId(t.id)?t.id:this.#t.generateNodeId(),n={isAsync:e.isAsync,isConstant:e.isConstant,label:e.label},i=Array.isArray(t.inputs)?t.inputs:p.generateInputIds(e.inputs),o=Array.isArray(t.outputs)?t.outputs:p.generateOutputIds(e.outputs),u=new e({...t,id:s,inputs:i,outputs:o},this,n);return this.#t.addNode(u),u}newEdge(t){const e=r.isDflowId(t.id)?t.id:this.#t.generateEdgeId(),s=new I({...t,id:e});this.#t.addEdge(s);const[n,i]=s.source,[o,u]=s.target,h=this.#t.getNodeById(n),d=this.#t.getNodeById(o),y=h.getOutputById(i);return d.getInputById(u).connectTo(y),s}newInput(t,e){return this.#t.getNodeById(t).newInput(e)}newOutput(t,e){return this.#t.getNodeById(t).newOutput(e)}toJSON(){return this.#t.toJSON()}toObject(){return this.#t.toObject()}async run(){await this.#t.run()}}export{r as DflowData};export{g as DflowItem};export{f as DflowPin};export{w as DflowInput};export{N as DflowOutput};export{p as DflowNode};export{m as DflowUnknownNode};export{I as DflowEdge};export{a as DflowGraph};export{B as DflowHost};
