const generateItemId=(itemMap,idPrefix,wantedId)=>{if(wantedId&&!itemMap.has(wantedId))return wantedId;const id=`${idPrefix}${itemMap.size}`;return itemMap.has(id)?generateItemId(itemMap,idPrefix):id};class Dflow{context;nodesCatalog;nodesMap=new Map;edgesMap=new Map;runStatus=null;executionReport=null;constructor({nodesCatalog:nodesCatalog2}){this.nodesCatalog={...nodesCatalog2,...coreNodesCatalog};this.context={}}static dataTypes=["null","boolean","number","string","array","object","DflowId"];clear(){this.nodesMap.clear();this.edgesMap.clear()}connect(sourceNode,sourcePosition=0){return{to:(targetNode,targetPosition=0)=>{const sourceOutput=sourceNode.output(sourcePosition);const targetInput=targetNode.input(targetPosition);this.newEdge({source:[sourceNode.id,sourceOutput.id],target:[targetNode.id,targetInput.id]})}}}deleteEdge(edgeId){const edge=this.getEdgeById(edgeId);const[targetNodeId,targetInputId]=edge.target;const targetNode=this.getNodeById(targetNodeId);const targetInput=targetNode.getInputById(targetInputId);targetInput.source=void 0;this.edgesMap.delete(edgeId)}deleteNode(nodeId){const node=this.getNodeById(nodeId);for(const edge of this.edges){const{source:[sourceNodeId],target:[targetNodeId]}=edge;if(sourceNodeId===node.id||targetNodeId===node.id){this.deleteEdge(edge.id)}}this.nodesMap.delete(nodeId)}executeFunction(functionId,args){const nodeConnections=this.nodeConnections;const childrenNodeIds=Dflow.childrenOfNodeId(functionId,nodeConnections);const returnNodeIds=[];for(const childrenNodeId of childrenNodeIds){const node=this.getNodeById(childrenNodeId);if(node.kind===DflowNodeReturn.kind){returnNodeIds.push(node.id)}}const nodeIdsInsideFunction=returnNodeIds.reduce((accumulator,returnNodeId,index,array)=>{const ancestors=Dflow.ancestorsOfNodeId(returnNodeId,nodeConnections);const result=accumulator.concat(ancestors);return index===array.length?[...new Set(result)]:result},[]);const nodeIds=Dflow.sortNodesByLevel([...returnNodeIds,...nodeIdsInsideFunction],nodeConnections);for(const nodeId of nodeIds){const node=this.getNodeById(nodeId);try{switch(node.kind){case DflowNodeArgument.kind:{const position=node.input(0).data;const index=typeof position==="number"&&!isNaN(position)?Math.max(position,0):0;node.output(0).data=args[index];break}case DflowNodeReturn.kind:{return node.input(1).data}default:{if(node.run.constructor.name==="AsyncFunction"){throw new DflowErrorCannotExecuteAsyncFunction}node.run();this.executionReport?.steps?.push(Dflow.executionNodeInfo(node))}}}catch(error){console.error(error)}}}getEdgeById(id){const item=this.edgesMap.get(id);if(!item)throw new DflowErrorItemNotFound("edge",{id});return item}getNodeById(id){const item=this.nodesMap.get(id);if(!item)throw new DflowErrorItemNotFound("node",{id});return item}newNode(arg){const NodeClass=this.nodesCatalog[arg.kind]??DflowNodeUnknown;const id=generateItemId(this.nodesMap,"n",arg.id);const inputs=NodeClass.inputs?.map((definition,i)=>{const obj=arg.inputs?.[i];const id2=obj?.id??`i${i}`;return{id:id2,...obj,...definition}})??[];const outputs=NodeClass.outputs?.map((definition,i)=>{const obj=arg.outputs?.[i];const id2=obj?.id??`o${i}`;return{id:id2,...obj,...definition}})??[];const node=new NodeClass({id,kind:arg.kind,host:this,inputs,outputs});this.nodesMap.set(node.id,node);return node}newEdge(arg){const id=generateItemId(this.edgesMap,"e",arg.id);const edge={...arg,id};this.edgesMap.set(edge.id,edge);const[sourceNodeId,sourceOutputId]=edge.source;const[targetNodeId,targetInputId]=edge.target;const sourceNode=this.getNodeById(sourceNodeId);const targetNode=this.getNodeById(targetNodeId);const sourceOutput=sourceNode.getOutputById(sourceOutputId);const targetInput=targetNode.getInputById(targetInputId);if(!Dflow.canConnect(sourceOutput.types,targetInput.types)){throw new DflowErrorCannotConnectSourceToTarget({source:[sourceNode.id,sourceOutput.id],target:[targetNode.id,targetInput.id]})}targetInput.source=sourceOutput;return edge}get edges(){return[...this.edgesMap.values()].map(({id,source,target})=>({id,source,target}))}get nodes(){return[...this.nodesMap.values()].map(item=>item.toJSON())}get nodeConnections(){return[...this.edgesMap.values()].map(edge=>({sourceId:edge.source[0],targetId:edge.target[0]}))}get nodeIdsInsideFunctions(){const ancestorsOfReturnNodes=[];for(const node of[...this.nodesMap.values()]){if(node.kind==="return"){ancestorsOfReturnNodes.push(Dflow.ancestorsOfNodeId(node.id,this.nodeConnections))}}return[...new Set(ancestorsOfReturnNodes.flat())]}async run(){this.runStatus="running";const executionReport={status:this.runStatus,start:Date.now(),end:Date.now(),steps:[]};const nodeIdsExcluded=this.nodeIdsInsideFunctions;const nodeIds=Dflow.sortNodesByLevel([...this.nodesMap.keys()].filter(nodeId=>!nodeIdsExcluded.includes(nodeId)),this.nodeConnections);for(const nodeId of nodeIds){const node=this.nodesMap.get(nodeId);try{if(!node.inputsDataAreValid){const error=new DflowErrorInvalidInputData(nodeId);executionReport.steps.push(Dflow.executionNodeInfo(node,error.toJSON()));node.clearOutputs();continue}if(node.run.constructor.name==="AsyncFunction"){await node.run()}else{node.run()}executionReport.steps.push(Dflow.executionNodeInfo(node))}catch(error){console.error(error);this.runStatus="failure"}}if(this.runStatus==="running")this.runStatus="success";executionReport.status=this.runStatus;executionReport.end=Date.now();this.executionReport=executionReport}toJSON(){return{nodes:[...this.nodesMap.values()].map(item=>item.toJSON()),edges:[...this.edgesMap.values()].map(({id,source:s,target:t})=>({id,s,t}))}}static ancestorsOfNodeId(nodeId,nodeConnections){const parentsNodeIds=Dflow.parentsOfNodeId(nodeId,nodeConnections);if(parentsNodeIds.length===0)return[];return parentsNodeIds.reduce((accumulator,parentNodeId,index,array)=>{const ancestors=Dflow.ancestorsOfNodeId(parentNodeId,nodeConnections);const result=accumulator.concat(ancestors);return index===array.length-1?[...new Set(array.concat(result))]:result},[])}static canConnect(sourceTypes,targetTypes){if(sourceTypes.length===0||targetTypes.length===0)return true;return targetTypes.some(dataType=>sourceTypes.includes(dataType))}static childrenOfNodeId(nodeId,nodeConnections){return nodeConnections.filter(({sourceId})=>nodeId===sourceId).map(({targetId})=>targetId)}static executionNodeInfo=(node,error)=>{const{id,k,o}=node.toJSON();const info={id,k};if(o)info.o=o;if(error)info.err=error;return info};static inferDataType(arg){if(arg===null)return["null"];if(typeof arg==="boolean")return["boolean"];if(typeof arg==="string")return["string"];if(Dflow.isNumber(arg))return["number"];if(Dflow.isArray(arg))return["array"];if(Dflow.isObject(arg))return["object"];return[]}static levelOfNodeId(nodeId,nodeConnections){const parentsNodeIds=Dflow.parentsOfNodeId(nodeId,nodeConnections);if(parentsNodeIds.length===0)return 0;let maxLevel=0;for(const parentNodeId of parentsNodeIds){const level=Dflow.levelOfNodeId(parentNodeId,nodeConnections);maxLevel=Math.max(level,maxLevel)}return maxLevel+1}static input(typing=[],rest){return{types:typeof typing==="string"?[typing]:typing,...rest}}static output(typing=[],rest){return{types:typeof typing==="string"?[typing]:typing,...rest}}static parentsOfNodeId(nodeId,nodeConnections){return nodeConnections.filter(({targetId})=>nodeId===targetId).map(({sourceId})=>sourceId)}static sortNodesByLevel(nodeIds,nodeConnections){const levelOf={};for(const nodeId of nodeIds){levelOf[nodeId]=Dflow.levelOfNodeId(nodeId,nodeConnections)}return nodeIds.slice().sort((a,b)=>levelOf[a]<=levelOf[b]?-1:1)}static isArray(arg){return Array.isArray(arg)&&arg.every(Dflow.isDflowData)}static isDflowId(arg){return typeof arg==="string"&&arg!==""||typeof arg==="number"}static isObject(arg){return typeof arg==="object"&&arg!==null&&!Array.isArray(arg)&&Object.values(arg).every(Dflow.isDflowData)}static isNumber(arg){return typeof arg==="number"&&!isNaN(arg)&&Number.isFinite(arg)}static isDflowData(arg){if(arg===void 0)return false;return arg===null||typeof arg==="boolean"||typeof arg==="string"||Dflow.isNumber(arg)||Dflow.isObject(arg)||Dflow.isArray(arg)||Dflow.isDflowId(arg)}static isValidDataType(types,data){if(types.length===0)return true;return types.some(dataType=>dataType==="null"?data===null:dataType==="boolean"?typeof data==="boolean":dataType==="string"?typeof data==="string":dataType==="number"?Dflow.isNumber(data):dataType==="object"?Dflow.isObject(data):dataType==="array"?Dflow.isArray(data):dataType==="DflowId"?Dflow.isDflowId(data):false)}}class DflowInput{id;name;nodeId;types;source;optional;constructor({id,name,nodeId,optional,types}){if(name)this.name=name;this.types=types;this.nodeId=nodeId;this.id=id;if(optional)this.optional=optional}get data(){return this.source?.data}toJSON(){return{id:this.id}}}class DflowOutput{id;name;nodeId;types;value;constructor({id,data,name,nodeId,types}){if(name)this.name=name;this.types=types;this.nodeId=nodeId;this.id=id;this.value=data}get data(){return this.value}set data(arg){if(arg===void 0){this.value===void 0;return}const{types}=this;if(types.length===0&&Dflow.isDflowData(arg)||types.includes("null")&&arg===null||types.includes("boolean")&&typeof arg==="boolean"||types.includes("string")&&typeof arg==="string"||types.includes("number")&&Dflow.isNumber(arg)||types.includes("object")&&Dflow.isObject(arg)||types.includes("array")&&Dflow.isArray(arg)||types.includes("DflowId")&&Dflow.isDflowId(arg)){this.value=arg}}clear(){this.value=void 0}toJSON(){const obj={id:this.id};if(this.value!==void 0)obj.d=this.value;return obj}}class DflowNode{id;inputsMap=new Map;outputsMap=new Map;inputPosition=[];outputPosition=[];kind;host;constructor({id,kind,inputs=[],outputs=[],host}){this.id=id;this.host=host;this.kind=kind;for(const obj of inputs){const id2=generateItemId(this.inputsMap,"i",obj.id);const input11=new DflowInput({...obj,id:id2,nodeId:this.id});this.inputsMap.set(id2,input11);this.inputPosition.push(id2)}for(const obj of outputs){const id2=generateItemId(this.outputsMap,"o",obj.id);const output10=new DflowOutput({...obj,id:id2,nodeId:this.id});this.outputsMap.set(id2,output10);this.outputPosition.push(id2)}}get inputsDataAreValid(){for(const{data,types,optional}of this.inputsMap.values()){if(optional&&data===void 0)continue;if(Dflow.isValidDataType(types,data))continue;return false}return true}clearOutputs(){for(const output10 of this.outputsMap.values())output10.clear()}getInputById(id){const item=this.inputsMap.get(id);if(!item)throw new DflowErrorItemNotFound("input",{id});return item}input(position){const id=this.inputPosition[position];if(!id){throw new DflowErrorItemNotFound("input",{id:this.id,nodeId:this.id,position})}return this.getInputById(id)}getOutputById(id){const item=this.outputsMap.get(id);if(!item){throw new DflowErrorItemNotFound("output",{id,nodeId:this.id})}return item}output(position){const id=this.outputPosition[position];if(!id){throw new DflowErrorItemNotFound("output",{nodeId:this.id,position})}return this.getOutputById(id)}run(){}toJSON(){const obj={id:this.id,k:this.kind};const inputs=[...this.inputsMap.values()].map(item=>item.toJSON());if(inputs.length>0)obj.i=inputs;const outputs=[...this.outputsMap.values()].map(item=>item.toJSON());if(outputs.length>0)obj.o=outputs;return obj}}const{input,output}=Dflow;class DflowNodeArgument extends DflowNode{static kind="argument";static inputs=[input("number",{name:"position",optional:true})];static outputs=[output()]}class DflowNodeData extends DflowNode{static kind="data";static outputs=[output()];constructor({outputs,...rest}){super({outputs:outputs?.map(output10=>({...output10,types:Dflow.inferDataType(output10.data)})),...rest})}}class DflowNodeFunction extends DflowNode{static kind="function";static outputs=[output("DflowId",{name:"id"})];constructor(arg){super(arg);this.output(0).data=this.id}}class DflowNodeReturn extends DflowNode{static kind="return";static inputs=[input("DflowId",{name:"functionId"}),input([],{name:"value"})]}class DflowNodeUnknown extends DflowNode{}const coreNodesCatalog={[DflowNodeArgument.kind]:DflowNodeArgument,[DflowNodeData.kind]:DflowNodeData,[DflowNodeFunction.kind]:DflowNodeFunction,[DflowNodeReturn.kind]:DflowNodeReturn};class DflowErrorCannotConnectSourceToTarget extends Error{source;target;static code="01";static message({s,t}){return`Cannot connect source ${s.join()} to target ${t.join()}`}constructor({source,target}){super(DflowErrorCannotConnectSourceToTarget.message({s:source,t:target}));this.source=source;this.target=target}toJSON(){return{_:DflowErrorCannotConnectSourceToTarget.code,s:this.source,t:this.target}}}class DflowErrorInvalidInputData extends Error{static code="02";nodeId;static message({nId:nodeId}){return`Invalid input data in node ${nodeId}`}constructor(nodeId){super(DflowErrorInvalidInputData.message({nId:nodeId}));this.nodeId=nodeId}toJSON(){return{_:DflowErrorInvalidInputData.code,nId:this.nodeId}}}class DflowErrorItemNotFound extends Error{static code="03";item;info;static message({item,id,nId:nodeId,p:position}){return`Not found ${[`item=${item}`,id?`id=${id}`:"",nodeId?`nodeId=${nodeId}`:"",position?`position=${position}`:""].filter(str=>str!=="").join()}`}constructor(item,info={}){super(DflowErrorItemNotFound.message({item,id:info.id,nId:info.nodeId,p:info.position}));this.item=item;this.info=info}toJSON(){const{item,info:{id,nodeId,position}}=this;const obj={item,_:DflowErrorItemNotFound.code};if(id)obj.id=id;if(nodeId)obj.nId=nodeId;if(position)obj.p=position;return obj}}class DflowErrorCannotExecuteAsyncFunction extends Error{static code="04";static message(){return"dflow executeFunction() cannot execute async functions"}constructor(){super(DflowErrorCannotExecuteAsyncFunction.message())}toJSON(){return{_:DflowErrorCannotExecuteAsyncFunction.code}}}const{input:input1,output:output1}=Dflow;class DflowArrayAt extends DflowNode{static kind="arrayAt";static inputs=[input1("array"),input1("number",{name:"index"})];static outputs=[output1()];run(){const array=this.input(0).data;const index=this.input(1).data;this.output(0).data=array.at(index)}}class DflowArrayFilter extends DflowNode{static kind="arrayFilter";static inputs=[input1("array"),input1("DflowId",{name:"functionId"})];static outputs=[output1("array")];run(){this.output(0).data=this.input(0).data.filter((...args)=>this.host.executeFunction(this.input(1).data,args))}}class DflowArrayFindLastIndex extends DflowNode{static kind="arrayFindLastIndex";static inputs=[input1("array"),input1("DflowId",{name:"functionId"})];static outputs=[output1("number")];run(){this.output(0).data=this.input(0).data.findLastIndex((...args)=>this.host.executeFunction(this.input(1).data,args))}}class DflowArrayFindIndex extends DflowNode{static kind="arrayFindIndex";static inputs=[input1("array"),input1("DflowId",{name:"functionId"})];static outputs=[output1("number")];run(){this.output(0).data=this.input(0).data.findIndex((...args)=>this.host.executeFunction(this.input(1).data,args))}}class DflowArrayIncludes extends DflowNode{static kind="arrayIncludes";static inputs=[input1("array",{name:"array"}),input1("string",{name:"element"})];static outputs=[output1("boolean")];run(){const data=this.input(0).data;const element=this.input(1).data;if(Array.isArray(data)&&typeof element!=="undefined"){this.output(0).data=data.includes(element)}}}class DflowArrayJoin extends DflowNode{static kind="arrayJoin";static inputs=[input1("array",{name:"array"}),input1("string",{name:"separator",optional:true})];static outputs=[output1("string")];run(){this.output(0).data=this.input(0).data.join(this.input(1).data)}}class DflowArrayLength extends DflowNode{static kind="arrayLength";static inputs=[input1("array")];static outputs=[output1("number")];run(){const data=this.input(0).data;if(Array.isArray(data)){this.output(0).data=data.length}else{this.output(0).clear}}}class DflowArrayMap extends DflowNode{static kind="arrayMap";static inputs=[input1("array"),input1("DflowId",{name:"functionId"})];static outputs=[output1("array")];run(){this.output(0).data=this.input(0).data.map((...args)=>this.host.executeFunction(this.input(1).data,args))}}class DflowArrayPop extends DflowNode{static kind="arrayPop";static inputs=[input1("array")];static outputs=[output1([],{name:"element"}),output1("array",{name:"rest"})];run(){const array=this.input(0).data.slice();const element=array.pop();this.output(0).data=element;this.output(1).data=array}}class DflowArrayPush extends DflowNode{static kind="arrayPush";static inputs=[input1("array"),input1([],{name:"element"})];static outputs=[output1("array")];run(){const array=this.input(0).data.slice();const element=this.input(1).data;if(element){array.push(element)}this.output(0).data=array}}class DflowArrayReverse extends DflowNode{static kind="arrayReverse";static inputs=[input1("array")];static outputs=[input1("array")];run(){const array=this.input(0).data.slice();this.output(0).data=array.reverse()}}class DflowArrayShift extends DflowNode{static kind="arrayShift";static inputs=[input1("array")];static outputs=[output1([],{name:"element"}),output1("array",{name:"rest"})];run(){const array=this.input(0).data.slice();const element=array.shift();this.output(0).data=element;this.output(1).data=array}}class DflowArraySlice extends DflowNode{static kind="arraySlice";static inputs=[input1("array"),input1("number",{name:"start"}),input1("number",{name:"end",optional:true})];static outputs=[output1("array")];run(){const array=super.input(0).data;const start=super.input(1).data;const end=super.input(2).data;if(typeof end==="number"){super.output(0).data=array.slice(start,end)}else{super.output(0).data=array.slice(start)}}}const catalog={[DflowArrayAt.kind]:DflowArrayAt,[DflowArrayFilter.kind]:DflowArrayFilter,[DflowArrayFindLastIndex.kind]:DflowArrayFindLastIndex,[DflowArrayFindIndex.kind]:DflowArrayFindIndex,[DflowArrayIncludes.kind]:DflowArrayIncludes,[DflowArrayJoin.kind]:DflowArrayJoin,[DflowArrayLength.kind]:DflowArrayLength,[DflowArrayMap.kind]:DflowArrayMap,[DflowArrayPop.kind]:DflowArrayPop,[DflowArrayPush.kind]:DflowArrayPush,[DflowArrayReverse.kind]:DflowArrayReverse,[DflowArrayShift.kind]:DflowArrayShift,[DflowArraySlice.kind]:DflowArraySlice};const{input:input2,output:output2}=Dflow;class DflowNodeIf extends DflowNode{static kind="if";static inputs=[input2([],{name:"condition"}),input2([],{name:"then"}),input2([],{name:"else"})];static outputs=[output2()];run(){this.output(0).data=this.input(0).data?this.input(1).data:this.input(2).data}}const catalog1={[DflowNodeIf.kind]:DflowNodeIf};const{input:input3}=Dflow;class DflowConsoleLog extends DflowNode{static kind="consoleLog";static inputs=[input3()];run(){console.log(this.input(0).data)}}const catalog2={[DflowConsoleLog.kind]:DflowConsoleLog};const{input:input4,output:output3}=Dflow;const dateOutputs=[output3("string"),output3("number",{name:"milliseconds"})];class DflowDateNew extends DflowNode{static kind="newDate";static inputs=[input4(["string","number"],{optional:true})];static outputs=dateOutputs;run(){const input11=this.input(0).data;if(typeof input11==="string"||typeof input11==="number"){const date=new Date(input11);const serializedDate=date.toJSON();if(serializedDate!==null){this.output(0).data=serializedDate;this.output(1).data=date.getTime()}}const d=new Date;this.output(0).data=d.toJSON();this.output(1).data=d.getTime()}}class DflowDateNow extends DflowNode{static kind="now";static outputs=dateOutputs;run(){const now=Date.now();this.output(0).data=new Date(now).toJSON();this.output(1).data=now}}const catalog3={[DflowDateNew.kind]:DflowDateNew,[DflowDateNow.kind]:DflowDateNow};const{input:input5,output:output4}=Dflow;class DflowNodeAnd extends DflowNode{static kind="and";static inputs=[input5("boolean"),input5("boolean")];static outputs=[output4("boolean")];run(){this.output(0).data=this.input(0).data&&this.input(1).data}}class DflowNodeNot extends DflowNode{static kind="not";static inputs=[input5("boolean")];static outputs=[output4("boolean")];run(){this.output(0).data=!this.input(0).data}}class DflowNodeNullishCoaleshing extends DflowNode{static kind="??";static inputs=[input5(),input5()];static outputs=[output4()];run(){this.output(0).data=this.input(0).data??this.input(1).data}}class DflowNodeOr extends DflowNode{static kind="or";static inputs=[input5("boolean"),input5("boolean")];static outputs=[output4("boolean")];run(){this.output(0).data=this.input(0).data||this.input(1).data}}const catalog4={[DflowNodeAnd.kind]:DflowNodeAnd,[DflowNodeNot.kind]:DflowNodeNot,[DflowNodeNullishCoaleshing.kind]:DflowNodeNullishCoaleshing,[DflowNodeOr.kind]:DflowNodeOr};const{input:input6,output:output5}=Dflow;class DflowMathAbs extends DflowNode{static kind="mathAbs";static inputs=[input6("number")];static outputs=[output5("number")];run(){this.output(0).data=Math.abs(this.input(0).data)}}class DflowMathCos extends DflowNode{static kind="mathCos";static inputs=[input6("number")];static outputs=[output5("number")];run(){this.output(0).data=Math.cos(this.input(0).data)}}class DflowMathCosh extends DflowNode{static kind="mathCosh";static inputs=[input6("number")];static outputs=[output5("number")];run(){this.output(0).data=Math.cosh(this.input(0).data)}}class DflowMathFloor extends DflowNode{static kind="mathFloor";static inputs=[input6("number")];static outputs=[output5("number")];run(){this.output(0).data=Math.floor(this.input(0).data)}}class DflowMathMax extends DflowNode{static kind="mathMax";static inputs=[input6("array")];static outputs=[output5("number")];run(){const list=this.input(0).data;const data=Math.max(...list);if(isNaN(data)){this.output(0).clear()}else{this.output(0).data=data}}}class DflowMathMin extends DflowNode{static kind="mathMin";static inputs=[input6("array")];static outputs=[output5("number")];run(){const list=this.input(0).data;const data=Math.min(...list);if(isNaN(data)){this.output(0).clear()}else{this.output(0).data=data}}}class DflowMathPI extends DflowNode{static kind="mathPI";static outputs=[output5("number",{name:"\u03C0",data:Math.PI})]}class DflowMathRound extends DflowNode{static kind="mathRound";static inputs=[input6("number")];static outputs=[output5("number")];run(){this.output(0).data=Math.round(this.input(0).data)}}class DflowMathSin extends DflowNode{static kind="mathSin";static inputs=[input6("number")];static outputs=[output5("number")];run(){this.output(0).data=Math.sin(this.input(0).data)}}class DflowMathSinh extends DflowNode{static kind="mathSinh";static inputs=[input6("number")];static outputs=[output5("number")];run(){this.output(0).data=Math.sinh(this.input(0).data)}}const catalog5={[DflowMathAbs.kind]:DflowMathAbs,[DflowMathCos.kind]:DflowMathCos,[DflowMathCosh.kind]:DflowMathCosh,[DflowMathFloor.kind]:DflowMathFloor,[DflowMathMax.kind]:DflowMathMax,[DflowMathMin.kind]:DflowMathMin,[DflowMathPI.kind]:DflowMathPI,[DflowMathRound.kind]:DflowMathRound,[DflowMathSin.kind]:DflowMathSin,[DflowMathSinh.kind]:DflowMathSinh};const{input:input7,output:output6}=Dflow;class DflowIsFinite extends DflowNode{static kind="isFinite";static inputs=[input7()];static outputs=[output6("boolean")];run(){this.output(0).data=Number.isFinite(this.input(0).data)}}class DflowIsInteger extends DflowNode{static kind="isInteger";static inputs=[input7()];static outputs=[output6("boolean")];run(){this.output(0).data=Number.isInteger(this.input(0).data)}}class DflowParseFloat extends DflowNode{static kind="parseFloat";static inputs=[input7("string")];static outputs=[output6("number")];run(){this.output(0).data=parseFloat(this.input(0).data)}}class DflowParseInt extends DflowNode{static kind="parseInt";static inputs=[input7(["number","string"])];static outputs=[output6("number")];run(){this.output(0).data=parseInt(this.input(0).data)}}const catalog6={[DflowIsFinite.kind]:DflowIsFinite,[DflowIsInteger.kind]:DflowIsInteger,[DflowParseFloat.kind]:DflowParseFloat,[DflowParseInt.kind]:DflowParseInt};const{input:input8,output:output7}=Dflow;class DflowObjectKeys extends DflowNode{static kind="objectKeys";static inputs=[input8("object")];static outputs=[output7("array")];run(){this.output(0).data=Object.keys(this.input(0).data)}}class DflowObjectValues extends DflowNode{static kind="objectValues";static inputs=[input8("object")];static outputs=[output7("array")];run(){this.output(0).data=Object.values(this.input(0).data)}}const catalog7={[DflowObjectKeys.kind]:DflowObjectKeys,[DflowObjectValues.kind]:DflowObjectValues};const{input:input9,output:output8}=Dflow;class DflowAddition extends DflowNode{static kind="addition";static inputs=[input9("number"),input9("number")];static outputs=[output8("number")];run(){this.output(0).data=this.input(0).data+this.input(1).data}}class DflowDivision extends DflowNode{static kind="division";static inputs=[input9("number"),input9("number")];static outputs=[output8("number")];run(){if(this.input(1).data){this.output(0).data=this.input(0).data/this.input(1).data}else{this.output(0).clear()}}}class DflowEquality extends DflowNode{static kind="equality";static inputs=[input9(),input9()];static outputs=[output8("boolean")];run(){this.output(0).data=this.input(0).data==this.input(1).data}}class DflowLessThan extends DflowNode{static kind="lessThan";static inputs=[input9("number"),input9("number")];static outputs=[output8("boolean")];run(){this.output(0).data=this.input(0).data<this.input(1).data}}class DflowLessThanOrEqual extends DflowNode{static kind="lessThanOrEqual";static inputs=[input9("number"),input9("number")];static outputs=[output8("boolean")];run(){this.output(0).data=this.input(0).data<=this.input(1).data}}class DflowGreaterThan extends DflowNode{static kind="greaterThan";static inputs=[input9("number"),input9("number")];static outputs=[output8("boolean")];run(){this.output(0).data=this.input(0).data>this.input(1).data}}class DflowGreaterThanOrEqual extends DflowNode{static kind="greaterThanOrEqual";static inputs=[input9("number"),input9("number")];static outputs=[output8("boolean")];run(){this.output(0).data=this.input(0).data>=this.input(1).data}}class DflowInequality extends DflowNode{static kind="inequality";static inputs=[input9(),input9()];static outputs=[output8("boolean")];run(){this.output(0).data=this.input(0).data!=this.input(1).data}}class DflowMultiplication extends DflowNode{static kind="multiplication";static inputs=[input9("number"),input9("number")];static outputs=[output8("number")];run(){this.output(0).data=this.input(0).data*this.input(1).data}}class DflowSubtraction extends DflowNode{static kind="subtraction";static inputs=[input9("number"),input9("number")];static outputs=[output8("number")];run(){this.output(0).data=this.input(0).data-this.input(1).data}}const catalog8={[DflowAddition.kind]:DflowAddition,[DflowDivision.kind]:DflowDivision,[DflowEquality.kind]:DflowEquality,[DflowGreaterThan.kind]:DflowGreaterThan,[DflowGreaterThanOrEqual.kind]:DflowGreaterThanOrEqual,[DflowLessThan.kind]:DflowLessThan,[DflowLessThanOrEqual.kind]:DflowLessThanOrEqual,[DflowInequality.kind]:DflowInequality,[DflowMultiplication.kind]:DflowMultiplication,[DflowSubtraction.kind]:DflowSubtraction};const{input:input10,output:output9}=Dflow;class DflowNodeStringLength extends DflowNode{static kind="stringLength";static inputs=[input10("string")];static outputs=[output9("number")];run(){this.output(0).data=this.input(0).data.length}}class DflowNodeSubstring extends DflowNode{static kind="substring";static inputs=[input10("string"),input10("number",{name:"start"}),input10("number",{name:"end",optional:true})];static outputs=[output9("string")];run(){const str=this.input(0).data;const start=this.input(1).data;const end=this.input(2).data;this.output(0).data=str.substring(start,end)}}const catalog9={[DflowNodeSubstring.kind]:DflowNodeSubstring,[DflowNodeStringLength.kind]:DflowNodeStringLength};const nodesCatalog={...catalog,...catalog1,...catalog2,...catalog3,...catalog4,...catalog5,...catalog6,...catalog7,...catalog8,...catalog9};export{nodesCatalog};
