const generateItemId=(itemMap,idPrefix,wantedId)=>{if(wantedId&&!itemMap.has(wantedId))return wantedId;const id=`${idPrefix}${itemMap.size}`;return itemMap.has(id)?generateItemId(itemMap,idPrefix):id};export class Dflow{static dataTypes=["string","number","boolean","object","array","DflowId"];static inferDataType(arg){if(Dflow.isBoolean(arg))return["boolean"];if(Dflow.isNumber(arg))return["number"];if(Dflow.isString(arg))return["string"];if(Dflow.isArray(arg))return["array"];if(Dflow.isObject(arg))return["object"];return[]}static isArray(arg){return Array.isArray(arg)&&arg.every(Dflow.isDflowData)}static isBoolean(arg){return typeof arg==="boolean"}static isDflowId(arg){return typeof arg==="string"&&arg!==""}static isObject(arg){return typeof arg==="object"&&arg!==null&&!Array.isArray(arg)&&Object.values(arg).every(Dflow.isDflowData)}static isNumber(arg){return typeof arg==="number"&&!isNaN(arg)&&Number.isFinite(arg)}static isString(arg){return typeof arg==="string"}static isDflowData(arg){if(arg===void 0)return false;return Dflow.isString(arg)||Dflow.isBoolean(arg)||Dflow.isNumber(arg)||Dflow.isObject(arg)||Dflow.isArray(arg)||Dflow.isDflowId(arg)}static isValidDataType(types,data){const isAnyType=types.length===0;if(isAnyType)return true;return types.some(pinType=>{switch(pinType){case"array":return Dflow.isArray(data);case"boolean":return Dflow.isBoolean(data);case"number":return Dflow.isNumber(data);case"object":return Dflow.isObject(data);case"string":return Dflow.isString(data);case"DflowId":return Dflow.isDflowId(data);default:return false}})}}export class DflowPin{name;nodeId;types;constructor({nodeId,name,types=[]}){if(name)this.name=name;this.types=types;this.nodeId=nodeId}static canConnect(sourceTypes,targetTypes){const sourceHasTypeAny=sourceTypes.length===0;if(sourceHasTypeAny)return true;const targetHasTypeAny=targetTypes.length===0;if(targetHasTypeAny)return true;return targetTypes.some(pinType=>sourceTypes.includes(pinType))}get hasTypeAny(){return this.types.length===0}hasType(type){return this.hasTypeAny||this.types.includes(type)}}export class DflowInput extends DflowPin{id;source;optional;constructor({id,optional,...pin}){super(pin);this.id=id;if(optional)this.optional=optional}get data(){return this.source?.data}get isConnected(){return this.source!==void 0}connectTo(pin){if(!DflowPin.canConnect(pin.types,this.types)){throw new DflowErrorCannotConnectPins({source:[pin.nodeId,pin.id],target:[this.nodeId,this.id]})}this.source=pin}disconnect(){this.source=void 0}toObject(){return{id:this.id}}}export class DflowOutput extends DflowPin{id;value;constructor({id,data,...pin}){super(pin);this.id=id;this.value=data}get data(){return this.value}set data(arg){if(arg===void 0){this.clear();return}if(this.hasType("string")&&Dflow.isString(arg)||this.hasType("number")&&Dflow.isNumber(arg)||this.hasType("boolean")&&Dflow.isBoolean(arg)||this.hasType("object")&&Dflow.isObject(arg)||this.hasType("array")&&Dflow.isArray(arg)||this.hasType("DflowId")&&Dflow.isDflowId(arg)||this.hasTypeAny&&Dflow.isDflowData(arg)){this.value=arg}else this.clear()}clear(){this.value=void 0}toObject(){const obj={id:this.id};if(this.value!==void 0)obj.d=this.value;return obj}}export class DflowNode{id;inputsMap=new Map;outputsMap=new Map;inputPosition=[];outputPosition=[];kind;host;constructor({id,kind,inputs=[],outputs=[],host}){this.id=id;this.host=host;this.kind=kind;for(const obj of inputs){const id2=generateItemId(this.inputsMap,"i",obj.id);const input2=new DflowInput({...obj,id:id2,nodeId:this.id});this.inputsMap.set(id2,input2);this.inputPosition.push(id2)}for(const obj of outputs){const id2=generateItemId(this.outputsMap,"o",obj.id);const output2=new DflowOutput({...obj,id:id2,nodeId:this.id});this.outputsMap.set(id2,output2);this.outputPosition.push(id2)}}static input(typing=[],rest){return{types:typeof typing==="string"?[typing]:typing,...rest}}static output(typing=[],rest){return{types:typeof typing==="string"?[typing]:typing,...rest}}get inputsDataAreValid(){for(const{data,types,optional}of this.inputsMap.values()){if(optional&&data===void 0)continue;if(Dflow.isValidDataType(types,data))continue;return false}return true}clearOutputs(){for(const output2 of this.outputsMap.values())output2.clear()}getInputById(id){const item=this.inputsMap.get(id);if(!item)throw new DflowErrorItemNotFound("input",{id});return item}input(position){const pinId=this.inputPosition[position];if(!pinId){throw new DflowErrorItemNotFound("input",{id:this.id,nodeId:this.id,position})}return this.getInputById(pinId)}getOutputById(id){const item=this.outputsMap.get(id);if(!item){throw new DflowErrorItemNotFound("output",{id,nodeId:this.id})}return item}output(position){const pinId=this.outputPosition[position];if(!pinId){throw new DflowErrorItemNotFound("output",{nodeId:this.id,position})}return this.getOutputById(pinId)}run(){}toObject(){const obj={id:this.id,k:this.kind};const inputs=[...this.inputsMap.values()].map(item=>item.toObject());if(inputs.length>0)obj.i=inputs;const outputs=[...this.outputsMap.values()].map(item=>item.toObject());if(outputs.length>0)obj.o=outputs;return obj}}export class DflowEdge{id;source;target;constructor({source,target,id}){this.id=id;this.source=source;this.target=target}toObject(){return{id:this.id,s:this.source,t:this.target}}}export class DflowGraph{nodesCatalog;nodesMap=new Map;edgesMap=new Map;runStatus=null;executionReport=null;constructor({nodesCatalog}){this.nodesCatalog={...nodesCatalog,...coreNodesCatalog}}static childrenOfNodeId(nodeId,nodeConnections){return nodeConnections.filter(({sourceId})=>nodeId===sourceId).map(({targetId})=>targetId)}static executionNodeInfo=(node,error)=>{const{id,k,o}=node.toObject();const info={id,k};if(o)info.o=o;if(error)info.err=error;return info};static parentsOfNodeId(nodeId,nodeConnections){return nodeConnections.filter(({targetId})=>nodeId===targetId).map(({sourceId})=>sourceId)}static ancestorsOfNodeId(nodeId,nodeConnections){const parentsNodeIds=DflowGraph.parentsOfNodeId(nodeId,nodeConnections);if(parentsNodeIds.length===0)return[];return parentsNodeIds.reduce((accumulator,parentNodeId,index,array)=>{const ancestors=DflowGraph.ancestorsOfNodeId(parentNodeId,nodeConnections);const result=accumulator.concat(ancestors);return index===array.length-1?[...new Set(array.concat(result))]:result},[])}static levelOfNodeId(nodeId,nodeConnections){const parentsNodeIds=DflowGraph.parentsOfNodeId(nodeId,nodeConnections);if(parentsNodeIds.length===0)return 0;let maxLevel=0;for(const parentNodeId of parentsNodeIds){const level=DflowGraph.levelOfNodeId(parentNodeId,nodeConnections);maxLevel=Math.max(level,maxLevel)}return maxLevel+1}get nodeConnections(){return[...this.edgesMap.values()].map(edge=>({sourceId:edge.source[0],targetId:edge.target[0]}))}get nodeIdsInsideFunctions(){const ancestorsOfReturnNodes=[];for(const node of[...this.nodesMap.values()]){if(node.kind==="return"){ancestorsOfReturnNodes.push(DflowGraph.ancestorsOfNodeId(node.id,this.nodeConnections))}}return[...new Set(ancestorsOfReturnNodes.flat())]}static sortNodesByLevel(nodeIds,nodeConnections){const levelOf={};for(const nodeId of nodeIds){levelOf[nodeId]=DflowGraph.levelOfNodeId(nodeId,nodeConnections)}return nodeIds.slice().sort((a,b)=>levelOf[a]<=levelOf[b]?-1:1)}async run(){this.runStatus="running";const executionReport={status:this.runStatus,start:new Date().toJSON(),end:new Date().toJSON(),steps:[]};const nodeIdsExcluded=this.nodeIdsInsideFunctions;const nodeIds=DflowGraph.sortNodesByLevel([...this.nodesMap.keys()].filter(nodeId=>!nodeIdsExcluded.includes(nodeId)),this.nodeConnections);for(const nodeId of nodeIds){const node=this.nodesMap.get(nodeId);try{if(!node.inputsDataAreValid){const error=new DflowErrorInvalidInputData(nodeId);executionReport.steps.push(DflowGraph.executionNodeInfo(node,error.toObject()));node.clearOutputs();continue}if(node.run.constructor.name==="AsyncFunction"){await node.run()}else{node.run()}executionReport.steps.push(DflowGraph.executionNodeInfo(node))}catch(error){console.error(error);this.runStatus="failure"}}if(this.runStatus==="running")this.runStatus="success";executionReport.status=this.runStatus;executionReport.end=new Date().toJSON();this.executionReport=executionReport}toObject(){return{nodes:[...this.nodesMap.values()].map(item=>item.toObject()),edges:[...this.edgesMap.values()].map(item=>item.toObject())}}}export class DflowHost{graph;context;constructor(arg){this.graph=new DflowGraph(arg);this.context={}}get executionReport(){return this.graph.executionReport}get edges(){return[...this.graph.edgesMap.values()].map(({id,source,target})=>({id,source,target}))}get nodes(){return[...this.graph.nodesMap.values()].map(item=>item.toObject())}get nodesCatalog(){return this.graph.nodesCatalog}get runStatus(){return this.graph.runStatus}clearGraph(){this.graph.nodesMap.clear();this.graph.edgesMap.clear()}connect(sourceNode,sourcePosition=0){return{to:(targetNode,targetPosition=0)=>{const sourcePin=sourceNode.output(sourcePosition);const targetPin=targetNode.input(targetPosition);this.newEdge({source:[sourceNode.id,sourcePin.id],target:[targetNode.id,targetPin.id]})}}}deleteEdge(edgeId){const edge=this.getEdgeById(edgeId);const[targetNodeId,targetPinId]=edge.target;const targetNode=this.getNodeById(targetNodeId);const targetPin=targetNode.getInputById(targetPinId);targetPin.disconnect();this.graph.edgesMap.delete(edgeId)}deleteNode(nodeId){const node=this.getNodeById(nodeId);for(const edge of this.edges){const{source:[sourceNodeId],target:[targetNodeId]}=edge;if(sourceNodeId===node.id||targetNodeId===node.id){this.deleteEdge(edge.id)}}this.graph.nodesMap.delete(nodeId)}executeFunction(functionId,args){const nodeConnections=this.graph.nodeConnections;const childrenNodeIds=DflowGraph.childrenOfNodeId(functionId,nodeConnections);const returnNodeIds=[];for(const childrenNodeId of childrenNodeIds){const node=this.getNodeById(childrenNodeId);if(node.kind===DflowNodeReturn.kind){returnNodeIds.push(node.id)}}const nodeIdsInsideFunction=returnNodeIds.reduce((accumulator,returnNodeId,index,array)=>{const ancestors=DflowGraph.ancestorsOfNodeId(returnNodeId,nodeConnections);const result=accumulator.concat(ancestors);return index===array.length?[...new Set(result)]:result},[]);const nodeIds=DflowGraph.sortNodesByLevel([...returnNodeIds,...nodeIdsInsideFunction],nodeConnections);for(const nodeId of nodeIds){const node=this.getNodeById(nodeId);try{switch(node.kind){case DflowNodeArgument.kind:{const position=node.input(0).data;const index=typeof position==="number"&&!isNaN(position)?Math.max(position,0):0;node.output(0).data=args[index];break}case DflowNodeReturn.kind:{return node.input(1).data}default:{if(node.run.constructor.name==="AsyncFunction"){throw new DflowErrorCannotExecuteAsyncFunction}node.run();this.executionReport?.steps?.push(DflowGraph.executionNodeInfo(node))}}}catch(error){console.error(error)}}}getEdgeById(id){const item=this.graph.edgesMap.get(id);if(!item)throw new DflowErrorItemNotFound("edge",{id});return item}getNodeById(id){const item=this.graph.nodesMap.get(id);if(!item)throw new DflowErrorItemNotFound("node",{id});return item}newNode(arg){const NodeClass=this.nodesCatalog[arg.kind]??DflowNodeUnknown;const id=generateItemId(this.graph.nodesMap,"n",arg.id);const inputs=NodeClass.inputs?.map((definition,i)=>{const obj=arg.inputs?.[i];const id2=obj?.id??`i${i}`;return{id:id2,...obj,...definition}})??[];const outputs=NodeClass.outputs?.map((definition,i)=>{const obj=arg.outputs?.[i];const id2=obj?.id??`o${i}`;return{id:id2,...obj,...definition}})??[];const node=new NodeClass({id,kind:arg.kind,host:this,inputs,outputs});this.graph.nodesMap.set(node.id,node);return node}newEdge(arg){const id=generateItemId(this.graph.edgesMap,"e",arg.id);const edge=new DflowEdge({...arg,id});this.graph.edgesMap.set(edge.id,edge);const[sourceNodeId,sourcePinId]=edge.source;const[targetNodeId,targetPinId]=edge.target;const sourceNode=this.getNodeById(sourceNodeId);const targetNode=this.getNodeById(targetNodeId);const sourcePin=sourceNode.getOutputById(sourcePinId);const targetPin=targetNode.getInputById(targetPinId);targetPin.connectTo(sourcePin);return edge}toObject(){return this.graph.toObject()}async run(){await this.graph.run()}}const{input,output}=DflowNode;class DflowNodeArgument extends DflowNode{static kind="argument";static inputs=[input("number",{name:"position",optional:true})];static outputs=[output()]}class DflowNodeData extends DflowNode{static kind="data";static outputs=[output()];constructor({outputs,...rest}){super({outputs:outputs?.map(output2=>({...output2,types:Dflow.inferDataType(output2.data)})),...rest})}}class DflowNodeFunction extends DflowNode{static kind="function";static outputs=[output("DflowId",{name:"id"})];constructor(arg){super(arg);this.output(0).data=this.id}}class DflowNodeReturn extends DflowNode{static kind="return";static inputs=[input("DflowId",{name:"functionId"}),input([],{name:"value"})]}export class DflowNodeUnknown extends DflowNode{}export const coreNodesCatalog={[DflowNodeArgument.kind]:DflowNodeArgument,[DflowNodeData.kind]:DflowNodeData,[DflowNodeFunction.kind]:DflowNodeFunction,[DflowNodeReturn.kind]:DflowNodeReturn};export class DflowErrorCannotConnectPins extends Error{source;target;static code="01";static message({s,t}){return`Cannot connect source ${s.join()} to target ${t.join()}`}constructor({source,target}){super(DflowErrorCannotConnectPins.message({s:source,t:target}));this.source=source;this.target=target}toObject(){return{_:DflowErrorCannotConnectPins.code,s:this.source,t:this.target}}}export class DflowErrorInvalidInputData extends Error{static code="02";nodeId;static message({nId:nodeId}){return`Invalid input data in node ${nodeId}`}constructor(nodeId){super(DflowErrorInvalidInputData.message({nId:nodeId}));this.nodeId=nodeId}toObject(){return{_:DflowErrorInvalidInputData.code,nId:this.nodeId}}}export class DflowErrorItemNotFound extends Error{static code="03";item;info;static message({item,id,nId:nodeId,p:position}){return`Not found ${[`item=${item}`,id?`id=${id}`:"",nodeId?`nodeId=${nodeId}`:"",position?`position=${position}`:""].filter(str=>str!=="").join()}`}constructor(item,info={}){super(DflowErrorItemNotFound.message({item,id:info.id,nId:info.nodeId,p:info.position}));this.item=item;this.info=info}toObject(){const{item,info:{id,nodeId,position}}=this;const obj={item,_:DflowErrorItemNotFound.code};if(id)obj.id=id;if(nodeId)obj.nId=nodeId;if(position)obj.p=position;return obj}}export class DflowErrorCannotExecuteAsyncFunction extends Error{static code="04";static message(){return"dflow executeFunction() cannot execute async functions"}constructor(){super(DflowErrorCannotExecuteAsyncFunction.message())}toObject(){return{_:DflowErrorCannotExecuteAsyncFunction.code}}}
