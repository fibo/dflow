var T=Object.defineProperty;var L=Object.getOwnPropertyDescriptor;var V=Object.getOwnPropertyNames;var W=Object.prototype.hasOwnProperty;var q=r=>T(r,"__esModule",{value:!0});var Q=(r,t)=>{for(var e in t)T(r,e,{get:t[e],enumerable:!0})},X=(r,t,e,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of V(t))!W.call(r,n)&&(e||n!=="default")&&T(r,n,{get:()=>t[n],enumerable:!(s=L(t,n))||s.enumerable});return r};var Y=(r=>(t,e)=>r&&r.get(t)||(e=X(q({}),t,1),r&&r.set(t,e),e))(typeof WeakMap!="undefined"?new WeakMap:0);var _={};Q(_,{DflowData:()=>i,DflowEdge:()=>b,DflowGraph:()=>p,DflowHost:()=>N,DflowInput:()=>O,DflowItem:()=>y,DflowNode:()=>u,DflowOutput:()=>E,DflowPin:()=>h,DflowUnknownNode:()=>I});const g=r=>`${r} must be a string`,P=r=>`${r} must be a number`,v=(r,t)=>`${t} pin not found nodeId=${r}`,S=(r,t,e)=>`${v(r,t)} position=${e}`,B=(r,t,e)=>`${v(r,t)} pinId=${e}`,k=({id:r,kind:t,outputs:e})=>({id:r,kind:t,outputs:e?.map(({id:s,data:n,name:o})=>({id:s,data:n,name:o}))});class i{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowGraph(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&Array.isArray(t.nodes)&&Array.isArray(t.edges)&&p.isDflowGraph(t)}static isDflowId(t){return i.isStringNotEmpty(t)}static isDflowType(t){return typeof t=="string"&&h.types.includes(t)}static isObject(t){return!i.isUndefined(t)&&!i.isNull(t)&&!i.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"&&!isNaN(t)}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return i.isString(t)&&t.length>0}static isUndefined(t){return typeof t>"u"}static validate(t,e){return e.length===0?!0:e.some(s=>{switch(s){case"array":return i.isArray(t);case"boolean":return i.isBoolean(t);case"null":return i.isNull(t);case"number":return i.isNumber(t);case"object":return i.isObject(t);case"string":return i.isString(t);case"DflowGraph":return i.isDflowGraph(t);case"DflowId":return i.isDflowId(t);case"DflowType":return i.isDflowType(t);default:return!1}},!0)}}class y{id;name;static isDflowItem({id:t,name:e}){return i.isDflowId(t)&&(i.isUndefined(e)||i.isStringNotEmpty(e))}constructor({id:t,name:e}){this.id=t,this.name=e}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}class h extends y{kind;types;static types=["string","number","boolean","null","object","array","DflowId","DflowGraph","DflowType"];static isDflowPin({types:t=[],...e}){return y.isDflowItem(e)&&h.isDflowPinTypes(t)}static isDflowPinType(t){return typeof t!="string"?!1:h.types.includes(t)}static isDflowPinTypes(t){return Array.isArray(t)?t.every(e=>h.isDflowPinType(e)):!1}constructor(t,{types:e=[],...s}){super(s);this.kind=t,this.types=e}get hasTypeAny(){return this.types.length===0}hasType(t){return this.hasTypeAny||this.types.includes(t)}}class O extends h{#t;#e;static isDflowInput({id:t,types:e}){return h.isDflowPin({id:t,types:e})}constructor({optional:t,...e}){super("input",e);this.#e=t}get data(){return this.#t?.data}get isConnected(){return typeof this.#t>"u"}get isOptional(){return this.#e}connectTo(t){const{hasTypeAny:e,types:s}=this,{types:n}=t;if(e||s.some(o=>n.includes(o)))this.#t=t;else throw new Error(`mismatching pinTypes, source has types [${n.join()}] and target has types [${s.join()}]`)}disconnect(){this.#t=void 0}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}class E extends h{#t;static isDflowOutput({id:t,data:e,types:s=[]}){return h.isDflowPin({id:t,types:s})&&i.validate(e,s)}constructor({data:t,...e}){super("output",e);this.#t=t}clear(){this.#t=void 0}get data(){return this.#t}set data(t){switch(!0){case i.isUndefined(t):this.clear();break;case this.hasTypeAny:case(i.isDflowGraph(t)&&this.hasType("DflowGraph")):case(i.isDflowId(t)&&this.hasType("DflowId")):case(i.isString(t)&&this.hasType("string")):case(i.isNumber(t)&&this.hasType("number")):case(i.isBoolean(t)&&this.hasType("boolean")):case(i.isNull(t)&&this.hasType("null")):case(i.isObject(t)&&this.hasType("object")):case(i.isArray(t)&&this.hasType("array")):{this.#t=t;break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t={...super.toObject()};return i.isUndefined(this.#t)||(t.data=this.#t),this.types.length>0&&(t.types=this.types),t}}class u extends y{#t=new Map;#e=new Map;#s=[];#n=[];kind;meta;host;static kind;static isAsync;static isConstant;static inputs;static outputs;static input(t=[],e){if(h.isDflowPinType(t))return{types:[t],...e};if(h.isDflowPinTypes(t))return{types:t,...e};throw new TypeError("invalid input definition")}static output(t=[],e){if(h.isDflowPinType(t))return{types:[t],...e};if(h.isDflowPinTypes(t))return{types:t,...e};throw new TypeError("invalid output definition")}static in(t=[],e){return[{types:t,...e}]}static out(t=[],e){return[{types:t,...e}]}static isDflowNode({kind:t,inputs:e=[],outputs:s=[],...n}){return y.isDflowItem(n)&&i.isStringNotEmpty(t)&&e.every(o=>O.isDflowInput(o))&&s.every(o=>E.isDflowOutput(o))}constructor({kind:t,inputs:e=[],outputs:s=[],...n},o,{isAsync:d=!1,isConstant:c=!1}={}){super(n);this.host=o,this.kind=t,this.meta={isAsync:d,isConstant:c};for(const f of e)this.newInput(f);for(const f of s)this.newOutput(f)}get inputs(){return this.#t.values()}get outputs(){return this.#e.values()}get numInputs(){return this.#t.size}get numOutputs(){return this.#e.size}clearOutputs(){for(const t of this.outputs)t.clear()}#i(t=this.numInputs){const e=`i${t}`;return this.#t.has(e)?this.#i(t+1):e}#o(t=this.numOutputs){const e=`o${t}`;return this.#e.has(e)?this.#o(t+1):e}getInputById(t){if(typeof t!="string")throw new TypeError(g("inputId"));const e=this.#t.get(t);if(e)return e;throw new Error(B(this.id,"input",t))}input(t){if(typeof t!="number")throw new TypeError(P("position"));const e=this.#s[t];if(i.isUndefined(e))throw new Error(S(this.id,"input",t));return this.getInputById(e)}getOutputById(t){if(typeof t!="string")throw new TypeError(g("outputId"));const e=this.#e.get(t);if(e)return e;throw new Error(B(this.id,"output",t))}output(t){if(typeof t!="number")throw new TypeError(P("position"));const e=this.#n[t];if(i.isUndefined(e))throw new Error(S(this.id,"output",t));return this.getOutputById(e)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),this.#t.delete(t),this.#s.splice(this.#s.indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),this.#e.delete(t),this.#n.splice(this.#n.indexOf(t),1)}newInput(t){const e=i.isDflowId(t.id)?t.id:this.#i(),s=new O({...t,id:e});return this.#t.set(e,s),this.#s.push(e),s}newOutput(t){const e=i.isDflowId(t.id)?t.id:this.#o(),s=new E({...t,id:e});return this.#e.set(e,s),this.#n.push(e),s}run(){}toObject(){const t={...super.toObject(),kind:this.kind},e=[],s=[];for(const n of this.inputs)e.push(n.toObject());e.length>0&&(t.inputs=e);for(const n of this.outputs)s.push(n.toObject());return s.length>0&&(t.outputs=s),t}}class I extends u{static kind="Unknown";constructor(t,e){super({...t,kind:I.kind},e)}run(){}}class b extends y{source;target;static isDflowEdge({source:t,target:e,...s},n){return y.isDflowItem(s)&&Array.isArray(t)&&t.length===2&&n.nodes.find(({id:o,outputs:d=[]})=>o===t[0]&&d.find(({id:c})=>c===t[1]))&&Array.isArray(e)&&e.length===2&&n.nodes.find(({id:o,inputs:d=[]})=>o===e[0]&&d.find(({id:c})=>c===e[1]))}constructor({source:t,target:e,...s}){super(s);const[n,o]=t,[d,c]=e;if(typeof n!="string")throw new TypeError(g("sourceNodeId"));if(typeof o!="string")throw new TypeError(g("sourcePinId"));if(typeof d!="string")throw new TypeError(g("targetNodeId"));if(typeof c!="string")throw new TypeError(g("targetPinId"));this.source=t,this.target=e}toObject(){return{...super.toObject(),source:this.source,target:this.target}}}class p extends y{#t=new Map;#e=new Map;runOptions={verbose:!1};runStatus=null;executionReport=null;static isDflowGraph(t){return t.nodes.every(e=>u.isDflowNode(e))&&t.edges.every(e=>b.isDflowEdge(e,t))}static childrenOfNodeId(t,e){return e.filter(({sourceId:s})=>t===s).map(({targetId:s})=>s)}static parentsOfNodeId(t,e){return e.filter(({targetId:s})=>t===s).map(({sourceId:s})=>s)}static levelOfNodeId(t,e){const s=p.parentsOfNodeId(t,e);if(s.length===0)return 0;let n=0;for(const o of s){const d=p.levelOfNodeId(o,e);n=Math.max(d,n)}return n+1}static ancestorsOfNodeId(t,e){const s=p.parentsOfNodeId(t,e);return s.length===0?[]:s.reduce((n,o,d,c)=>{const f=p.ancestorsOfNodeId(o,e),l=n.concat(f);return d===c.length-1?Array.from(new Set(c.concat(l))):l},[])}static sort(t,e){const s={};for(const n of t)s[n]=p.levelOfNodeId(n,e);return t.slice().sort((n,o)=>s[n]<=s[o]?-1:1)}get edges(){return this.#e.values()}get nodes(){return this.#t.values()}get nodeConnections(){return[...this.#e.values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...this.#e.keys()]}get nodeIds(){return[...this.#t.keys()]}get numEdges(){return this.#e.size}get numNodes(){return this.#t.size}addEdge(t){if(this.#e.has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);this.#e.set(t.id,t)}addNode(t){if(this.#t.has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);this.#t.set(t.id,t)}clear(){this.#t.clear(),this.#e.clear()}deleteEdge(t){this.#e.delete(t)}deleteNode(t){this.#t.delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(g("nodeId"));const e=this.#t.get(t);if(e)return e;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(g("edgeId"));const e=this.#e.get(t);if(e)return e;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const e=`e${t}`;return this.#e.has(e)?this.generateEdgeId(t+1):e}generateNodeId(t=this.numNodes){const e=`n${t}`;return this.#t.has(e)?this.generateNodeId(t+1):e}nodeIdsInsideFunctions(){const t=[];for(const e of this.nodes)e.kind==="return"&&t.push(p.ancestorsOfNodeId(e.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const e=this.nodeIdsInsideFunctions(),s=p.sort(this.nodeIds.filter(n=>!e.includes(n)),this.nodeConnections);e:for(const n of s){const o=this.#t.get(n);try{if(!o.meta.isConstant){let d=!1;t:for(const{data:c,types:f,isOptional:l}of o.inputs){if(l&&typeof c>"u")continue t;if(!i.validate(c,f)){d=!0;break t}}if(d){for(const c of o.outputs)c.clear();t&&this.executionReport.steps?.push(k(o.toObject()));continue e}o.meta.isAsync?await o.run():o.run()}t&&this.executionReport.steps?.push(k(o.toObject()))}catch(d){console.error(d),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t={...super.toObject(),nodes:[],edges:[]};for(const e of this.nodes)t.nodes.push(e.toObject());for(const e of this.edges)t.edges.push(e.toObject());return t}}const{input:j,output:$}=u;class D extends u{static kind="argument";static isConstant=!0;static inputs=[j("number",{name:"position",optional:!0})];static outputs=[$()]}class C extends u{static kind="array";static inputs=u.in();static outputs=u.out(["array"]);run(){const t=this.input(0).data;i.isArray(t)?this.output(0).data=t:this.output(0).clear()}}class R extends u{static kind="boolean";static inputs=[j()];static outputs=[$("boolean")];run(){const t=this.input(0).data;i.isBoolean(t)?this.output(0).data=t:this.output(0).clear()}}class U extends u{static kind="data";static isConstant=!0;static outputs=u.out()}class F extends u{static kind="function";static isConstant=!0;static outputs=u.out(["DflowId"],{name:"id"});constructor(...t){super(...t);this.output(0).data=this.id}}class M extends u{static kind="dflow";static outputs=u.out(["array"],{name:"nodeKinds"});run(){const t=this.output(0);t.data=this.host.nodeKinds}}class z extends u{static kind="isUndefined";static inputs=u.in();static outputs=u.out(["boolean"]);run(){this.output(0).data=i.isUndefined(this.input(0).data)}}class G extends u{static kind="number";static inputs=u.in();static outputs=u.out(["number"]);run(){const t=this.input(0).data;i.isNumber(t)?this.output(0).data=t:this.output(0).clear()}}class K extends u{static kind="object";static inputs=u.in();static outputs=u.out(["object"]);run(){const t=this.input(0).data;i.isObject(t)?this.output(0).data=t:this.output(0).clear()}}class m extends u{static kind="return";static isConstant=!0;static inputs=[...u.in(["DflowId"],{name:"functionId"}),...u.in([],{name:"value"})]}class H extends u{static kind="string";static inputs=u.in();static outputs=u.out(["string"]);run(){const t=this.input(0).data;i.isString(t)?this.output(0).data=t:this.output(0).clear()}}const Z={[D.kind]:D,[C.kind]:C,[R.kind]:R,[U.kind]:U,[M.kind]:M,[z.kind]:z,[G.kind]:G,[K.kind]:K,[F.kind]:F,[H.kind]:H,[m.kind]:m};class N{#t;nodesCatalog;context;static#e(t=[]){return t.map((e,s)=>({...e,id:`i${s}`}))}static#s(t=[]){return t.map((e,s)=>({...e,id:`o${s}`}))}constructor(t={}){this.nodesCatalog={...t,...Z},this.#t=new p({id:"g1"}),this.context={}}get executionReport(){return this.#t.executionReport}get edges(){return this.#t.edges}get nodes(){return this.#t.nodes}get numEdges(){return this.#t.numEdges}get numNodes(){return this.#t.numNodes}get nodeKinds(){return Object.keys(this.nodesCatalog)}get runStatusIsSuccess(){return this.#t.runStatus==="success"}get runStatusIsWaiting(){return this.#t.runStatus==="waiting"}get runStatusIsFailure(){return this.#t.runStatus==="failure"}set verbose(t){this.#t.runOptions.verbose=t}clearGraph(){this.#t.clear()}connect(t,e=0){return{to:(s,n=0)=>{const o=this.#t.generateEdgeId(),d=t.output(e),c=s.input(n);this.newEdge({id:o,source:[t.id,d.id],target:[s.id,c.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(g("edgeId"));const e=this.#t.getEdgeById(t);if(e){const[s,n]=e.target;this.getNodeById(s).getInputById(n).disconnect(),this.#t.deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(g("nodeId"));const e=this.getNodeById(t);if(e){for(const s of this.#t.edges){const{source:[n],target:[o]}=s;(n===e.id||o===e.id)&&this.deleteEdge(s.id)}this.#t.deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,e]){for(const s of this.edges){const[n,o]=s.source,[d,c]=s.target;(n===t&&o===e||d===t&&c===e)&&this.deleteEdge(s.id)}}executeFunction(t,e){const{verbose:s}=this.#t.runOptions,n=this.#t.nodeConnections,o=p.childrenOfNodeId(t,n),d=[];for(const l of o){const a=this.getNodeById(l);a.kind===m.kind&&d.push(a.id)}const c=d.reduce((l,a,w,x)=>{const J=p.ancestorsOfNodeId(a,n),A=l.concat(J);return w===x.length?Array.from(new Set(A)):A},[]),f=p.sort([...d,...c],n);for(const l of f){const a=this.getNodeById(l);try{switch(a.kind){case D.kind:{const w=a.input(0).data,x=typeof w=="number"&&!isNaN(w)?Math.max(w,0):0;a.output(0).data=e[x];break}case m.kind:return a.input(1).data;default:!a.meta.isConstant&&!a.meta.isAsync&&a.run(),s&&this.executionReport?.steps?.push(k(a.toObject()))}}catch(w){console.error(w)}}}getEdgeById(t){return this.#t.getEdgeById(t)}getNodeById(t){return this.#t.getNodeById(t)}newNode(t){const e=this.nodesCatalog[t.kind]??I,s=i.isDflowId(t.id)?t.id:this.#t.generateNodeId(),n={isAsync:e.isAsync,isConstant:e.isConstant},o=Array.isArray(t.inputs)?t.inputs:N.#e(e.inputs),d=Array.isArray(t.outputs)?t.outputs:N.#s(e.outputs),c=new e({...t,id:s,inputs:o,outputs:d},this,n);return this.#t.addNode(c),c}newEdge(t){const e=i.isDflowId(t.id)?t.id:this.#t.generateEdgeId(),s=new b({...t,id:e});this.#t.addEdge(s);const[n,o]=s.source,[d,c]=s.target,f=this.#t.getNodeById(n),l=this.#t.getNodeById(d),a=f.getOutputById(o);return l.getInputById(c).connectTo(a),s}newInput(t,e){return this.#t.getNodeById(t).newInput(e)}newOutput(t,e){return this.#t.getNodeById(t).newOutput(e)}toObject(){return this.#t.toObject()}async run(){await this.#t.run()}}module.exports=Y(_);
