var k=Object.defineProperty;var L=Object.getOwnPropertyDescriptor;var V=Object.getOwnPropertyNames;var W=Object.prototype.hasOwnProperty;var q=o=>k(o,"__esModule",{value:!0});var K=(o,t)=>{for(var e in t)k(o,e,{get:t[e],enumerable:!0})},Q=(o,t,e,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of V(t))!W.call(o,n)&&(e||n!=="default")&&k(o,n,{get:()=>t[n],enumerable:!(s=L(t,n))||s.enumerable});return o};var X=(o=>(t,e)=>o&&o.get(t)||(e=Q(q({}),t,1),o&&o.set(t,e),e))(typeof WeakMap!="undefined"?new WeakMap:0);var G={};K(G,{DflowData:()=>u,DflowEdge:()=>B,DflowGraph:()=>l,DflowHost:()=>I,DflowInput:()=>S,DflowItem:()=>w,DflowNode:()=>p,DflowOutput:()=>E,DflowPin:()=>x});class O extends Error{constructor(t,e){super(`${t} not found id=${e}`)}}const T=o=>`${o} must be a string`,Y=(o,t)=>`${t} pin not found nodeId=${o}`,v=(o,t,e)=>`${Y(o,t)} position=${e}`,A=({id:o,kind:t,outputs:e},s)=>{const n={id:o,kind:t,outputs:e?.map(({id:i,data:r,name:d})=>({id:i,data:r,name:d}))};return s&&(n.error=s),n};class u{static isArray(t){return!!Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowId(t){return u.isStringNotEmpty(t)}static isObject(t){return!(typeof t!="object"||!t||Array.isArray(t))}static isNumber(t){return typeof t=="number"&&!isNaN(t)}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return u.isString(t)&&t!==""}static validate(t,e){return e.length===0?!0:e.some(s=>{switch(s){case"array":return u.isArray(t);case"boolean":return u.isBoolean(t);case"number":return u.isNumber(t);case"object":return u.isObject(t);case"string":return u.isString(t);case"DflowId":return u.isDflowId(t);default:return!1}},!0)}}class w{id;name;constructor({id:t,name:e}){this.id=t,this.name=e}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}class x extends w{kind;types;static types=["string","number","boolean","object","array","DflowId"];constructor(t,{types:e=[],...s}){super(s);this.kind=t,this.types=e}get hasTypeAny(){return this.types.length===0}hasType(t){return this.hasTypeAny||this.types.includes(t)}toObject(){const t=super.toObject();return this.types.length>0&&(t.types=this.types),t}}class S extends x{#t;#e;#s;#n;constructor({multi:t,optional:e,...s}){super("input",s);this.#t=t,this.#e=e}get data(){if(this.#t){const t=Array.from(this.#n??[]);return t.length?t.map(e=>e.data):void 0}else return this.#s?.data}get isConnected(){return this.#t?Array.from(this.#n??[]).length>0:typeof this.#s>"u"}get isMulti(){return this.#t}get isOptional(){return this.#e}connectTo(t){const{hasTypeAny:e,types:s}=this,{types:n}=t;if(e||s.some(r=>n.includes(r)))this.#t?(this.#n||(this.#n=new Set),this.#n.add(t)):this.#s=t;else throw new Error(`mismatching pinTypes, source has types [${n.join()}] and target has types [${s.join()}]`)}disconnect(){this.#t?this.#n?.clear():this.#s=void 0}toObject(){return super.toObject()}}class E extends x{#t;constructor({data:t,...e}){super("output",e);this.#t=t}clear(){this.#t=void 0}get data(){return this.#t}set data(t){switch(!0){case typeof t>"u":this.clear();break;case this.hasTypeAny:case(this.hasType("string")&&u.isString(t)):case(this.hasType("number")&&u.isNumber(t)):case(this.hasType("boolean")&&u.isBoolean(t)):case(this.hasType("object")&&u.isObject(t)):case(this.hasType("array")&&u.isArray(t)):case(this.hasType("DflowId")&&u.isDflowId(t)):{this.#t=t;break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof data is ${typeof t}`)}}toObject(){const t=super.toObject();return typeof this.#t<"u"&&(t.data=this.#t),t}}class p extends w{#t=new Map;#e=new Map;#s=[];#n=[];kind;meta;host;static kind;static isAsync;static isConstant;static inputs;static outputs;static input(t=[],e){return typeof t=="string"?{types:[t],...e}:{types:t,...e}}static output(t=[],e){return typeof t=="string"?{types:[t],...e}:{types:t,...e}}constructor({kind:t,inputs:e=[],outputs:s=[],...n},i,{isAsync:r=!1,isConstant:d=!1}={}){super(n);this.host=i,this.kind=t,this.meta={isAsync:r,isConstant:d};for(const h of e)this.newInput(h);for(const h of s)this.newOutput(h)}get inputs(){return this.#t.values()}get outputs(){return this.#e.values()}clearOutputs(){for(const t of this.outputs)t.clear()}getInputById(t){const e=this.#t.get(t);if(!e)throw new O("input",t);return e}input(t){const e=this.#s[t];if(!e)throw new Error(v(this.id,"input",t));return this.getInputById(e)}getOutputById(t){const e=this.#e.get(t);if(!e)throw new O("output",t);return e}output(t){const e=this.#n[t];if(!e)throw new Error(v(this.id,"output",t));return this.getOutputById(e)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),this.#t.delete(t),this.#s.splice(this.#s.indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),this.#e.delete(t),this.#n.splice(this.#n.indexOf(t),1)}newInput(t){const e=this.#t.size,s=(r=e)=>{const d=`i${r}`;return this.#t.has(d)?s(r+1):d},n=u.isDflowId(t.id)?t.id:s(),i=new S({...t,id:n});return this.#t.set(n,i),this.#s.push(n),i}newOutput(t){const e=this.#e.size,s=(r=e)=>{const d=`o${r}`;return this.#e.has(d)?s(r+1):d},n=u.isDflowId(t.id)?t.id:s(),i=new E({...t,id:n});return this.#e.set(n,i),this.#n.push(n),i}run(){}toObject(){const t={...super.toObject(),kind:this.kind},e=[],s=[];for(const n of this.inputs)e.push(n.toObject());e.length>0&&(t.inputs=e);for(const n of this.outputs)s.push(n.toObject());return s.length>0&&(t.outputs=s),t}}class B extends w{source;target;constructor({source:t,target:e,...s}){super(s);this.source=t,this.target=e}toObject(){return{...super.toObject(),source:this.source,target:this.target}}}class l extends w{nodes=new Map;edges=new Map;runOptions={verbose:!1};runStatus=null;executionReport=null;static childrenOfNodeId(t,e){return e.filter(({sourceId:s})=>t===s).map(({targetId:s})=>s)}static parentsOfNodeId(t,e){return e.filter(({targetId:s})=>t===s).map(({sourceId:s})=>s)}static levelOfNodeId(t,e){const s=l.parentsOfNodeId(t,e);if(s.length===0)return 0;let n=0;for(const i of s){const r=l.levelOfNodeId(i,e);n=Math.max(r,n)}return n+1}static ancestorsOfNodeId(t,e){const s=l.parentsOfNodeId(t,e);return s.length===0?[]:s.reduce((n,i,r,d)=>{const h=l.ancestorsOfNodeId(i,e),a=n.concat(h);return r===d.length-1?Array.from(new Set(d.concat(a))):a},[])}static sort(t,e){const s={};for(const n of t)s[n]=l.levelOfNodeId(n,e);return t.slice().sort((n,i)=>s[n]<=s[i]?-1:1)}get nodeConnections(){return[...this.edges.values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}#t(){const t=[];for(const e of[...this.nodes.values()])e.kind==="return"&&t.push(l.ancestorsOfNodeId(e.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const e=this.#t(),s=l.sort([...this.nodes.keys()].filter(n=>!e.includes(n)),this.nodeConnections);e:for(const n of s){const i=this.nodes.get(n);try{if(!i.meta.isConstant){let r=!1;t:for(const{id:d,data:h,types:a,isOptional:c}of i.inputs){if(c&&typeof h>"u")continue t;if(!u.validate(h,a)){r=!0,t&&this.executionReport.steps?.push(A(i.toObject(),`invalid input data nodeId=${n} inputId=${d} data=${h}`));break t}}if(r){for(const d of i.outputs)d.clear();continue e}i.meta.isAsync?await i.run():i.run()}t&&this.executionReport.steps?.push(A(i.toObject()))}catch(r){console.error(r),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t={...super.toObject(),nodes:[],edges:[]};for(const e of this.nodes.values())t.nodes.push(e.toObject());for(const e of this.edges.values())t.edges.push(e.toObject());return t}}class I{#t;nodesCatalog;context;static#e(t=[]){return t.map((e,s)=>({...e,id:u.isDflowId(e.id)?e.id:`i${s}`}))}static#s(t=[]){return t.map((e,s)=>({...e,id:u.isDflowId(e.id)?e.id:`o${s}`}))}constructor(t={}){this.nodesCatalog={...t,...H},this.#t=new l({id:"g1"}),this.context={}}get executionReport(){return this.#t.executionReport}get edges(){return Array.from(this.#t.edges.values())}get nodes(){return this.#t.nodes}get runStatusIsSuccess(){return this.#t.runStatus==="success"}get runStatusIsWaiting(){return this.#t.runStatus==="waiting"}get runStatusIsFailure(){return this.#t.runStatus==="failure"}set verbose(t){this.#t.runOptions.verbose=t}clearGraph(){this.#t.nodes.clear(),this.#t.edges.clear()}connect(t,e=0){return{to:(s,n=0)=>{const i=t.output(e),r=s.input(n);this.newEdge({source:[t.id,i.id],target:[s.id,r.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(T("edgeId"));const e=this.getEdgeById(t);if(!e)return;const[s,n]=e.target;this.getNodeById(s).getInputById(n).disconnect(),this.#t.edges.delete(t)}deleteNode(t){if(typeof t!="string")throw new TypeError(T("nodeId"));const e=this.getNodeById(t);if(e){for(const s of this.edges){const{source:[n],target:[i]}=s;(n===e.id||i===e.id)&&this.deleteEdge(s.id)}this.#t.nodes.delete(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,e]){for(const s of this.edges){const[n,i]=s.source,[r,d]=s.target;(n===t&&i===e||r===t&&d===e)&&this.deleteEdge(s.id)}}executeFunction(t,e){const{verbose:s}=this.#t.runOptions,n=this.#t.nodeConnections,i=l.childrenOfNodeId(t,n),r=[];for(const a of i){const c=this.getNodeById(a);c.kind===b.kind&&r.push(c.id)}const d=r.reduce((a,c,f,N)=>{const C=l.ancestorsOfNodeId(c,n),m=a.concat(C);return f===N.length?Array.from(new Set(m)):m},[]),h=l.sort([...r,...d],n);for(const a of h){const c=this.getNodeById(a);try{switch(c.kind){case j.kind:{const f=c.input(0).data,N=typeof f=="number"&&!isNaN(f)?Math.max(f,0):0;c.output(0).data=e[N];break}case b.kind:return c.input(1).data;default:!c.meta.isConstant&&!c.meta.isAsync&&c.run(),s&&this.executionReport?.steps?.push(A(c.toObject()))}}catch(f){console.error(f)}}}getEdgeById(t){const e=this.#t.edges.get(t);if(!e)throw new O("edge",t);return e}getNodeById(t){const e=this.#t.nodes.get(t);if(!e)throw new O("node",t);return e}newNode(t){const e=this.#t.nodes.size,s=(c=e)=>{const f=`n${c}`;return this.#t.nodes.has(f)?s(c+1):f},n=this.nodesCatalog[t.kind]??Z,i=u.isDflowId(t.id)?t.id:s(),r={isAsync:n.isAsync,isConstant:n.isConstant},d=Array.isArray(t.inputs)?I.#e(t.inputs):I.#e(n.inputs??[]),h=Array.isArray(t.outputs)?I.#s(t.outputs):I.#s(n.outputs??[]),a=new n({...t,id:i,inputs:d,outputs:h},this,r);return this.#t.nodes.set(a.id,a),a}newEdge(t){const e=this.#t.edges.size,s=(m=e)=>{const D=`e${m}`;return this.#t.edges.has(D)?s(m+1):D},n=u.isDflowId(t.id)?t.id:s(),i=new B({...t,id:n});this.#t.edges.set(i.id,i);const[r,d]=i.source,[h,a]=i.target,c=this.getNodeById(r),f=this.getNodeById(h),N=c.getOutputById(d);return f.getInputById(a).connectTo(N),i}newInput(t,e){return this.getNodeById(t).newInput(e)}newOutput(t,e){return this.getNodeById(t).newOutput(e)}toObject(){return this.#t.toObject()}async run(){await this.#t.run()}}const{input:g,output:y}=p;class j extends p{static kind="argument";static isConstant=!0;static inputs=[g("number",{name:"position",optional:!0})];static outputs=[y()]}class P extends p{static kind="array";static inputs=[g()];static outputs=[y("array")];run(){const t=this.input(0).data;u.isArray(t)?this.output(0).data=t:this.output(0).clear()}}class $ extends p{static kind="boolean";static inputs=[g()];static outputs=[y("boolean")];run(){const t=this.input(0).data;u.isBoolean(t)?this.output(0).data=t:this.output(0).clear()}}class R extends p{static kind="data";static isConstant=!0;static outputs=[y()]}class M extends p{static kind="function";static isConstant=!0;static outputs=[y("DflowId",{name:"id"})];constructor(...t){super(...t);this.output(0).data=this.id}}class F extends p{static kind="isUndefined";static inputs=[g()];static outputs=[y("boolean")];run(){this.output(0).data=typeof this.input(0).data>"u"}}class z extends p{static kind="number";static inputs=[g()];static outputs=[y("number")];run(){const t=this.input(0).data;u.isNumber(t)?this.output(0).data=t:this.output(0).clear()}}class U extends p{static kind="object";static inputs=[g()];static outputs=[y("object")];run(){const t=this.input(0).data;u.isObject(t)?this.output(0).data=t:this.output(0).clear()}}class b extends p{static kind="return";static isConstant=!0;static inputs=[g("DflowId",{name:"functionId"}),g([],{name:"value"})]}class J extends p{static kind="string";static inputs=[g()];static outputs=[y("string")];run(){const t=this.input(0).data;u.isString(t)?this.output(0).data=t:this.output(0).clear()}}class Z extends p{}const H={[j.kind]:j,[P.kind]:P,[$.kind]:$,[R.kind]:R,[F.kind]:F,[z.kind]:z,[U.kind]:U,[M.kind]:M,[J.kind]:J,[b.kind]:b};module.exports=X(G);
