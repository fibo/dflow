var A=Object.defineProperty;var Jt=Object.getOwnPropertyDescriptor;var zt=Object.getOwnPropertyNames;var Kt=Object.prototype.hasOwnProperty;var Ut=i=>A(i,"__esModule",{value:!0});var Vt=(i,t)=>{for(var s in t)A(i,s,{get:t[s],enumerable:!0})},Wt=(i,t,s,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of zt(t))!Kt.call(i,a)&&(s||a!=="default")&&A(i,a,{get:()=>t[a],enumerable:!(n=Jt(t,a))||n.enumerable});return i};var Qt=(i=>(t,s)=>i&&i.get(t)||(s=Wt(Ut({}),t,1),i&&i.set(t,s),s))(typeof WeakMap!="undefined"?new WeakMap:0);var fs={};Vt(fs,{nodesCatalog:()=>Lt});const y=i=>`${i} must be a string`,P=(i,t)=>`${t} pin not found nodeId=${i}`,v=(i,t,s)=>`${P(i,t)} position=${s}`,M=(i,t,s)=>`${P(i,t)} pinId=${s}`,T=({id:i,kind:t,outputs:s},n)=>{const a={id:i,kind:t,outputs:s?.map(({id:u,data:r,name:d})=>({id:u,data:r,name:d}))};return n&&(a.error=n),a};class o{static isArray(t){return!!Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowId(t){return o.isStringNotEmpty(t)}static isObject(t){return!(typeof t!="object"||!t||Array.isArray(t))}static isNumber(t){return typeof t=="number"&&!isNaN(t)}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return o.isString(t)&&t!==""}static validate(t,s){return s.length===0?!0:s.some(n=>{switch(n){case"array":return o.isArray(t);case"boolean":return o.isBoolean(t);case"number":return o.isNumber(t);case"object":return o.isObject(t);case"string":return o.isString(t);case"DflowId":return o.isDflowId(t);default:return!1}},!0)}}class k{id;name;static isDflowItem(t){if(typeof t!="object"||!t)return!1;const{id:s,name:n}=t;return o.isDflowId(s)&&(typeof n>"u"||o.isStringNotEmpty(n))}constructor({id:t,name:s}){this.id=t,this.name=s}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}class f extends k{kind;types;static types=["string","number","boolean","object","array","DflowId"];static isDflowPin(t){if(typeof t!="object"||!t)return!1;const{types:s,...n}=t;return k.isDflowItem(n)&&f.isDflowPinTypes(s)}static isDflowPinType(t){return typeof t!="string"?!1:f.types.includes(t)}static isDflowPinTypes(t){return Array.isArray(t)?t.every(s=>f.isDflowPinType(s)):!1}constructor(t,{types:s=[],...n}){super(n);this.kind=t,this.types=s}get hasTypeAny(){return this.types.length===0}hasType(t){return this.hasTypeAny||this.types.includes(t)}toObject(){const t=super.toObject();return this.types.length>0&&(t.types=this.types),t}}class C extends f{#t;#s;#e;#n;static isDflowInput(t){if(typeof t!="object"||!t)return!1;const{id:s,types:n,optional:a,multi:u}=t;return f.isDflowPin({id:s,types:n})&&(typeof u>"u"||typeof u=="boolean")&&(typeof a>"u"||typeof a=="boolean")}constructor({multi:t,optional:s,...n}){super("input",n);this.#t=t,this.#s=s}get data(){if(this.#t){const t=Array.from(this.#n??[]);return t.length?t.map(s=>s.data):void 0}else return this.#e?.data}get isConnected(){return this.#t?Array.from(this.#n??[]).length>0:typeof this.#e>"u"}get isMulti(){return this.#t}get isOptional(){return this.#s}connectTo(t){const{hasTypeAny:s,types:n}=this,{types:a}=t;if(s||n.some(r=>a.includes(r)))this.#t?(this.#n||(this.#n=new Set),this.#n.add(t)):this.#e=t;else throw new Error(`mismatching pinTypes, source has types [${a.join()}] and target has types [${n.join()}]`)}disconnect(){this.#t?this.#n?.clear():this.#e=void 0}toObject(){return super.toObject()}}class B extends f{#t;static isDflowOutput({id:t,data:s,types:n=[]}){return f.isDflowPin({id:t,types:n})&&o.validate(s,n)}constructor({data:t,...s}){super("output",s);this.#t=t}clear(){this.#t=void 0}get data(){return this.#t}set data(t){switch(!0){case typeof t>"u":this.clear();break;case this.hasTypeAny:case(this.hasType("string")&&o.isString(t)):case(this.hasType("number")&&o.isNumber(t)):case(this.hasType("boolean")&&o.isBoolean(t)):case(this.hasType("object")&&o.isObject(t)):case(this.hasType("array")&&o.isArray(t)):case(this.hasType("DflowId")&&o.isDflowId(t)):{this.#t=t;break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=super.toObject();return typeof this.#t<"u"&&(t.data=this.#t),t}}class e extends k{#t=new Map;#s=new Map;#e=[];#n=[];kind;meta;host;static kind;static isAsync;static isConstant;static inputs;static outputs;static input(t=[],s){if(f.isDflowPinType(t))return{types:[t],...s};if(f.isDflowPinTypes(t))return{types:t,...s};throw new TypeError("invalid input definition")}static output(t=[],s){if(f.isDflowPinType(t))return{types:[t],...s};if(f.isDflowPinTypes(t))return{types:t,...s};throw new TypeError("invalid output definition")}static in(t=[],s){return[{types:t,...s}]}static out(t=[],s){return[{types:t,...s}]}static isDflowNode(t){if(typeof t!="object"||!t)return!1;const{kind:s,inputs:n=[],outputs:a=[],...u}=t;return k.isDflowItem(u)&&o.isStringNotEmpty(s)&&n.every(r=>C.isDflowInput(r))&&a.every(r=>B.isDflowOutput(r))}constructor({kind:t,inputs:s=[],outputs:n=[],...a},u,{isAsync:r=!1,isConstant:d=!1}={}){super(a);this.host=u,this.kind=t,this.meta={isAsync:r,isConstant:d};for(const h of s)this.newInput(h);for(const h of n)this.newOutput(h)}get inputs(){return this.#t.values()}get outputs(){return this.#s.values()}get numInputs(){return this.#t.size}get numOutputs(){return this.#s.size}clearOutputs(){for(const t of this.outputs)t.clear()}#i(t=this.numInputs){const s=`i${t}`;return this.#t.has(s)?this.#i(t+1):s}#a(t=this.numOutputs){const s=`o${t}`;return this.#s.has(s)?this.#a(t+1):s}getInputById(t){if(typeof t!="string")throw new TypeError(y("inputId"));const s=this.#t.get(t);if(s)return s;throw new Error(M(this.id,"input",t))}input(t){const s=this.#e[t];if(!s)throw new Error(v(this.id,"input",t));return this.getInputById(s)}getOutputById(t){if(typeof t!="string")throw new TypeError(y("outputId"));const s=this.#s.get(t);if(s)return s;throw new Error(M(this.id,"output",t))}output(t){const s=this.#n[t];if(!s)throw new Error(v(this.id,"output",t));return this.getOutputById(s)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),this.#t.delete(t),this.#e.splice(this.#e.indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),this.#s.delete(t),this.#n.splice(this.#n.indexOf(t),1)}newInput(t){const s=o.isDflowId(t.id)?t.id:this.#i(),n=new C({...t,id:s});return this.#t.set(s,n),this.#e.push(s),n}newOutput(t){const s=o.isDflowId(t.id)?t.id:this.#a(),n=new B({...t,id:s});return this.#s.set(s,n),this.#n.push(s),n}run(){}toObject(){const t={...super.toObject(),kind:this.kind},s=[],n=[];for(const a of this.inputs)s.push(a.toObject());s.length>0&&(t.inputs=s);for(const a of this.outputs)n.push(a.toObject());return n.length>0&&(t.outputs=n),t}}class Xt extends k{source;target;static isDflowEdge(t){if(typeof t!="object"||!t)return!1;const{source:s,target:n,...a}=t;return!(k.isDflowItem(a)||!Array.isArray(s)||s.length!==2||o.isDflowId(s[0])||o.isDflowId(s[1])||!Array.isArray(n)||n.length!==2||o.isDflowId(n[0])||o.isDflowId(n[1]))}constructor({source:t,target:s,...n}){super(n);const[a,u]=t,[r,d]=s;if(typeof a!="string")throw new TypeError(y("sourceNodeId"));if(typeof u!="string")throw new TypeError(y("sourcePinId"));if(typeof r!="string")throw new TypeError(y("targetNodeId"));if(typeof d!="string")throw new TypeError(y("targetPinId"));this.source=t,this.target=s}toObject(){return{...super.toObject(),source:this.source,target:this.target}}}class g extends k{#t=new Map;#s=new Map;runOptions={verbose:!1};runStatus=null;executionReport=null;static childrenOfNodeId(t,s){return s.filter(({sourceId:n})=>t===n).map(({targetId:n})=>n)}static parentsOfNodeId(t,s){return s.filter(({targetId:n})=>t===n).map(({sourceId:n})=>n)}static levelOfNodeId(t,s){const n=g.parentsOfNodeId(t,s);if(n.length===0)return 0;let a=0;for(const u of n){const r=g.levelOfNodeId(u,s);a=Math.max(r,a)}return a+1}static ancestorsOfNodeId(t,s){const n=g.parentsOfNodeId(t,s);return n.length===0?[]:n.reduce((a,u,r,d)=>{const h=g.ancestorsOfNodeId(u,s),l=a.concat(h);return r===d.length-1?Array.from(new Set(d.concat(l))):l},[])}static sort(t,s){const n={};for(const a of t)n[a]=g.levelOfNodeId(a,s);return t.slice().sort((a,u)=>n[a]<=n[u]?-1:1)}get edges(){return this.#s.values()}get nodes(){return this.#t.values()}get nodeConnections(){return[...this.#s.values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...this.#s.keys()]}get nodeIds(){return[...this.#t.keys()]}get numEdges(){return this.#s.size}get numNodes(){return this.#t.size}addEdge(t){if(this.#s.has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);this.#s.set(t.id,t)}addNode(t){if(this.#t.has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);this.#t.set(t.id,t)}clear(){this.#t.clear(),this.#s.clear()}deleteEdge(t){this.#s.delete(t)}deleteNode(t){this.#t.delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(y("nodeId"));const s=this.#t.get(t);if(s)return s;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(y("edgeId"));const s=this.#s.get(t);if(s)return s;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const s=`e${t}`;return this.#s.has(s)?this.generateEdgeId(t+1):s}generateNodeId(t=this.numNodes){const s=`n${t}`;return this.#t.has(s)?this.generateNodeId(t+1):s}nodeIdsInsideFunctions(){const t=[];for(const s of this.nodes)s.kind==="return"&&t.push(g.ancestorsOfNodeId(s.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const s=this.nodeIdsInsideFunctions(),n=g.sort(this.nodeIds.filter(a=>!s.includes(a)),this.nodeConnections);s:for(const a of n){const u=this.#t.get(a);try{if(!u.meta.isConstant){let r=!1;t:for(const{id:d,data:h,types:l,isOptional:p}of u.inputs){if(p&&typeof h>"u")continue t;if(!o.validate(h,l)){r=!0,t&&this.executionReport.steps?.push(T(u.toObject(),`invalid input data nodeId=${a} inputId=${d} data=${h}`));break t}}if(r){for(const d of u.outputs)d.clear();continue s}u.meta.isAsync?await u.run():u.run()}t&&this.executionReport.steps?.push(T(u.toObject()))}catch(r){console.error(r),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t={...super.toObject(),nodes:[],edges:[]};for(const s of this.nodes)t.nodes.push(s.toObject());for(const s of this.edges)t.edges.push(s.toObject());return t}}class N{#t;nodesCatalog;context;static#s(t=[]){return t.map((s,n)=>({...s,id:o.isDflowId(s.id)?s.id:`i${n}`}))}static#e(t=[]){return t.map((s,n)=>({...s,id:o.isDflowId(s.id)?s.id:`o${n}`}))}constructor(t={}){this.nodesCatalog={...t,...Zt},this.#t=new g({id:"g1"}),this.context={}}get executionReport(){return this.#t.executionReport}get edges(){return this.#t.edges}get nodes(){return this.#t.nodes}get numEdges(){return this.#t.numEdges}get numNodes(){return this.#t.numNodes}get nodeKinds(){return Object.keys(this.nodesCatalog)}get runStatusIsSuccess(){return this.#t.runStatus==="success"}get runStatusIsWaiting(){return this.#t.runStatus==="waiting"}get runStatusIsFailure(){return this.#t.runStatus==="failure"}set verbose(t){this.#t.runOptions.verbose=t}clearGraph(){this.#t.clear()}connect(t,s=0){return{to:(n,a=0)=>{const u=this.#t.generateEdgeId(),r=t.output(s),d=n.input(a);this.newEdge({id:u,source:[t.id,r.id],target:[n.id,d.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(y("edgeId"));const s=this.#t.getEdgeById(t);if(s){const[n,a]=s.target;this.getNodeById(n).getInputById(a).disconnect(),this.#t.deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(y("nodeId"));const s=this.getNodeById(t);if(s){for(const n of this.#t.edges){const{source:[a],target:[u]}=n;(a===s.id||u===s.id)&&this.deleteEdge(n.id)}this.#t.deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,s]){for(const n of this.edges){const[a,u]=n.source,[r,d]=n.target;(a===t&&u===s||r===t&&d===s)&&this.deleteEdge(n.id)}}executeFunction(t,s){const{verbose:n}=this.#t.runOptions,a=this.#t.nodeConnections,u=g.childrenOfNodeId(t,a),r=[];for(const l of u){const p=this.getNodeById(l);p.kind===x.kind&&r.push(p.id)}const d=r.reduce((l,p,b,E)=>{const qt=g.ancestorsOfNodeId(p,a),j=l.concat(qt);return b===E.length?Array.from(new Set(j)):j},[]),h=g.sort([...r,...d],a);for(const l of h){const p=this.getNodeById(l);try{switch(p.kind){case S.kind:{const b=p.input(0).data,E=typeof b=="number"&&!isNaN(b)?Math.max(b,0):0;p.output(0).data=s[E];break}case x.kind:return p.input(1).data;default:!p.meta.isConstant&&!p.meta.isAsync&&p.run(),n&&this.executionReport?.steps?.push(T(p.toObject()))}}catch(b){console.error(b)}}}getEdgeById(t){return this.#t.getEdgeById(t)}getNodeById(t){return this.#t.getNodeById(t)}newNode(t){const s=this.nodesCatalog[t.kind]??Yt,n=o.isDflowId(t.id)?t.id:this.#t.generateNodeId(),a={isAsync:s.isAsync,isConstant:s.isConstant},u=Array.isArray(t.inputs)?N.#s(t.inputs):N.#s(s.inputs??[]),r=Array.isArray(t.outputs)?N.#e(t.outputs):N.#e(s.outputs??[]),d=new s({...t,id:n,inputs:u,outputs:r},this,a);return this.#t.addNode(d),d}newEdge(t){const s=o.isDflowId(t.id)?t.id:this.#t.generateEdgeId(),n=new Xt({...t,id:s});this.#t.addEdge(n);const[a,u]=n.source,[r,d]=n.target,h=this.#t.getNodeById(a),l=this.#t.getNodeById(r),p=h.getOutputById(u);return l.getInputById(d).connectTo(p),n}newInput(t,s){return this.#t.getNodeById(t).newInput(s)}newOutput(t,s){return this.#t.getNodeById(t).newOutput(s)}toObject(){return this.#t.toObject()}async run(){await this.#t.run()}}const{input:m,output:I}=e;class S extends e{static kind="argument";static isConstant=!0;static inputs=[m("number",{name:"position",optional:!0})];static outputs=[I()]}class $ extends e{static kind="array";static inputs=[m()];static outputs=[I("array")];run(){const t=this.input(0).data;o.isArray(t)?this.output(0).data=t:this.output(0).clear()}}class F extends e{static kind="boolean";static inputs=[m()];static outputs=[I("boolean")];run(){const t=this.input(0).data;o.isBoolean(t)?this.output(0).data=t:this.output(0).clear()}}class R extends e{static kind="data";static isConstant=!0;static outputs=[I()]}class L extends e{static kind="function";static isConstant=!0;static outputs=[I("DflowId",{name:"id"})];constructor(...t){super(...t);this.output(0).data=this.id}}class q extends e{static kind="isUndefined";static inputs=[m()];static outputs=[I("boolean")];run(){this.output(0).data=typeof this.input(0).data>"u"}}class J extends e{static kind="number";static inputs=[m()];static outputs=[I("number")];run(){const t=this.input(0).data;o.isNumber(t)?this.output(0).data=t:this.output(0).clear()}}class z extends e{static kind="object";static inputs=[m()];static outputs=[I("object")];run(){const t=this.input(0).data;o.isObject(t)?this.output(0).data=t:this.output(0).clear()}}class x extends e{static kind="return";static isConstant=!0;static inputs=[m("DflowId",{name:"functionId"}),m([],{name:"value"})]}class K extends e{static kind="string";static inputs=[m()];static outputs=[I("string")];run(){const t=this.input(0).data;o.isString(t)?this.output(0).data=t:this.output(0).clear()}}class Yt extends e{}const Zt={[S.kind]:S,[$.kind]:$,[F.kind]:F,[R.kind]:R,[q.kind]:q,[J.kind]:J,[z.kind]:z,[L.kind]:L,[K.kind]:K,[x.kind]:x};class U extends e{static kind="arrayAt";static inputs=[...e.in(["array"]),...e.in(["number"],{name:"index"})];static outputs=e.out();run(){const t=this.input(0).data,s=this.input(1).data;this.output(0).data=t.at(s)}}class V extends e{static kind="arrayFilter";static inputs=[...e.in(["array"]),...e.in(["DflowId"],{name:"functionId"})];static outputs=e.out(["array"]);run(){this.output(0).data=this.input(0).data.filter((...t)=>this.host.executeFunction(this.input(1).data,t))}}class W extends e{static kind="arrayFindLastIndex";static inputs=[...e.in(["array"]),...e.in(["DflowId"],{name:"functionId"})];static outputs=e.out(["number"]);run(){this.output(0).data=this.input(0).data.findLastIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}class Q extends e{static kind="arrayFindIndex";static inputs=[...e.in(["array"]),...e.in(["DflowId"],{name:"functionId"})];static outputs=e.out(["number"]);run(){this.output(0).data=this.input(0).data.findIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}class X extends e{static kind="arrayIncludes";static inputs=[...e.in(["array"],{name:"array"}),...e.in(["string"],{name:"element"})];static outputs=e.out(["boolean"]);run(){const t=this.input(0).data,s=this.input(1).data;Array.isArray(t)&&(this.output(0).data=t.includes(s))}}class Y extends e{static kind="arrayJoin";static inputs=[...e.in(["array"],{name:"array"}),...e.in(["string"],{name:"separator",optional:!0})];static outputs=e.out(["string"]);run(){this.output(0).data=this.input(0).data.join(this.input(1).data)}}class Z extends e{static kind="arrayLength";static inputs=e.in(["array"]);static outputs=e.out(["number"]);run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t.length:this.output(0).clear}}class H extends e{static kind="arrayMap";static inputs=[...e.in(["array"]),...e.in(["DflowId"],{name:"functionId"})];static outputs=e.out(["array"]);run(){this.output(0).data=this.input(0).data.map((...t)=>this.host.executeFunction(this.input(1).data,t))}}class G extends e{static kind="arrayPop";static inputs=e.in(["array"]);static outputs=[...e.out([],{name:"element"}),...e.out(["array"],{name:"rest"})];run(){const t=this.input(0).data.slice(),s=t.pop();this.output(0).data=s,this.output(1).data=t}}class _ extends e{static kind="arrayPush";static inputs=[...e.in(["array"]),...e.in([],{name:"element"})];static outputs=e.out(["array"]);run(){const t=this.input(0).data.slice(),s=this.input(1).data;s&&t.push(s),this.output(0).data=t}}class tt extends e{static kind="arrayReverse";static inputs=e.in(["array"]);static outputs=e.in(["array"]);run(){const t=this.input(0).data.slice();this.output(0).data=t.reverse()}}class st extends e{static kind="arrayShift";static inputs=e.in(["array"]);static outputs=[...e.out([],{name:"element"}),...e.out(["array"],{name:"rest"})];run(){const t=this.input(0).data.slice(),s=t.shift();this.output(0).data=s,this.output(1).data=t}}class et extends e{static kind="arraySlice";static inputs=[...e.in(["array"]),...e.in(["number"],{name:"start"}),...e.in(["number"],{name:"end",optional:!0})];static outputs=e.out(["array"]);run(){const t=super.input(0).data,s=super.input(1).data,n=super.input(2).data;typeof n=="number"?super.output(0).data=t.slice(s,n):super.output(0).data=t.slice(s)}}const Ht={[U.kind]:U,[V.kind]:V,[W.kind]:W,[Q.kind]:Q,[X.kind]:X,[Y.kind]:Y,[Z.kind]:Z,[H.kind]:H,[G.kind]:G,[_.kind]:_,[tt.kind]:tt,[st.kind]:st,[et.kind]:et};class nt extends e{static kind="if";static inputs=[...e.in([],{name:"condition"}),...e.in([],{name:"then"}),...e.in([],{name:"else"})];static outputs=e.out();run(){this.output(0).data=this.input(0).data?this.input(1).data:this.input(2).data}}const Gt={[nt.kind]:nt};class it extends e{static kind="consoleLog";static inputs=[...e.in([])];run(){console.log(this.input(0).data)}}const _t={[it.kind]:it},at=[...e.out(["string"]),...e.out(["number"],{name:"milliseconds"})];class ut extends e{static kind="newDate";static inputs=e.in(["string","number"],{optional:!0});static outputs=at;run(){const t=this.input(0).data;if(typeof t=="string"||typeof t=="number"){const n=new Date(t),a=n.toJSON();a!==null&&(this.output(0).data=a,this.output(1).data=n.getTime())}const s=new Date;this.output(0).data=s.toJSON(),this.output(1).data=s.getTime()}}class ot extends e{static kind="now";static outputs=at;run(){const t=Date.now();this.output(0).data=new Date(t).toJSON(),this.output(1).data=t}}const ts={[ut.kind]:ut,[ot.kind]:ot},{input:D,output:ss}=e;class rt extends e{static kind="and";static inputs=[D("boolean"),D("boolean")];static outputs=[ss("boolean")];run(){this.output(0).data=this.input(0).data&&this.input(1).data}}class dt extends e{static kind="not";static inputs=e.in(["boolean"]);static outputs=e.out(["boolean"]);run(){this.output(0).data=!this.input(0).data}}class ct extends e{static kind="??";static inputs=[...e.in(),...e.in()];static outputs=e.out();run(){this.output(0).data=this.input(0).data??this.input(1).data}}class pt extends e{static kind="or";static inputs=[D("boolean"),D("boolean")];static outputs=e.out(["boolean"]);run(){this.output(0).data=this.input(0).data||this.input(1).data}}const es={[rt.kind]:rt,[dt.kind]:dt,[ct.kind]:ct,[pt.kind]:pt},{input:ns,output:is}=e;class ht extends e{static kind="mathAbs";static inputs=e.in(["number"]);static outputs=e.out(["number"]);run(){this.output(0).data=Math.abs(this.input(0).data)}}class lt extends e{static kind="mathCos";static inputs=[ns("number")];static outputs=e.out(["number"]);run(){this.output(0).data=Math.cos(this.input(0).data)}}class ft extends e{static kind="mathCosh";static inputs=e.in(["number"]);static outputs=e.out(["number"]);run(){this.output(0).data=Math.cosh(this.input(0).data)}}class gt extends e{static kind="mathFloor";static inputs=e.in(["number"]);static outputs=e.out(["number"]);run(){this.output(0).data=Math.floor(this.input(0).data)}}class yt extends e{static kind="mathMax";static inputs=e.in(["array"]);static outputs=e.out(["number"]);run(){const t=this.input(0).data,s=Math.max(...t);isNaN(s)?this.output(0).clear():this.output(0).data=s}}class wt extends e{static kind="mathMin";static inputs=e.in(["array"]);static outputs=e.out(["number"]);run(){const t=this.input(0).data,s=Math.min(...t);isNaN(s)?this.output(0).clear():this.output(0).data=s}}class mt extends e{static kind="mathPI";static isConstant=!0;static outputs=[is("number",{name:"\u03C0",data:Math.PI})]}class It extends e{static kind="mathRound";static inputs=e.in(["number"]);static outputs=e.out(["number"]);run(){this.output(0).data=Math.round(this.input(0).data)}}class bt extends e{static kind="mathSin";static inputs=e.in(["number"]);static outputs=e.out(["number"]);run(){this.output(0).data=Math.sin(this.input(0).data)}}class kt extends e{static kind="mathSinh";static inputs=e.in(["number"]);static outputs=e.out(["number"]);run(){this.output(0).data=Math.sinh(this.input(0).data)}}const as={[ht.kind]:ht,[lt.kind]:lt,[ft.kind]:ft,[gt.kind]:gt,[yt.kind]:yt,[wt.kind]:wt,[mt.kind]:mt,[It.kind]:It,[bt.kind]:bt,[kt.kind]:kt};class Nt extends e{static kind="isFinite";static inputs=e.in(["number"]);static outputs=e.out(["boolean"]);run(){this.output(0).data=Number.isFinite(this.input(0).data)}}class xt extends e{static kind="isInteger";static inputs=e.in([]);static outputs=e.out(["boolean"]);run(){this.output(0).data=Number.isInteger(this.input(0).data)}}class Dt extends e{static kind="isNaN";static inputs=e.in([]);static outputs=e.out(["boolean"]);run(){this.output(0).data=Number.isNaN(this.input(0).data)}}class Ot extends e{static kind="parseFloat";static inputs=e.in(["string"]);static outputs=e.out(["number"]);run(){this.output(0).data=parseFloat(this.input(0).data)}}class Et extends e{static kind="parseInt";static inputs=e.in(["number","string"]);static outputs=e.out(["number"]);run(){this.output(0).data=parseInt(this.input(0).data)}}const us={[Nt.kind]:Nt,[xt.kind]:xt,[Dt.kind]:Dt,[Ot.kind]:Ot,[Et.kind]:Et};class At extends e{static kind="objectKeys";static inputs=e.in(["object"]);static outputs=e.out(["array"]);run(){this.output(0).data=Object.keys(this.input(0).data)}}class Tt extends e{static kind="objectValues";static inputs=e.in(["object"]);static outputs=e.out(["array"]);run(){this.output(0).data=Object.values(this.input(0).data)}}const os={[At.kind]:At,[Tt.kind]:Tt},{input:c,output:w}=e;class St extends e{static kind="addition";static inputs=[c("number"),c("number",{multi:!0})];static outputs=[w("number")];run(){this.output(0).data=this.input(0).data+this.input(1).data}}class jt extends e{static kind="division";static inputs=[c("number"),c("number")];static outputs=[w("number")];run(){this.input(1).data?this.output(0).data=this.input(0).data/this.input(1).data:this.output(0).clear()}}class Pt extends e{static kind="equality";static inputs=[c(),c()];static outputs=[w("boolean")];run(){this.output(0).data=this.input(0).data==this.input(1).data}}class vt extends e{static kind="lessThan";static inputs=[c("number"),c("number")];static outputs=[w("boolean")];run(){this.output(0).data=this.input(0).data<this.input(1).data}}class Mt extends e{static kind="lessThanOrEqual";static inputs=[c("number"),c("number")];static outputs=[w("boolean")];run(){this.output(0).data=this.input(0).data<=this.input(1).data}}class Ct extends e{static kind="greaterThan";static inputs=[c("number"),c("number")];static outputs=[w("boolean")];run(){this.output(0).data=this.input(0).data>this.input(1).data}}class Bt extends e{static kind="greaterThanOrEqual";static inputs=[c("number"),c("number")];static outputs=[w("boolean")];run(){this.output(0).data=this.input(0).data>=this.input(1).data}}class $t extends e{static kind="inequality";static inputs=[c(),c()];static outputs=[w("boolean")];run(){this.output(0).data=this.input(0).data!=this.input(1).data}}class Ft extends e{static kind="multiplication";static inputs=[c("number"),c("number")];static outputs=[w("number")];run(){this.output(0).data=this.input(0).data*this.input(1).data}}class Rt extends e{static kind="subtraction";static inputs=[c("number"),c("number")];static outputs=[w("number")];run(){this.output(0).data=this.input(0).data-this.input(1).data}}const rs={[St.kind]:St,[jt.kind]:jt,[Pt.kind]:Pt,[Ct.kind]:Ct,[Bt.kind]:Bt,[vt.kind]:vt,[Mt.kind]:Mt,[$t.kind]:$t,[Ft.kind]:Ft,[Rt.kind]:Rt},{input:O,output:ds}=e;class cs extends e{static kind="stringLength";static inputs=[O("string")];static outputs=[ds("number")];run(){this.output(0).data=this.input(0).data.length}}class ps extends e{static kind="substring";static inputs=[O("string"),O("number",{name:"start"}),O("number",{name:"end",optional:!0})];static outputs=e.out(["string"]);run(){const t=this.input(0).data,s=this.input(1).data,n=this.input(2).data;this.output(0).data=t.substring(s,n)}}const hs={DflowNodeStringLength:cs,DflowNodeSubstring:ps},ls=Object.values(hs).reduce((i,t)=>({[t.kind]:t,...i}),{}),Lt={...Ht,...Gt,..._t,...ts,...es,...as,...us,...os,...rs,...ls};module.exports=Qt(fs);
