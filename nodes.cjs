var v=Object.defineProperty;var _t=Object.getOwnPropertyDescriptor;var ts=Object.getOwnPropertyNames;var ss=Object.prototype.hasOwnProperty;var ns=n=>v(n,"__esModule",{value:!0});var es=(n,t)=>{for(var s in t)v(n,s,{get:t[s],enumerable:!0})},is=(n,t,s,e)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of ts(t))!ss.call(n,a)&&(s||a!=="default")&&v(n,a,{get:()=>t[a],enumerable:!(e=_t(t,a))||e.enumerable});return n};var as=(n=>(t,s)=>n&&n.get(t)||(s=is(ns({}),t,1),n&&n.set(t,s),s))(typeof WeakMap!="undefined"?new WeakMap:0);var Os={};es(Os,{nodesCatalog:()=>Gt});class M extends Error{constructor(t,s){super(`${t} not found id=${s}`)}}const q=n=>`${n} must be a string`,us=(n,t)=>`${t} pin not found nodeId=${n}`,J=(n,t,s)=>`${us(n,t)} position=${s}`,F=({id:n,kind:t,outputs:s},e)=>{const a={id:n,kind:t,outputs:s?.map(({id:u,data:o,name:d})=>({id:u,data:o,name:d}))};return e&&(a.error=e),a};class r{static isArray(t){return!!Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowId(t){return r.isStringNotEmpty(t)}static isObject(t){return!(typeof t!="object"||!t||Array.isArray(t))}static isNumber(t){return typeof t=="number"&&!isNaN(t)}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return r.isString(t)&&t!==""}static validate(t,s){return s.length===0?!0:s.some(e=>{switch(e){case"array":return r.isArray(t);case"boolean":return r.isBoolean(t);case"number":return r.isNumber(t);case"object":return r.isObject(t);case"string":return r.isString(t);case"DflowId":return r.isDflowId(t);default:return!1}},!0)}}class T{id;name;constructor({id:t,name:s}){this.id=t,this.name=s}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}class z extends T{kind;types;static types=["string","number","boolean","object","array","DflowId"];constructor(t,{types:s=[],...e}){super(e);this.kind=t,this.types=s}get hasTypeAny(){return this.types.length===0}hasType(t){return this.hasTypeAny||this.types.includes(t)}toObject(){const t=super.toObject();return this.types.length>0&&(t.types=this.types),t}}class os extends z{#t;#s;#n;#e;constructor({multi:t,optional:s,...e}){super("input",e);this.#t=t,this.#s=s}get data(){if(this.#t){const t=Array.from(this.#e??[]);return t.length?t.map(s=>s.data):void 0}else return this.#n?.data}get isConnected(){return this.#t?Array.from(this.#e??[]).length>0:typeof this.#n>"u"}get isMulti(){return this.#t}get isOptional(){return this.#s}connectTo(t){const{hasTypeAny:s,types:e}=this,{types:a}=t;if(s||e.some(o=>a.includes(o)))this.#t?(this.#e||(this.#e=new Set),this.#e.add(t)):this.#n=t;else throw new Error(`mismatching pinTypes, source has types [${a.join()}] and target has types [${e.join()}]`)}disconnect(){this.#t?this.#e?.clear():this.#n=void 0}toObject(){return super.toObject()}}class rs extends z{#t;constructor({data:t,...s}){super("output",s);this.#t=t}clear(){this.#t=void 0}get data(){return this.#t}set data(t){switch(!0){case typeof t>"u":this.clear();break;case this.hasTypeAny:case(this.hasType("string")&&r.isString(t)):case(this.hasType("number")&&r.isNumber(t)):case(this.hasType("boolean")&&r.isBoolean(t)):case(this.hasType("object")&&r.isObject(t)):case(this.hasType("array")&&r.isArray(t)):case(this.hasType("DflowId")&&r.isDflowId(t)):{this.#t=t;break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof data is ${typeof t}`)}}toObject(){const t=super.toObject();return typeof this.#t<"u"&&(t.data=this.#t),t}}class i extends T{#t=new Map;#s=new Map;#n=[];#e=[];kind;meta;host;static kind;static isAsync;static isConstant;static inputs;static outputs;static input(t=[],s){return typeof t=="string"?{types:[t],...s}:{types:t,...s}}static output(t=[],s){return typeof t=="string"?{types:[t],...s}:{types:t,...s}}constructor({kind:t,inputs:s=[],outputs:e=[],...a},u,{isAsync:o=!1,isConstant:d=!1}={}){super(a);this.host=u,this.kind=t,this.meta={isAsync:o,isConstant:d};for(const f of s)this.newInput(f);for(const f of e)this.newOutput(f)}get inputs(){return this.#t.values()}get outputs(){return this.#s.values()}clearOutputs(){for(const t of this.outputs)t.clear()}getInputById(t){const s=this.#t.get(t);if(!s)throw new M("input",t);return s}input(t){const s=this.#n[t];if(!s)throw new Error(J(this.id,"input",t));return this.getInputById(s)}getOutputById(t){const s=this.#s.get(t);if(!s)throw new M("output",t);return s}output(t){const s=this.#e[t];if(!s)throw new Error(J(this.id,"output",t));return this.getOutputById(s)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),this.#t.delete(t),this.#n.splice(this.#n.indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),this.#s.delete(t),this.#e.splice(this.#e.indexOf(t),1)}newInput(t){const s=this.#t.size,e=(o=s)=>{const d=`i${o}`;return this.#t.has(d)?e(o+1):d},a=r.isDflowId(t.id)?t.id:e(),u=new os({...t,id:a});return this.#t.set(a,u),this.#n.push(a),u}newOutput(t){const s=this.#s.size,e=(o=s)=>{const d=`o${o}`;return this.#s.has(d)?e(o+1):d},a=r.isDflowId(t.id)?t.id:e(),u=new rs({...t,id:a});return this.#s.set(a,u),this.#e.push(a),u}run(){}toObject(){const t={...super.toObject(),kind:this.kind},s=[],e=[];for(const a of this.inputs)s.push(a.toObject());s.length>0&&(t.inputs=s);for(const a of this.outputs)e.push(a.toObject());return e.length>0&&(t.outputs=e),t}}class ds extends T{source;target;constructor({source:t,target:s,...e}){super(e);this.source=t,this.target=s}toObject(){return{...super.toObject(),source:this.source,target:this.target}}}class m extends T{nodes=new Map;edges=new Map;runOptions={verbose:!1};runStatus=null;executionReport=null;static childrenOfNodeId(t,s){return s.filter(({sourceId:e})=>t===e).map(({targetId:e})=>e)}static parentsOfNodeId(t,s){return s.filter(({targetId:e})=>t===e).map(({sourceId:e})=>e)}static levelOfNodeId(t,s){const e=m.parentsOfNodeId(t,s);if(e.length===0)return 0;let a=0;for(const u of e){const o=m.levelOfNodeId(u,s);a=Math.max(o,a)}return a+1}static ancestorsOfNodeId(t,s){const e=m.parentsOfNodeId(t,s);return e.length===0?[]:e.reduce((a,u,o,d)=>{const f=m.ancestorsOfNodeId(u,s),l=a.concat(f);return o===d.length-1?Array.from(new Set(d.concat(l))):l},[])}static sort(t,s){const e={};for(const a of t)e[a]=m.levelOfNodeId(a,s);return t.slice().sort((a,u)=>e[a]<=e[u]?-1:1)}get nodeConnections(){return[...this.edges.values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}#t(){const t=[];for(const s of[...this.nodes.values()])s.kind==="return"&&t.push(m.ancestorsOfNodeId(s.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const s=this.#t(),e=m.sort([...this.nodes.keys()].filter(a=>!s.includes(a)),this.nodeConnections);s:for(const a of e){const u=this.nodes.get(a);try{if(!u.meta.isConstant){let o=!1;t:for(const{id:d,data:f,types:l,isOptional:p}of u.inputs){if(p&&typeof f>"u")continue t;if(!r.validate(f,l)){o=!0,t&&this.executionReport.steps?.push(F(u.toObject(),`invalid input data nodeId=${a} inputId=${d} data=${f}`));break t}}if(o){for(const d of u.outputs)d.clear();continue s}u.meta.isAsync?await u.run():u.run()}t&&this.executionReport.steps?.push(F(u.toObject()))}catch(o){console.error(o),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t={...super.toObject(),nodes:[],edges:[]};for(const s of this.nodes.values())t.nodes.push(s.toObject());for(const s of this.edges.values())t.edges.push(s.toObject());return t}}class j{#t;nodesCatalog;context;static#s(t=[]){return t.map((s,e)=>({...s,id:r.isDflowId(s.id)?s.id:`i${e}`}))}static#n(t=[]){return t.map((s,e)=>({...s,id:r.isDflowId(s.id)?s.id:`o${e}`}))}constructor(t={}){this.nodesCatalog={...t,...ps},this.#t=new m({id:"g1"}),this.context={}}get executionReport(){return this.#t.executionReport}get edges(){return Array.from(this.#t.edges.values())}get nodes(){return this.#t.nodes}get runStatusIsSuccess(){return this.#t.runStatus==="success"}get runStatusIsWaiting(){return this.#t.runStatus==="waiting"}get runStatusIsFailure(){return this.#t.runStatus==="failure"}set verbose(t){this.#t.runOptions.verbose=t}clearGraph(){this.#t.nodes.clear(),this.#t.edges.clear()}connect(t,s=0){return{to:(e,a=0)=>{const u=t.output(s),o=e.input(a);this.newEdge({source:[t.id,u.id],target:[e.id,o.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(q("edgeId"));const s=this.getEdgeById(t);if(!s)return;const[e,a]=s.target;this.getNodeById(e).getInputById(a).disconnect(),this.#t.edges.delete(t)}deleteNode(t){if(typeof t!="string")throw new TypeError(q("nodeId"));const s=this.getNodeById(t);if(s){for(const e of this.edges){const{source:[a],target:[u]}=e;(a===s.id||u===s.id)&&this.deleteEdge(e.id)}this.#t.nodes.delete(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,s]){for(const e of this.edges){const[a,u]=e.source,[o,d]=e.target;(a===t&&u===s||o===t&&d===s)&&this.deleteEdge(e.id)}}executeFunction(t,s){const{verbose:e}=this.#t.runOptions,a=this.#t.nodeConnections,u=m.childrenOfNodeId(t,a),o=[];for(const l of u){const p=this.getNodeById(l);p.kind===C.kind&&o.push(p.id)}const d=o.reduce((l,p,y,D)=>{const R=m.ancestorsOfNodeId(p,a),O=l.concat(R);return y===D.length?Array.from(new Set(O)):O},[]),f=m.sort([...o,...d],a);for(const l of f){const p=this.getNodeById(l);try{switch(p.kind){case B.kind:{const y=p.input(0).data,D=typeof y=="number"&&!isNaN(y)?Math.max(y,0):0;p.output(0).data=s[D];break}case C.kind:return p.input(1).data;default:!p.meta.isConstant&&!p.meta.isAsync&&p.run(),e&&this.executionReport?.steps?.push(F(p.toObject()))}}catch(y){console.error(y)}}}getEdgeById(t){const s=this.#t.edges.get(t);if(!s)throw new M("edge",t);return s}getNodeById(t){const s=this.#t.nodes.get(t);if(!s)throw new M("node",t);return s}newNode(t){const s=this.#t.nodes.size,e=(p=s)=>{const y=`n${p}`;return this.#t.nodes.has(y)?e(p+1):y},a=this.nodesCatalog[t.kind]??cs,u=r.isDflowId(t.id)?t.id:e(),o={isAsync:a.isAsync,isConstant:a.isConstant},d=Array.isArray(t.inputs)?j.#s(t.inputs):j.#s(a.inputs??[]),f=Array.isArray(t.outputs)?j.#n(t.outputs):j.#n(a.outputs??[]),l=new a({...t,id:u,inputs:d,outputs:f},this,o);return this.#t.nodes.set(l.id,l),l}newEdge(t){const s=this.#t.edges.size,e=(O=s)=>{const L=`e${O}`;return this.#t.edges.has(L)?e(O+1):L},a=r.isDflowId(t.id)?t.id:e(),u=new ds({...t,id:a});this.#t.edges.set(u.id,u);const[o,d]=u.source,[f,l]=u.target,p=this.getNodeById(o),y=this.getNodeById(f),D=p.getOutputById(d);return y.getInputById(l).connectTo(D),u}newInput(t,s){return this.getNodeById(t).newInput(s)}newOutput(t,s){return this.getNodeById(t).newOutput(s)}toObject(){return this.#t.toObject()}async run(){await this.#t.run()}}const{input:w,output:I}=i;class B extends i{static kind="argument";static isConstant=!0;static inputs=[w("number",{name:"position",optional:!0})];static outputs=[I()]}class U extends i{static kind="array";static inputs=[w()];static outputs=[I("array")];run(){const t=this.input(0).data;r.isArray(t)?this.output(0).data=t:this.output(0).clear()}}class V extends i{static kind="boolean";static inputs=[w()];static outputs=[I("boolean")];run(){const t=this.input(0).data;r.isBoolean(t)?this.output(0).data=t:this.output(0).clear()}}class K extends i{static kind="data";static isConstant=!0;static outputs=[I()]}class W extends i{static kind="function";static isConstant=!0;static outputs=[I("DflowId",{name:"id"})];constructor(...t){super(...t);this.output(0).data=this.id}}class Q extends i{static kind="isUndefined";static inputs=[w()];static outputs=[I("boolean")];run(){this.output(0).data=typeof this.input(0).data>"u"}}class X extends i{static kind="number";static inputs=[w()];static outputs=[I("number")];run(){const t=this.input(0).data;r.isNumber(t)?this.output(0).data=t:this.output(0).clear()}}class Y extends i{static kind="object";static inputs=[w()];static outputs=[I("object")];run(){const t=this.input(0).data;r.isObject(t)?this.output(0).data=t:this.output(0).clear()}}class C extends i{static kind="return";static isConstant=!0;static inputs=[w("DflowId",{name:"functionId"}),w([],{name:"value"})]}class Z extends i{static kind="string";static inputs=[w()];static outputs=[I("string")];run(){const t=this.input(0).data;r.isString(t)?this.output(0).data=t:this.output(0).clear()}}class cs extends i{}const ps={[B.kind]:B,[U.kind]:U,[V.kind]:V,[K.kind]:K,[Q.kind]:Q,[X.kind]:X,[Y.kind]:Y,[W.kind]:W,[Z.kind]:Z,[C.kind]:C},{input:c,output:g}=i;class H extends i{static kind="arrayAt";static inputs=[c("array"),c("number",{name:"index"})];static outputs=[g()];run(){const t=this.input(0).data,s=this.input(1).data;this.output(0).data=t.at(s)}}class G extends i{static kind="arrayFilter";static inputs=[c("array"),c("DflowId",{name:"functionId"})];static outputs=[g("array")];run(){this.output(0).data=this.input(0).data.filter((...t)=>this.host.executeFunction(this.input(1).data,t))}}class _ extends i{static kind="arrayFindLastIndex";static inputs=[c("array"),c("DflowId",{name:"functionId"})];static outputs=[g("number")];run(){this.output(0).data=this.input(0).data.findLastIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}class tt extends i{static kind="arrayFindIndex";static inputs=[c("array"),c("DflowId",{name:"functionId"})];static outputs=[g("number")];run(){this.output(0).data=this.input(0).data.findIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}class st extends i{static kind="arrayIncludes";static inputs=[c("array",{name:"array"}),c("string",{name:"element"})];static outputs=[g("boolean")];run(){const t=this.input(0).data,s=this.input(1).data;Array.isArray(t)&&(this.output(0).data=t.includes(s))}}class nt extends i{static kind="arrayJoin";static inputs=[c("array",{name:"array"}),c("string",{name:"separator",optional:!0})];static outputs=[g("string")];run(){this.output(0).data=this.input(0).data.join(this.input(1).data)}}class et extends i{static kind="arrayLength";static inputs=[c("array")];static outputs=[g("number")];run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t.length:this.output(0).clear}}class it extends i{static kind="arrayMap";static inputs=[c("array"),c("DflowId",{name:"functionId"})];static outputs=[g("array")];run(){this.output(0).data=this.input(0).data.map((...t)=>this.host.executeFunction(this.input(1).data,t))}}class at extends i{static kind="arrayPop";static inputs=[c("array")];static outputs=[g([],{name:"element"}),g("array",{name:"rest"})];run(){const t=this.input(0).data.slice(),s=t.pop();this.output(0).data=s,this.output(1).data=t}}class ut extends i{static kind="arrayPush";static inputs=[c("array"),c([],{name:"element"})];static outputs=[g("array")];run(){const t=this.input(0).data.slice(),s=this.input(1).data;s&&t.push(s),this.output(0).data=t}}class ot extends i{static kind="arrayReverse";static inputs=[c("array")];static outputs=[c("array")];run(){const t=this.input(0).data.slice();this.output(0).data=t.reverse()}}class rt extends i{static kind="arrayShift";static inputs=[c("array")];static outputs=[g([],{name:"element"}),g("array",{name:"rest"})];run(){const t=this.input(0).data.slice(),s=t.shift();this.output(0).data=s,this.output(1).data=t}}class dt extends i{static kind="arraySlice";static inputs=[c("array"),c("number",{name:"start"}),c("number",{name:"end",optional:!0})];static outputs=[g("array")];run(){const t=super.input(0).data,s=super.input(1).data,e=super.input(2).data;typeof e=="number"?super.output(0).data=t.slice(s,e):super.output(0).data=t.slice(s)}}const hs={[H.kind]:H,[G.kind]:G,[_.kind]:_,[tt.kind]:tt,[st.kind]:st,[nt.kind]:nt,[et.kind]:et,[it.kind]:it,[at.kind]:at,[ut.kind]:ut,[ot.kind]:ot,[rt.kind]:rt,[dt.kind]:dt},{input:$,output:ls}=i;class ct extends i{static kind="if";static inputs=[$([],{name:"condition"}),$([],{name:"then"}),$([],{name:"else"})];static outputs=[ls()];run(){this.output(0).data=this.input(0).data?this.input(1).data:this.input(2).data}}const fs={[ct.kind]:ct},{input:gs}=i;class pt extends i{static kind="consoleLog";static inputs=[gs()];run(){console.log(this.input(0).data)}}const ys={[pt.kind]:pt},{input:ms,output:ht}=i,lt=[ht("string"),ht("number",{name:"milliseconds"})];class ft extends i{static kind="newDate";static inputs=[ms(["string","number"],{optional:!0})];static outputs=lt;run(){const t=this.input(0).data;if(typeof t=="string"||typeof t=="number"){const e=new Date(t),a=e.toJSON();a!==null&&(this.output(0).data=a,this.output(1).data=e.getTime())}const s=new Date;this.output(0).data=s.toJSON(),this.output(1).data=s.getTime()}}class gt extends i{static kind="now";static outputs=lt;run(){const t=Date.now();this.output(0).data=new Date(t).toJSON(),this.output(1).data=t}}const bs={[ft.kind]:ft,[gt.kind]:gt},{input:N,output:E}=i;class yt extends i{static kind="and";static inputs=[N("boolean"),N("boolean")];static outputs=[E("boolean")];run(){this.output(0).data=this.input(0).data&&this.input(1).data}}class mt extends i{static kind="not";static inputs=[N("boolean")];static outputs=[E("boolean")];run(){this.output(0).data=!this.input(0).data}}class bt extends i{static kind="??";static inputs=[N(),N()];static outputs=[E()];run(){this.output(0).data=this.input(0).data??this.input(1).data}}class kt extends i{static kind="or";static inputs=[N("boolean"),N("boolean")];static outputs=[E("boolean")];run(){this.output(0).data=this.input(0).data||this.input(1).data}}const ks={[yt.kind]:yt,[mt.kind]:mt,[bt.kind]:bt,[kt.kind]:kt},{input:x,output:b}=i;class wt extends i{static kind="mathAbs";static inputs=[x("number")];static outputs=[b("number")];run(){this.output(0).data=Math.abs(this.input(0).data)}}class It extends i{static kind="mathCos";static inputs=[x("number")];static outputs=[b("number")];run(){this.output(0).data=Math.cos(this.input(0).data)}}class xt extends i{static kind="mathCosh";static inputs=[x("number")];static outputs=[b("number")];run(){this.output(0).data=Math.cosh(this.input(0).data)}}class Nt extends i{static kind="mathFloor";static inputs=[x("number")];static outputs=[b("number")];run(){this.output(0).data=Math.floor(this.input(0).data)}}class Dt extends i{static kind="mathMax";static inputs=[x("array")];static outputs=[b("number")];run(){const t=this.input(0).data,s=Math.max(...t);isNaN(s)?this.output(0).clear():this.output(0).data=s}}class Ot extends i{static kind="mathMin";static inputs=[x("array")];static outputs=[b("number")];run(){const t=this.input(0).data,s=Math.min(...t);isNaN(s)?this.output(0).clear():this.output(0).data=s}}class At extends i{static kind="mathPI";static isConstant=!0;static outputs=[b("number",{name:"\u03C0",data:Math.PI})]}class St extends i{static kind="mathRound";static inputs=[x("number")];static outputs=[b("number")];run(){this.output(0).data=Math.round(this.input(0).data)}}class jt extends i{static kind="mathSin";static inputs=[x("number")];static outputs=[b("number")];run(){this.output(0).data=Math.sin(this.input(0).data)}}class Mt extends i{static kind="mathSinh";static inputs=[x("number")];static outputs=[b("number")];run(){this.output(0).data=Math.sinh(this.input(0).data)}}const ws={[wt.kind]:wt,[It.kind]:It,[xt.kind]:xt,[Nt.kind]:Nt,[Dt.kind]:Dt,[Ot.kind]:Ot,[At.kind]:At,[St.kind]:St,[jt.kind]:jt,[Mt.kind]:Mt},{input:A,output:S}=i;class Tt extends i{static kind="isFinite";static inputs=[A("number")];static outputs=[S("boolean")];run(){this.output(0).data=Number.isFinite(this.input(0).data)}}class Ct extends i{static kind="isInteger";static inputs=[A()];static outputs=[S("boolean")];run(){this.output(0).data=Number.isInteger(this.input(0).data)}}class Et extends i{static kind="isNaN";static inputs=[A()];static outputs=[S("boolean")];run(){this.output(0).data=Number.isNaN(this.input(0).data)}}class Pt extends i{static kind="parseFloat";static inputs=[A("string")];static outputs=[S("number")];run(){this.output(0).data=parseFloat(this.input(0).data)}}class vt extends i{static kind="parseInt";static inputs=[A(["number","string"])];static outputs=[S("number")];run(){this.output(0).data=parseInt(this.input(0).data)}}const Is={[Tt.kind]:Tt,[Ct.kind]:Ct,[Et.kind]:Et,[Pt.kind]:Pt,[vt.kind]:vt},{input:Ft,output:Bt}=i;class $t extends i{static kind="objectKeys";static inputs=[Ft("object")];static outputs=[Bt("array")];run(){this.output(0).data=Object.keys(this.input(0).data)}}class Rt extends i{static kind="objectValues";static inputs=[Ft("object")];static outputs=[Bt("array")];run(){this.output(0).data=Object.values(this.input(0).data)}}const xs={[$t.kind]:$t,[Rt.kind]:Rt},{input:h,output:k}=i;class Lt extends i{static kind="addition";static inputs=[h("number"),h("number")];static outputs=[k("number")];run(){this.output(0).data=this.input(0).data+this.input(1).data}}class qt extends i{static kind="division";static inputs=[h("number"),h("number")];static outputs=[k("number")];run(){this.input(1).data?this.output(0).data=this.input(0).data/this.input(1).data:this.output(0).clear()}}class Jt extends i{static kind="equality";static inputs=[h(),h()];static outputs=[k("boolean")];run(){this.output(0).data=this.input(0).data==this.input(1).data}}class zt extends i{static kind="lessThan";static inputs=[h("number"),h("number")];static outputs=[k("boolean")];run(){this.output(0).data=this.input(0).data<this.input(1).data}}class Ut extends i{static kind="lessThanOrEqual";static inputs=[h("number"),h("number")];static outputs=[k("boolean")];run(){this.output(0).data=this.input(0).data<=this.input(1).data}}class Vt extends i{static kind="greaterThan";static inputs=[h("number"),h("number")];static outputs=[k("boolean")];run(){this.output(0).data=this.input(0).data>this.input(1).data}}class Kt extends i{static kind="greaterThanOrEqual";static inputs=[h("number"),h("number")];static outputs=[k("boolean")];run(){this.output(0).data=this.input(0).data>=this.input(1).data}}class Wt extends i{static kind="inequality";static inputs=[h(),h()];static outputs=[k("boolean")];run(){this.output(0).data=this.input(0).data!=this.input(1).data}}class Qt extends i{static kind="multiplication";static inputs=[h("number"),h("number")];static outputs=[k("number")];run(){this.output(0).data=this.input(0).data*this.input(1).data}}class Xt extends i{static kind="subtraction";static inputs=[h("number"),h("number")];static outputs=[k("number")];run(){this.output(0).data=this.input(0).data-this.input(1).data}}const Ns={[Lt.kind]:Lt,[qt.kind]:qt,[Jt.kind]:Jt,[Vt.kind]:Vt,[Kt.kind]:Kt,[zt.kind]:zt,[Ut.kind]:Ut,[Wt.kind]:Wt,[Qt.kind]:Qt,[Xt.kind]:Xt},{input:P,output:Yt}=i;class Zt extends i{static kind="stringLength";static inputs=[P("string")];static outputs=[Yt("number")];run(){this.output(0).data=this.input(0).data.length}}class Ht extends i{static kind="substring";static inputs=[P("string"),P("number",{name:"start"}),P("number",{name:"end",optional:!0})];static outputs=[Yt("string")];run(){const t=this.input(0).data,s=this.input(1).data,e=this.input(2).data;this.output(0).data=t.substring(s,e)}}const Ds={[Ht.kind]:Ht,[Zt.kind]:Zt},Gt={...hs,...fs,...ys,...bs,...ks,...ws,...Is,...xs,...Ns,...Ds};module.exports=as(Os);
