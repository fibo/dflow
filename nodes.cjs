var g=Object.defineProperty;var Lt=Object.getOwnPropertyDescriptor;var Rt=Object.getOwnPropertyNames;var Ut=Object.prototype.hasOwnProperty;var qt=n=>g(n,"__esModule",{value:!0});var Gt=(n,t)=>{for(var i in t)g(n,i,{get:t[i],enumerable:!0})},Jt=(n,t,i,e)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of Rt(t))!Ut.call(n,a)&&(i||a!=="default")&&g(n,a,{get:()=>t[a],enumerable:!(e=Lt(t,a))||e.enumerable});return n};var zt=(n=>(t,i)=>n&&n.get(t)||(i=Jt(qt({}),t,1),n&&n.set(t,i),i))(typeof WeakMap!="undefined"?new WeakMap:0);var ns={};Gt(ns,{nodesCatalog:()=>Bt});const h=n=>`${n} must be a string`,k=n=>`${n} must be a number`,I=(n,t)=>`${t} pin not found nodeId=${n}`,D=(n,t,i)=>`${I(n,t)} position=${i}`,x=(n,t,i)=>`${I(n,t)} pinId=${i}`,T=({id:n,kind:t,outputs:i})=>({id:n,kind:t,outputs:i?.map(({id:e,data:a,name:o})=>({id:e,data:a,name:o}))});class u{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowGraph(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&Array.isArray(t.nodes)&&Array.isArray(t.edges)&&c.isDflowGraph(t)}static isDflowId(t){return u.isStringNotEmpty(t)}static isDflowType(t){return typeof t=="string"&&l.types.includes(t)}static isObject(t){return!u.isUndefined(t)&&!u.isNull(t)&&!u.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return u.isString(t)&&t.length>0}static isUndefined(t){return typeof t>"u"}static validate(t,i){return i.length===0?!0:i.some(e=>{switch(e){case"array":return u.isArray(t);case"boolean":return u.isBoolean(t);case"null":return u.isNull(t);case"number":return u.isNumber(t);case"object":return u.isObject(t);case"string":return u.isString(t);case"DflowGraph":return u.isDflowGraph(t);case"DflowId":return u.isDflowId(t);case"DflowType":return u.isDflowType(t);default:return!1}},!0)}}class f{id;name;static isDflowItem({id:t,name:i}){return u.isDflowId(t)&&(u.isUndefined(i)||u.isStringNotEmpty(i))}constructor({id:t,name:i}){this.id=t,this.name=i}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}class l extends f{kind;types;static types=["string","number","boolean","null","object","array","DflowId","DflowGraph","DflowType"];static isDflowPin({types:t=[],...i}){return f.isDflowItem(i)&&t.every(e=>l.isDflowPinType(e))}static isDflowPinType(t){l.types.includes(t)}constructor(t,{types:i=[],...e}){super(e);this.kind=t,this.types=i}get hasTypeAny(){return this.types.length===0}get hasTypeDflowId(){return this.hasTypeAny||this.types.includes("DflowId")}get hasTypeDflowGraph(){return this.hasTypeAny||this.types.includes("DflowGraph")}get hasTypeDflowType(){return this.hasTypeAny||this.types.includes("DflowType")}get hasTypeString(){return this.hasTypeAny||this.types.includes("string")}get hasTypeNumber(){return this.hasTypeAny||this.types.includes("number")}get hasTypeBoolean(){return this.hasTypeAny||this.types.includes("boolean")}get hasTypeNull(){return this.hasTypeAny||this.types.includes("null")}get hasTypeObject(){return this.hasTypeAny||this.types.includes("object")}get hasTypeArray(){return this.hasTypeAny||this.types.includes("array")}addType(t){this.types.push(t)}removeType(t){this.types.splice(this.types.indexOf(t),1)}}class w extends l{#t;#s;static isDflowInput({id:t,types:i}){return l.isDflowPin({id:t,types:i})}constructor({optional:t,...i}){super("input",i);this.#s=t}get data(){return this.#t?.data}get isConnected(){return typeof this.#t>"u"}get isOptional(){return this.#s}connectTo(t){const{hasTypeAny:i,types:e}=this,{types:a}=t;if(i||e.some(o=>a.includes(o)))this.#t=t;else throw new Error(`mismatching pinTypes, source has types [${a.join()}] and target has types [${e.join()}]`)}disconnect(){this.#t=void 0}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}class b extends l{#t;static isDflowOutput({id:t,data:i,types:e=[]}){return l.isDflowPin({id:t,types:e})&&u.validate(i,e)}constructor({data:t,...i}){super("output",i);this.#t=t}clear(){this.#t=void 0}get data(){return this.#t}set data(t){switch(!0){case u.isUndefined(t):this.clear();break;case this.hasTypeAny:case(u.isDflowGraph(t)&&this.hasTypeDflowGraph):case(u.isDflowId(t)&&this.hasTypeDflowId):case(u.isString(t)&&this.hasTypeString):case(u.isNumber(t)&&this.hasTypeNumber):case(u.isBoolean(t)&&this.hasTypeBoolean):case(u.isNull(t)&&this.hasTypeNull):case(u.isObject(t)&&this.hasTypeObject):case(u.isArray(t)&&this.hasTypeArray):{this.#t=t;break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t={...super.toObject()};return u.isUndefined(this.#t)||(t.data=this.#t),this.types.length>0&&(t.types=this.types),t}}class s extends f{#t=new Map;#s=new Map;#i=[];#n=[];#e;kind;meta;host;static kind;static isAsync;static isConstant;static label;static inputs;static outputs;static generateInputIds(t=[]){return t.map((i,e)=>({...i,id:`i${e}`}))}static generateOutputIds(t=[]){return t.map((i,e)=>({...i,id:`o${e}`}))}static in(t=[],i){return[{types:t,...i}]}static ins(t,i=[]){return Array(t).fill(s.in(i)).flat()}static out(t=[],i){return[{types:t,...i}]}static outs(t,i=[]){return Array(t).fill(s.out(i)).flat()}static outputNumber(t){return{...t,types:["number"]}}static isDflowNode({kind:t,inputs:i=[],outputs:e=[],...a}){return f.isDflowItem(a)&&u.isStringNotEmpty(t)&&i.every(o=>w.isDflowInput(o))&&e.every(o=>b.isDflowOutput(o))}constructor({kind:t,inputs:i=[],outputs:e=[],...a},o,{isAsync:r=!1,isConstant:d=!1,label:y}={}){super(a);this.#e=y,this.host=o,this.kind=t,this.meta={isAsync:r,isConstant:d};for(const p of i)this.newInput(p);for(const p of e)this.newOutput(p);this.onCreate()}get label(){return this.#e||this.kind}get inputs(){return this.#t.values()}get outputs(){return this.#s.values()}get numInputs(){return this.#t.size}get numOutputs(){return this.#s.size}clearOutputs(){for(const t of this.outputs)t.clear()}#a(t=this.numInputs){const i=`i${t}`;return this.#t.has(i)?this.#a(t+1):i}#u(t=this.numOutputs){const i=`o${t}`;return this.#s.has(i)?this.#u(t+1):i}getInputById(t){if(typeof t!="string")throw new TypeError(h("inputId"));const i=this.#t.get(t);if(i instanceof w)return i;throw new Error(x(this.id,"input",t))}input(t){if(typeof t!="number")throw new TypeError(k("position"));const i=this.#i[t];if(u.isUndefined(i))throw new Error(D(this.id,"input",t));return this.getInputById(i)}getOutputById(t){if(typeof t!="string")throw new TypeError(h("outputId"));const i=this.#s.get(t);if(i instanceof b)return i;throw new Error(x(this.id,"output",t))}output(t){if(typeof t!="number")throw new TypeError(k("position"));const i=this.#n[t];if(u.isUndefined(i))throw new Error(D(this.id,"output",t));return this.getOutputById(i)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),this.#t.delete(t),this.#i.splice(this.#i.indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),this.#s.delete(t),this.#n.splice(this.#n.indexOf(t),1)}onBeforeConnectInput(t,i){}onCreate(){}newInput(t){const i=u.isDflowId(t.id)?t.id:this.#a(),e=new w({...t,id:i});return this.#t.set(i,e),this.#i.push(i),e}newOutput(t){const i=u.isDflowId(t.id)?t.id:this.#u(),e=new b({...t,id:i});return this.#s.set(i,e),this.#n.push(i),e}run(){}toObject(){const t={...super.toObject(),kind:this.kind},i=[],e=[];for(const a of this.inputs)i.push(a.toObject());i.length>0&&(t.inputs=i);for(const a of this.outputs)e.push(a.toObject());return e.length>0&&(t.outputs=e),t}}class Ft extends s{static kind="Unknown";constructor(t,i){super({...t,kind:Ft.kind},i)}run(){}}class A extends f{source;target;static isDflowEdge({source:t,target:i,...e},a){return f.isDflowItem(e)&&Array.isArray(t)&&t.length===2&&a.nodes.find(({id:o,outputs:r=[]})=>o===t[0]&&r.find(({id:d})=>d===t[1]))&&Array.isArray(i)&&i.length===2&&a.nodes.find(({id:o,inputs:r=[]})=>o===i[0]&&r.find(({id:d})=>d===i[1]))}constructor({source:t,target:i,...e}){super(e);const[a,o]=t,[r,d]=i;if(typeof a!="string")throw new TypeError(h("sourceNodeId"));if(typeof o!="string")throw new TypeError(h("sourcePinId"));if(typeof r!="string")throw new TypeError(h("targetNodeId"));if(typeof d!="string")throw new TypeError(h("targetPinId"));this.source=t,this.target=i}toObject(){return{...super.toObject(),source:this.source,target:this.target}}}class c extends f{#t=new Map;#s=new Map;runOptions={verbose:!1};runStatus=null;executionReport=null;static isDflowGraph(t){return t.nodes.every(i=>s.isDflowNode(i))&&t.edges.every(i=>A.isDflowEdge(i,t))}static childrenOfNodeId(t,i){return i.filter(({sourceId:e})=>t===e).map(({targetId:e})=>e)}static parentsOfNodeId(t,i){return i.filter(({targetId:e})=>t===e).map(({sourceId:e})=>e)}static levelOfNodeId(t,i){const e=c.parentsOfNodeId(t,i);if(e.length===0)return 0;let a=0;for(const o of e){const r=c.levelOfNodeId(o,i);a=Math.max(r,a)}return a+1}static ancestorsOfNodeId(t,i){const e=c.parentsOfNodeId(t,i);return e.length===0?[]:e.reduce((a,o,r,d)=>{const y=c.ancestorsOfNodeId(o,i),p=a.concat(y);return r===d.length-1?Array.from(new Set(d.concat(p))):p},[])}static sort(t,i){const e={};for(const a of t)e[a]=c.levelOfNodeId(a,i);return t.slice().sort((a,o)=>e[a]<=e[o]?-1:1)}get edges(){return this.#s.values()}get nodes(){return this.#t.values()}get nodeConnections(){return[...this.#s.values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...this.#s.keys()]}get nodeIds(){return[...this.#t.keys()]}get numEdges(){return this.#s.size}get numNodes(){return this.#t.size}addEdge(t){if(this.#s.has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);this.#s.set(t.id,t)}addNode(t){if(this.#t.has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);this.#t.set(t.id,t)}clear(){this.#t.clear(),this.#s.clear()}deleteEdge(t){this.#s.delete(t)}deleteNode(t){this.#t.delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(h("nodeId"));const i=this.#t.get(t);if(i instanceof s)return i;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(h("edgeId"));const i=this.#s.get(t);if(i instanceof A)return i;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const i=`e${t}`;return this.#s.has(i)?this.generateEdgeId(t+1):i}generateNodeId(t=this.numNodes){const i=`n${t}`;return this.#t.has(i)?this.generateNodeId(t+1):i}nodeIdsInsideFunctions(){const t=[];for(const i of this.nodes)i.kind==="return"&&t.push(c.ancestorsOfNodeId(i.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const i=this.nodeIdsInsideFunctions(),e=c.sort(this.nodeIds.filter(a=>!i.includes(a)),this.nodeConnections);s:for(const a of e){const o=this.#t.get(a);try{if(!o.meta.isConstant){let r=!1;t:for(const{data:d,types:y,isOptional:p}of o.inputs){if(p&&typeof d>"u")continue t;if(!u.validate(d,y)){r=!0;break t}}if(r){for(const d of o.outputs)d.clear();t&&this.executionReport.steps?.push(T(o.toObject()));continue s}o.meta.isAsync?await o.run():o.run()}t&&this.executionReport.steps?.push(T(o.toObject()))}catch(r){console.error(r),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t={...super.toObject(),nodes:[],edges:[]};for(const i of this.nodes)t.nodes.push(i.toObject());for(const i of this.edges)t.edges.push(i.toObject());return t}}class N extends s{static kind="arrayAt";static inputs=[...s.in(["array"]),...s.in(["number"],{name:"index"})];static outputs=s.out();run(){const t=this.input(0).data,i=this.input(1).data;this.output(0).data=t.at(i)}}class O extends s{static kind="arrayFilter";static inputs=[...s.in(["array"]),...s.in(["DflowId"],{name:"functionId"})];static outputs=s.out(["array"]);run(){this.output(0).data=this.input(0).data.filter((...t)=>this.host.executeFunction(this.input(1).data,t))}}class E extends s{static kind="arrayFindLastIndex";static inputs=[...s.in(["array"]),...s.in(["DflowId"],{name:"functionId"})];static outputs=s.out(["number"]);run(){this.output(0).data=this.input(0).data.findLastIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}class j extends s{static kind="arrayFindIndex";static inputs=[...s.in(["array"]),...s.in(["DflowId"],{name:"functionId"})];static outputs=s.out(["number"]);run(){this.output(0).data=this.input(0).data.findIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}class S extends s{static kind="arrayIncludes";static inputs=[...s.in(["array"],{name:"array"}),...s.in(["string"],{name:"element"})];static outputs=s.out(["boolean"]);run(){const t=this.input(0).data,i=this.input(1).data;Array.isArray(t)&&(this.output(0).data=t.includes(i))}}class M extends s{static kind="arrayJoin";static inputs=[...s.in(["array"],{name:"array"}),...s.in(["string"],{name:"separator",optional:!0})];static outputs=s.out(["string"]);run(){const t=this.input(0).data,i=this.input(1).data??",";Array.isArray(t)&&(this.output(0).data=t.join(i))}}class v extends s{static kind="arrayLength";static inputs=s.in(["array"]);static outputs=s.out(["number"]);run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t.length:this.output(0).clear}}class P extends s{static kind="arrayMap";static inputs=[...s.in(["array"]),...s.in(["DflowId"],{name:"functionId"})];static outputs=s.out(["array"]);run(){this.output(0).data=this.input(0).data.map((...t)=>this.host.executeFunction(this.input(1).data,t))}}class C extends s{static kind="arrayPop";static inputs=s.in(["array"]);static outputs=[...s.out([],{name:"element"}),...s.out(["array"],{name:"rest"})];run(){const t=this.input(0).data.slice(),i=t.pop();this.output(0).data=i,this.output(1).data=t}}class $ extends s{static kind="arrayPush";static inputs=[...s.in(["array"]),...s.in([],{name:"element"})];static outputs=s.out(["array"]);run(){const t=this.input(0).data.slice(),i=this.input(1).data;i&&t.push(i),this.output(0).data=t}}class F extends s{static kind="arrayReverse";static inputs=s.in(["array"]);static outputs=s.in(["array"]);run(){const t=this.input(0).data.slice();this.output(0).data=t.reverse()}}class B extends s{static kind="arrayShift";static inputs=s.in(["array"]);static outputs=[...s.out([],{name:"element"}),...s.out(["array"],{name:"rest"})];run(){const t=this.input(0).data.slice(),i=t.shift();this.output(0).data=i,this.output(1).data=t}}class L extends s{static kind="arraySlice";static inputs=[...s.in(["array"]),...s.in(["number"],{name:"start"}),...s.in(["number"],{name:"end",optional:!0})];static outputs=s.out(["array"]);run(){const t=super.input(0).data,i=super.input(1).data,e=super.input(2).data;typeof e=="number"?super.output(0).data=t.slice(i,e):super.output(0).data=t.slice(i)}}const Kt={[N.kind]:N,[O.kind]:O,[E.kind]:E,[j.kind]:j,[S.kind]:S,[M.kind]:M,[v.kind]:v,[P.kind]:P,[C.kind]:C,[$.kind]:$,[F.kind]:F,[B.kind]:B,[L.kind]:L};class R extends s{static kind="if";static inputs=[...s.in(["boolean"],{name:"condition"}),...s.in([],{name:"then"}),...s.in([],{name:"else"})];static outputs=s.out();run(){this.output(0).data=this.input(0).data?this.input(1).data:this.input(2).data}}const Vt={[R.kind]:R};class U extends s{static kind="consoleLog";static inputs=[...s.in([])];run(){console.log(this.input(0).data)}}const Ht={[U.kind]:U},q=[...s.out(["string"]),...s.out(["number"],{name:"milliseconds"})];class G extends s{static kind="newDate";static inputs=s.in(["string","number"],{optional:!0});static outputs=q;run(){const t=this.input(0).data;if(typeof t=="string"||typeof t=="number"){const e=new Date(t),a=e.toJSON();a!==null&&(this.output(0).data=a,this.output(1).data=e.getTime())}const i=new Date;this.output(0).data=i.toJSON(),this.output(1).data=i.getTime()}}class J extends s{static kind="now";static outputs=q;run(){const t=Date.now();this.output(0).data=new Date(t).toJSON(),this.output(1).data=t}}const Qt={[G.kind]:G,[J.kind]:J};class z extends s{static kind="data";static isConstant=!0;static outputs=s.out()}class K extends s{static kind="array";static inputs=s.in();static outputs=s.out(["array"]);run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t:this.output(0).clear()}}class V extends s{static kind="boolean";static inputs=s.in();static outputs=s.out(["boolean"]);run(){const t=this.input(0).data;typeof t=="boolean"?this.output(0).data=t:this.output(0).clear()}}class H extends s{static kind="number";static inputs=s.in();static outputs=s.out(["number"]);run(){const t=this.input(0).data;typeof t=="number"?this.output(0).data=t:this.output(0).clear()}}class Q extends s{static kind="object";static inputs=s.in();static outputs=s.out(["object"]);run(){const t=this.input(0).data;typeof t=="object"&&t!==null?this.output(0).data=t:this.output(0).clear()}}class W extends s{static kind="string";static inputs=s.in();static outputs=s.out(["string"]);run(){const t=this.input(0).data;typeof t=="string"?this.output(0).data=t:this.output(0).clear()}}class X extends s{static kind="isArray";static inputs=s.out();static outputs=s.out(["boolean"]);run(){const t=this.input(0).data;this.output(0).data=Array.isArray(t)}}class Y extends s{static kind="isDefined";static inputs=s.in();static outputs=s.out(["boolean"]);run(){const t=this.input(0).data;this.output(0).data=typeof t<"u"}}class Z extends s{static kind="isUndefined";static inputs=s.in();static outputs=s.out(["boolean"]);run(){const t=this.input(0).data;this.output(0).data=typeof t>"u"}}const Wt={[z.kind]:z,[Y.kind]:Y,[Z.kind]:Z,[K.kind]:K,[V.kind]:V,[H.kind]:H,[Q.kind]:Q,[W.kind]:W,[X.kind]:X};class m extends s{static kind="dflow";static outputs=s.out(["array"],{name:"nodeKinds"});run(){const t=this.output(0);t.data=this.host.nodeKinds}}class _ extends s{static kind="comment";static isConstant=!0;static outputs=s.out(["string"])}class tt extends s{static kind="typeNumber";static isConstant=!0;static outputs=s.out(["DflowType"],{name:"number",data:"number"})}class st extends s{static kind="argument";static isConstant=!0;static inputs=[...s.in(["DflowType"],{name:"type"}),...s.in(["number"],{name:"argumentPosition"})];static outputs=s.out();onBeforeConnectInput(t,i){const e=t.output(i).data;this.output(0).addType(e)}}class it extends s{static kind="function";static isConstant=!0;static outputs=m.out(["DflowId"],{name:"id"});onCreate(){this.output(0).data=this.id}}class nt extends s{static kind="return";static isConstant=!0;static inputs=[...m.in(["DflowId"],{name:"functionId"}),...m.in([],{name:"value"})]}const Xt={[m.kind]:m,[st.kind]:st,[_.kind]:_,[it.kind]:it,[nt.kind]:nt,[tt.kind]:tt};class et extends s{static kind="and";static inputs=s.ins(2,["boolean"]);static outputs=s.out(["boolean"]);run(){this.output(0).data=this.input(0).data&&this.input(1).data}}class at extends s{static kind="not";static inputs=s.in(["boolean"]);static outputs=s.out(["boolean"]);run(){this.output(0).data=!this.input(0).data}}class ut extends s{static kind="or";static inputs=s.ins(2,["boolean"]);static outputs=s.out(["boolean"]);run(){this.output(0).data=this.input(0).data||this.input(1).data}}const Yt={[et.kind]:et,[at.kind]:at,[ut.kind]:ut};class ot extends s{static kind="mathAbs";static inputs=s.in(["number"]);static outputs=s.out(["number"]);run(){this.output(0).data=Math.abs(this.input(0).data)}}class rt extends s{static kind="mathCos";static inputs=s.in(["number"]);static outputs=s.out(["number"]);run(){this.output(0).data=Math.cos(this.input(0).data)}}class dt extends s{static kind="mathCosh";static inputs=s.in(["number"]);static outputs=s.out(["number"]);run(){this.output(0).data=Math.cosh(this.input(0).data)}}class ct extends s{static kind="mathFloor";static inputs=s.in(["number"]);static outputs=s.out(["number"]);run(){this.output(0).data=Math.floor(this.input(0).data)}}class pt extends s{static kind="mathMax";static inputs=s.in(["array"]);static outputs=s.out(["number"]);run(){const t=this.input(0).data,i=Math.max(...t);isNaN(i)?this.output(0).clear():this.output(0).data=i}}class ht extends s{static kind="mathMin";static inputs=s.in(["array"]);static outputs=s.out(["number"]);run(){const t=this.input(0).data,i=Math.min(...t);isNaN(i)?this.output(0).clear():this.output(0).data=i}}class lt extends s{static kind="mathPI";static isConstant=!0;static outputs=s.out(["number"],{name:"\u03C0",data:Math.PI})}class ft extends s{static kind="mathRound";static inputs=s.in(["number"]);static outputs=s.out(["number"]);run(){this.output(0).data=Math.round(this.input(0).data)}}class yt extends s{static kind="mathSin";static inputs=s.in(["number"]);static outputs=s.out(["number"]);run(){this.output(0).data=Math.sin(this.input(0).data)}}class mt extends s{static kind="mathSinh";static inputs=s.in(["number"]);static outputs=s.out(["number"]);run(){this.output(0).data=Math.sinh(this.input(0).data)}}const Zt={[ot.kind]:ot,[rt.kind]:rt,[dt.kind]:dt,[ct.kind]:ct,[pt.kind]:pt,[ht.kind]:ht,[lt.kind]:lt,[ft.kind]:ft,[yt.kind]:yt,[mt.kind]:mt};class gt extends s{static kind="isFinite";static inputs=s.in(["number"]);static outputs=s.out(["boolean"]);run(){this.output(0).data=Number.isFinite(this.input(0).data)}}class wt extends s{static kind="isInteger";static inputs=s.in([]);static outputs=s.out(["boolean"]);run(){this.output(0).data=Number.isInteger(this.input(0).data)}}class bt extends s{static kind="isNaN";static inputs=s.in([]);static outputs=s.out(["boolean"]);run(){this.output(0).data=Number.isNaN(this.input(0).data)}}class kt extends s{static kind="parseFloat";static inputs=s.in(["string"]);static outputs=s.out(["number"]);run(){this.output(0).data=parseFloat(this.input(0).data)}}class It extends s{static kind="parseInt";static inputs=s.in(["number","string"]);static outputs=s.out(["number"]);run(){this.output(0).data=parseInt(this.input(0).data)}}const _t={[gt.kind]:gt,[wt.kind]:wt,[bt.kind]:bt,[kt.kind]:kt,[It.kind]:It};class Dt extends s{static kind="objectKeys";static inputs=s.in(["object"]);static outputs=s.out(["array"]);run(){this.output(0).data=Object.keys(this.input(0).data)}}class xt extends s{static kind="objectValues";static inputs=s.in(["object"]);static outputs=s.out(["array"]);run(){this.output(0).data=Object.values(this.input(0).data)}}const ts={[Dt.kind]:Dt,[xt.kind]:xt};class Tt extends s{static kind="addition";static inputs=s.ins(2,["number"]);static outputs=s.out(["number"]);run(){this.output(0).data=this.input(0).data+this.input(1).data}}class At extends s{static kind="division";static inputs=s.ins(2,["number"]);static outputs=s.out(["number"]);run(){this.input(1).data?this.output(0).data=this.input(0).data/this.input(1).data:this.output(0).clear()}}class Nt extends s{static kind="equality";static inputs=s.ins(2);static outputs=s.out(["boolean"]);run(){this.output(0).data=this.input(0).data==this.input(1).data}}class Ot extends s{static kind="lessThan";static inputs=s.ins(2,["number"]);static outputs=s.out(["boolean"]);run(){this.output(0).data=this.input(0).data<this.input(1).data}}class Et extends s{static kind="lessThanOrEqual";static inputs=s.ins(2,["number"]);static outputs=s.out(["boolean"]);run(){this.output(0).data=this.input(0).data<=this.input(1).data}}class jt extends s{static kind="greaterThan";static inputs=s.ins(2,["number"]);static outputs=s.out(["boolean"]);run(){this.output(0).data=this.input(0).data>this.input(1).data}}class St extends s{static kind="greaterThanOrEqual";static inputs=s.ins(2,["number"]);static outputs=s.out(["boolean"]);run(){this.output(0).data=this.input(0).data>=this.input(1).data}}class Mt extends s{static kind="inequality";static inputs=s.ins(2);static outputs=s.out(["boolean"]);run(){this.output(0).data=this.input(0).data!=this.input(1).data}}class vt extends s{static kind="multiplication";static inputs=s.ins(2,["number"]);static outputs=s.out(["number"]);run(){this.output(0).data=this.input(0).data*this.input(1).data}}class Pt extends s{static kind="subtraction";static inputs=s.ins(2,["number"]);static outputs=s.out(["number"]);run(){this.output(0).data=this.input(0).data-this.input(1).data}}const ss={[Tt.kind]:Tt,[At.kind]:At,[Nt.kind]:Nt,[jt.kind]:jt,[St.kind]:St,[Ot.kind]:Ot,[Et.kind]:Et,[Mt.kind]:Mt,[vt.kind]:vt,[Pt.kind]:Pt};class Ct extends s{static kind="stringLength";static inputs=s.in(["string"]);static outputs=s.out(["number"]);run(){this.output(0).data=this.input(0).data.length}}class $t extends s{static kind="substring";static inputs=[...s.in(["string"]),...s.in(["number"],{name:"start"}),...s.in(["number"],{name:"end",optional:!0})];static outputs=s.out(["string"]);run(){const t=this.input(0).data,i=this.input(1).data,e=this.input(2).data;this.output(0).data=t.substring(i,e)}}const is={[Ct.kind]:Ct,[$t.kind]:$t},Bt={...Kt,...Vt,...Ht,...Wt,...Qt,...Xt,...Yt,...Zt,..._t,...ts,...ss,...is};module.exports=zt(ns);
