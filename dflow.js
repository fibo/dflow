var Ns=Object.defineProperty,Os=Object.defineProperties;var Ts=Object.getOwnPropertyDescriptors;var _t=Object.getOwnPropertySymbols;var ps=Object.prototype.hasOwnProperty,hs=Object.prototype.propertyIsEnumerable;var us=(e,t,s)=>t in e?Ns(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,l=(e,t)=>{for(var s in t||(t={}))ps.call(t,s)&&us(e,s,t[s]);if(_t)for(var s of _t(t))hs.call(t,s)&&us(e,s,t[s]);return e},I=(e,t)=>Os(e,Ts(t));var E=(e,t)=>{var s={};for(var a in e)ps.call(e,a)&&t.indexOf(a)<0&&(s[a]=e[a]);if(e!=null&&_t)for(var a of _t(e))t.indexOf(a)<0&&hs.call(e,a)&&(s[a]=e[a]);return s};var n=(e,t,s)=>(us(e,typeof t!="symbol"?t+"":t,s),s),rs=(e,t,s)=>{if(!t.has(e))throw TypeError("Cannot "+s)};var u=(e,t,s)=>(rs(e,t,"read from private field"),s?s.call(e):t.get(e)),m=(e,t,s)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,s)},x=(e,t,s,a)=>(rs(e,t,"write to private field"),a?a.call(e,s):t.set(e,s),s);var J=(e,t,s)=>(rs(e,t,"access private method"),s);var w,Zt,j,v,P,G,R,qt,Mt,ks,Lt,fs,f,b,p,z;const N=e=>`${e} must be a string`,ls=e=>`${e} must be a number`,ys=(e,t)=>`${t} pin not found nodeId=${e}`,gs=(e,t,s)=>`${ys(e,t)} position=${s}`,ms=(e,t,s)=>`${ys(e,t)} pinId=${s}`,os=({id:e,kind:t,outputs:s})=>({id:e,kind:t,outputs:s==null?void 0:s.map(({id:a,data:r,name:d})=>({id:a,data:r,name:d}))});class o{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowGraph(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&Array.isArray(t.nodes)&&Array.isArray(t.edges)&&S.isDflowGraph(t)}static isDflowId(t){return o.isStringNotEmpty(t)}static isDflowType(t){return typeof t=="string"&&C.types.includes(t)}static isObject(t){return!o.isUndefined(t)&&!o.isNull(t)&&!o.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return o.isString(t)&&t.length>0}static isUndefined(t){return typeof t>"u"}static validate(t,s){return s.length===0?!0:s.some(a=>{switch(a){case"array":return o.isArray(t);case"boolean":return o.isBoolean(t);case"null":return o.isNull(t);case"number":return o.isNumber(t);case"object":return o.isObject(t);case"string":return o.isString(t);case"DflowGraph":return o.isDflowGraph(t);case"DflowId":return o.isDflowId(t);case"DflowType":return o.isDflowType(t);default:return!1}},!0)}}class ${constructor({id:t,name:s}){n(this,"id");n(this,"name");this.id=t,this.name=s}static isDflowItem({id:t,name:s}){return o.isDflowId(t)&&(o.isUndefined(s)||o.isStringNotEmpty(s))}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const es=class extends ${constructor(t,r){var d=r,{types:s=[]}=d,a=E(d,["types"]);super(a);n(this,"kind");n(this,"types");this.kind=t,this.types=s}static isDflowPin(a){var r=a,{types:t=[]}=r,s=E(r,["types"]);return $.isDflowItem(s)&&t.every(d=>es.isDflowPinType(d))}static isDflowPinType(t){es.types.includes(t)}get hasTypeAny(){return this.types.length===0}get hasTypeDflowId(){return this.hasTypeAny||this.types.includes("DflowId")}get hasTypeDflowGraph(){return this.hasTypeAny||this.types.includes("DflowGraph")}get hasTypeDflowType(){return this.hasTypeAny||this.types.includes("DflowType")}get hasTypeString(){return this.hasTypeAny||this.types.includes("string")}get hasTypeNumber(){return this.hasTypeAny||this.types.includes("number")}get hasTypeBoolean(){return this.hasTypeAny||this.types.includes("boolean")}get hasTypeNull(){return this.hasTypeAny||this.types.includes("null")}get hasTypeObject(){return this.hasTypeAny||this.types.includes("object")}get hasTypeArray(){return this.hasTypeAny||this.types.includes("array")}addType(t){this.types.push(t)}removeType(t){this.types.splice(this.types.indexOf(t),1)}};let C=es;n(C,"types",["string","number","boolean","null","object","array","DflowId","DflowGraph","DflowType"]);class Dt extends C{constructor(a){var r=a,{optional:t}=r,s=E(r,["optional"]);super("input",s);m(this,w,void 0);m(this,Zt,void 0);x(this,Zt,t)}static isDflowInput({id:t,types:s}){return C.isDflowPin({id:t,types:s})}get data(){var t;return(t=u(this,w))==null?void 0:t.data}get isConnected(){return typeof u(this,w)>"u"}get isOptional(){return u(this,Zt)}connectTo(t){const{hasTypeAny:s,types:a}=this,{types:r}=t;if(s||a.some(d=>r.includes(d)))x(this,w,t);else throw new Error(`mismatching pinTypes, source has types [${r.join()}] and target has types [${a.join()}]`)}disconnect(){x(this,w,void 0)}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}w=new WeakMap,Zt=new WeakMap;class ts extends C{constructor(a){var r=a,{data:t}=r,s=E(r,["data"]);super("output",s);m(this,j,void 0);x(this,j,t)}static isDflowOutput({id:t,data:s,types:a=[]}){return C.isDflowPin({id:t,types:a})&&o.validate(s,a)}clear(){x(this,j,void 0)}get data(){return u(this,j)}set data(t){switch(!0){case o.isUndefined(t):this.clear();break;case this.hasTypeAny:case(o.isDflowGraph(t)&&this.hasTypeDflowGraph):case(o.isDflowId(t)&&this.hasTypeDflowId):case(o.isString(t)&&this.hasTypeString):case(o.isNumber(t)&&this.hasTypeNumber):case(o.isBoolean(t)&&this.hasTypeBoolean):case(o.isNull(t)&&this.hasTypeNull):case(o.isObject(t)&&this.hasTypeObject):case(o.isArray(t)&&this.hasTypeArray):{x(this,j,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=l({},super.toObject());return o.isUndefined(u(this,j))||(t.data=u(this,j)),this.types.length>0&&(t.types=this.types),t}}j=new WeakMap;const as=class extends ${constructor(g,d,{isAsync:h=!1,isConstant:c=!1,label:y}={}){var O=g,{kind:t,inputs:s=[],outputs:a=[]}=O,r=E(O,["kind","inputs","outputs"]);super(r);m(this,Mt);m(this,Lt);m(this,v,new Map);m(this,P,new Map);m(this,G,[]);m(this,R,[]);m(this,qt,void 0);n(this,"kind");n(this,"meta");n(this,"host");x(this,qt,y),this.host=d,this.kind=t,this.meta={isAsync:h,isConstant:c};for(const T of s)this.newInput(T);for(const T of a)this.newOutput(T);this.onCreate()}static generateInputIds(t=[]){return t.map((s,a)=>I(l({},s),{id:`i${a}`}))}static generateOutputIds(t=[]){return t.map((s,a)=>I(l({},s),{id:`o${a}`}))}static in(t=[],s){return[l({types:t},s)]}static ins(t,s=[]){return Array(t).fill(as.in(s)).flat()}static out(t=[],s){return[l({types:t},s)]}static outs(t,s=[]){return Array(t).fill(as.out(s)).flat()}static outputNumber(t){return I(l({},t),{types:["number"]})}static isDflowNode(d){var h=d,{kind:t,inputs:s=[],outputs:a=[]}=h,r=E(h,["kind","inputs","outputs"]);return $.isDflowItem(r)&&o.isStringNotEmpty(t)&&s.every(c=>Dt.isDflowInput(c))&&a.every(c=>ts.isDflowOutput(c))}get label(){return u(this,qt)||this.kind}get inputs(){return u(this,v).values()}get outputs(){return u(this,P).values()}get numInputs(){return u(this,v).size}get numOutputs(){return u(this,P).size}clearOutputs(){for(const t of this.outputs)t.clear()}getInputById(t){if(typeof t!="string")throw new TypeError(N("inputId"));const s=u(this,v).get(t);if(s instanceof Dt)return s;throw new Error(ms(this.id,"input",t))}input(t){if(typeof t!="number")throw new TypeError(ls("position"));const s=u(this,G)[t];if(o.isUndefined(s))throw new Error(gs(this.id,"input",t));return this.getInputById(s)}getOutputById(t){if(typeof t!="string")throw new TypeError(N("outputId"));const s=u(this,P).get(t);if(s instanceof ts)return s;throw new Error(ms(this.id,"output",t))}output(t){if(typeof t!="number")throw new TypeError(ls("position"));const s=u(this,R)[t];if(o.isUndefined(s))throw new Error(gs(this.id,"output",t));return this.getOutputById(s)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),u(this,v).delete(t),u(this,G).splice(u(this,G).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),u(this,P).delete(t),u(this,R).splice(u(this,R).indexOf(t),1)}onBeforeConnectInput(t,s){}onCreate(){}newInput(t){const s=o.isDflowId(t.id)?t.id:J(this,Mt,ks).call(this),a=new Dt(I(l({},t),{id:s}));return u(this,v).set(s,a),u(this,G).push(s),a}newOutput(t){const s=o.isDflowId(t.id)?t.id:J(this,Lt,fs).call(this),a=new ts(I(l({},t),{id:s}));return u(this,P).set(s,a),u(this,R).push(s),a}run(){}toObject(){const t=I(l({},super.toObject()),{kind:this.kind}),s=[],a=[];for(const r of this.inputs)s.push(r.toObject());s.length>0&&(t.inputs=s);for(const r of this.outputs)a.push(r.toObject());return a.length>0&&(t.outputs=a),t}};let i=as;v=new WeakMap,P=new WeakMap,G=new WeakMap,R=new WeakMap,qt=new WeakMap,Mt=new WeakSet,ks=function(t=this.numInputs){const s=`i${t}`;return u(this,v).has(s)?J(this,Mt,ks).call(this,t+1):s},Lt=new WeakSet,fs=function(t=this.numOutputs){const s=`o${t}`;return u(this,P).has(s)?J(this,Lt,fs).call(this,t+1):s},n(i,"kind"),n(i,"isAsync"),n(i,"isConstant"),n(i,"label"),n(i,"inputs"),n(i,"outputs");const ds=class extends i{constructor(t,s){super(I(l({},t),{kind:ds.kind}),s)}run(){}};let ss=ds;n(ss,"kind","Unknown");class K extends ${constructor(r){var d=r,{source:t,target:s}=d,a=E(d,["source","target"]);super(a);n(this,"source");n(this,"target");const[h,c]=t,[y,g]=s;if(typeof h!="string")throw new TypeError(N("sourceNodeId"));if(typeof c!="string")throw new TypeError(N("sourcePinId"));if(typeof y!="string")throw new TypeError(N("targetNodeId"));if(typeof g!="string")throw new TypeError(N("targetPinId"));this.source=t,this.target=s}static isDflowEdge(d,r){var h=d,{source:t,target:s}=h,a=E(h,["source","target"]);return $.isDflowItem(a)&&Array.isArray(t)&&t.length===2&&r.nodes.find(({id:c,outputs:y=[]})=>c===t[0]&&y.find(({id:g})=>g===t[1]))&&Array.isArray(s)&&s.length===2&&r.nodes.find(({id:c,inputs:y=[]})=>c===s[0]&&y.find(({id:g})=>g===s[1]))}toObject(){return I(l({},super.toObject()),{source:this.source,target:this.target})}}const B=class extends ${constructor(){super(...arguments);m(this,f,new Map);m(this,b,new Map);n(this,"runOptions",{verbose:!1});n(this,"runStatus",null);n(this,"executionReport",null)}static isDflowGraph(t){return t.nodes.every(s=>i.isDflowNode(s))&&t.edges.every(s=>K.isDflowEdge(s,t))}static childrenOfNodeId(t,s){return s.filter(({sourceId:a})=>t===a).map(({targetId:a})=>a)}static parentsOfNodeId(t,s){return s.filter(({targetId:a})=>t===a).map(({sourceId:a})=>a)}static levelOfNodeId(t,s){const a=B.parentsOfNodeId(t,s);if(a.length===0)return 0;let r=0;for(const d of a){const h=B.levelOfNodeId(d,s);r=Math.max(h,r)}return r+1}static ancestorsOfNodeId(t,s){const a=B.parentsOfNodeId(t,s);return a.length===0?[]:a.reduce((r,d,h,c)=>{const y=B.ancestorsOfNodeId(d,s),g=r.concat(y);return h===c.length-1?Array.from(new Set(c.concat(g))):g},[])}static sort(t,s){const a={};for(const r of t)a[r]=B.levelOfNodeId(r,s);return t.slice().sort((r,d)=>a[r]<=a[d]?-1:1)}get edges(){return u(this,b).values()}get nodes(){return u(this,f).values()}get nodeConnections(){return[...u(this,b).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...u(this,b).keys()]}get nodeIds(){return[...u(this,f).keys()]}get numEdges(){return u(this,b).size}get numNodes(){return u(this,f).size}addEdge(t){if(u(this,b).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);u(this,b).set(t.id,t)}addNode(t){if(u(this,f).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);u(this,f).set(t.id,t)}clear(){u(this,f).clear(),u(this,b).clear()}deleteEdge(t){u(this,b).delete(t)}deleteNode(t){u(this,f).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(N("nodeId"));const s=u(this,f).get(t);if(s instanceof i)return s;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(N("edgeId"));const s=u(this,b).get(t);if(s instanceof K)return s;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const s=`e${t}`;return u(this,b).has(s)?this.generateEdgeId(t+1):s}generateNodeId(t=this.numNodes){const s=`n${t}`;return u(this,f).has(s)?this.generateNodeId(t+1):s}nodeIdsInsideFunctions(){const t=[];for(const s of this.nodes)s.kind==="return"&&t.push(B.ancestorsOfNodeId(s.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){var r,d;const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const s=this.nodeIdsInsideFunctions(),a=B.sort(this.nodeIds.filter(h=>!s.includes(h)),this.nodeConnections);s:for(const h of a){const c=u(this,f).get(h);try{if(!c.meta.isConstant){let y=!1;t:for(const{data:g,types:O,isOptional:T}of c.inputs){if(T&&typeof g>"u")continue t;if(!o.validate(g,O)){y=!0;break t}}if(y){for(const g of c.outputs)g.clear();t&&((r=this.executionReport.steps)==null||r.push(os(c.toObject())));continue s}c.meta.isAsync?await c.run():c.run()}t&&((d=this.executionReport.steps)==null||d.push(os(c.toObject())))}catch(y){console.error(y),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=I(l({},super.toObject()),{nodes:[],edges:[]});for(const s of this.nodes)t.nodes.push(s.toObject());for(const s of this.edges)t.edges.push(s.toObject());return t}};let S=B;f=new WeakMap,b=new WeakMap;class Es{constructor(t={}){m(this,p,void 0);m(this,z,void 0);n(this,"context");x(this,z,t),x(this,p,new S({id:"g1"})),this.context={}}get executionReport(){return u(this,p).executionReport}get edges(){return u(this,p).edges}get nodes(){return u(this,p).nodes}get numEdges(){return u(this,p).numEdges}get numNodes(){return u(this,p).numNodes}get nodeKinds(){return Object.keys(u(this,z))}get runStatusIsSuccess(){return u(this,p).runStatus==="success"}get runStatusIsWaiting(){return u(this,p).runStatus==="waiting"}get runStatusIsFailure(){return u(this,p).runStatus==="failure"}set verbose(t){u(this,p).runOptions.verbose=t}clearGraph(){u(this,p).clear()}connect(t,s=0){return{to:(a,r=0)=>{const d=u(this,p).generateEdgeId(),h=t.output(s),c=a.input(r);a.onBeforeConnectInput(t,s),this.newEdge({id:d,source:[t.id,h.id],target:[a.id,c.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(N("edgeId"));const s=u(this,p).getEdgeById(t);if(s instanceof K){const[a,r]=s.target;this.getNodeById(a).getInputById(r).disconnect(),u(this,p).deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(N("nodeId"));const s=this.getNodeById(t);if(s instanceof i){for(const a of u(this,p).edges){const{source:[r],target:[d]}=a;(r===s.id||d===s.id)&&this.deleteEdge(a.id)}u(this,p).deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,s]){for(const a of this.edges){const[r,d]=a.source,[h,c]=a.target;(r===t&&d===s||h===t&&c===s)&&this.deleteEdge(a.id)}}executeFunction(t,s){var g,O,T;const{verbose:a}=u(this,p).runOptions,r=u(this,p).nodeConnections,d=S.childrenOfNodeId(t,r),h=[];for(const F of d){const k=this.getNodeById(F);k.kind==="return"&&h.push(k.id)}const c=h.reduce((F,k,H,Is)=>{const xs=S.ancestorsOfNodeId(k,r),cs=F.concat(xs);return H===Is.length?Array.from(new Set(cs)):cs},[]),y=S.sort([...h,...c],r);for(const F of y){const k=this.getNodeById(F);try{switch(k.kind){case"argument":{const H=Math.max((g=k.input(1).data)!=null?g:0,0);k.output(0).data=s[H];break}case"return":return k.input(1).data;default:!k.meta.isConstant&&!k.meta.isAsync&&k.run(),a&&((T=(O=this.executionReport)==null?void 0:O.steps)==null||T.push(os(k.toObject())))}}catch(H){console.error(H)}}}getEdgeById(t){return u(this,p).getEdgeById(t)}getNodeById(t){return u(this,p).getNodeById(t)}newNode(t){var y;const s=(y=u(this,z)[t.kind])!=null?y:ss,a=o.isDflowId(t.id)?t.id:u(this,p).generateNodeId(),r={isAsync:s.isAsync,isConstant:s.isConstant,label:s.label},d=Array.isArray(t.inputs)?t.inputs:i.generateInputIds(s.inputs),h=Array.isArray(t.outputs)?t.outputs:i.generateOutputIds(s.outputs),c=new s(I(l({},t),{id:a,inputs:d,outputs:h}),this,r);return u(this,p).addNode(c),c}newEdge(t){const s=o.isDflowId(t.id)?t.id:u(this,p).generateEdgeId(),a=new K(I(l({},t),{id:s}));u(this,p).addEdge(a);const[r,d]=a.source,[h,c]=a.target,y=u(this,p).getNodeById(r),g=u(this,p).getNodeById(h),O=y.getOutputById(d);return g.getInputById(c).connectTo(O),a}newInput(t,s){return u(this,p).getNodeById(t).newInput(s)}newOutput(t,s){return u(this,p).getNodeById(t).newOutput(s)}toObject(){return u(this,p).toObject()}async run(){await u(this,p).run()}}p=new WeakMap,z=new WeakMap;export{o as DflowData};export{$ as DflowItem};export{C as DflowPin};export{Dt as DflowInput};export{ts as DflowOutput};export{i as DflowNode};export{ss as DflowUnknownNode};export{K as DflowEdge};export{S as DflowGraph};export{Es as DflowHost};class W extends i{run(){const t=this.input(0).data,s=this.input(1).data;this.output(0).data=t.at(s)}}n(W,"kind","arrayAt"),n(W,"inputs",[...i.in(["array"]),...i.in(["number"],{name:"index"})]),n(W,"outputs",i.out());class Q extends i{run(){this.output(0).data=this.input(0).data.filter((...t)=>this.host.executeFunction(this.input(1).data,t))}}n(Q,"kind","arrayFilter"),n(Q,"inputs",[...i.in(["array"]),...i.in(["DflowId"],{name:"functionId"})]),n(Q,"outputs",i.out(["array"]));class V extends i{run(){this.output(0).data=this.input(0).data.findLastIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}n(V,"kind","arrayFindLastIndex"),n(V,"inputs",[...i.in(["array"]),...i.in(["DflowId"],{name:"functionId"})]),n(V,"outputs",i.out(["number"]));class X extends i{run(){this.output(0).data=this.input(0).data.findIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}n(X,"kind","arrayFindIndex"),n(X,"inputs",[...i.in(["array"]),...i.in(["DflowId"],{name:"functionId"})]),n(X,"outputs",i.out(["number"]));class Y extends i{run(){const t=this.input(0).data,s=this.input(1).data;Array.isArray(t)&&(this.output(0).data=t.includes(s))}}n(Y,"kind","arrayIncludes"),n(Y,"inputs",[...i.in(["array"],{name:"array"}),...i.in(["string"],{name:"element"})]),n(Y,"outputs",i.out(["boolean"]));class Z extends i{run(){var a;const t=this.input(0).data,s=(a=this.input(1).data)!=null?a:",";Array.isArray(t)&&(this.output(0).data=t.join(s))}}n(Z,"kind","arrayJoin"),n(Z,"inputs",[...i.in(["array"],{name:"array"}),...i.in(["string"],{name:"separator",optional:!0})]),n(Z,"outputs",i.out(["string"]));class q extends i{run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t.length:this.output(0).clear}}n(q,"kind","arrayLength"),n(q,"inputs",i.in(["array"])),n(q,"outputs",i.out(["number"]));class M extends i{run(){this.output(0).data=this.input(0).data.map((...t)=>this.host.executeFunction(this.input(1).data,t))}}n(M,"kind","arrayMap"),n(M,"inputs",[...i.in(["array"]),...i.in(["DflowId"],{name:"functionId"})]),n(M,"outputs",i.out(["array"]));class L extends i{run(){const t=this.input(0).data.slice(),s=t.pop();this.output(0).data=s,this.output(1).data=t}}n(L,"kind","arrayPop"),n(L,"inputs",i.in(["array"])),n(L,"outputs",[...i.out([],{name:"element"}),...i.out(["array"],{name:"rest"})]);class _ extends i{run(){const t=this.input(0).data.slice(),s=this.input(1).data;s&&t.push(s),this.output(0).data=t}}n(_,"kind","arrayPush"),n(_,"inputs",[...i.in(["array"]),...i.in([],{name:"element"})]),n(_,"outputs",i.out(["array"]));class D extends i{run(){const t=this.input(0).data.slice();this.output(0).data=t.reverse()}}n(D,"kind","arrayReverse"),n(D,"inputs",i.in(["array"])),n(D,"outputs",i.in(["array"]));class tt extends i{run(){const t=this.input(0).data.slice(),s=t.shift();this.output(0).data=s,this.output(1).data=t}}n(tt,"kind","arrayShift"),n(tt,"inputs",i.in(["array"])),n(tt,"outputs",[...i.out([],{name:"element"}),...i.out(["array"],{name:"rest"})]);class st extends i{run(){const t=this.input(0).data,s=this.input(1).data,a=this.input(2).data;typeof a=="number"?this.output(0).data=t.slice(s,a):this.output(0).data=t.slice(s)}}n(st,"kind","arraySlice"),n(st,"inputs",[...i.in(["array"]),...i.in(["number"],{name:"start"}),...i.in(["number"],{name:"end",optional:!0})]),n(st,"outputs",i.out(["array"]));const Bs={[W.kind]:W,[Q.kind]:Q,[V.kind]:V,[X.kind]:X,[Y.kind]:Y,[Z.kind]:Z,[q.kind]:q,[M.kind]:M,[L.kind]:L,[_.kind]:_,[D.kind]:D,[tt.kind]:tt,[st.kind]:st};class nt extends i{run(){this.output(0).data=this.input(0).data?this.input(1).data:this.input(2).data}}n(nt,"kind","if"),n(nt,"inputs",[...i.in(["boolean"],{name:"condition"}),...i.in([],{name:"then"}),...i.in([],{name:"else"})]),n(nt,"outputs",i.out());const js={[nt.kind]:nt};class ns extends i{run(){console.log(this.input(0).data)}}n(ns,"kind","consoleLog"),n(ns,"inputs",[...i.in([])]);const vs={[ns.kind]:ns},bs=[...i.out(["string"]),...i.out(["number"],{name:"milliseconds"})];class it extends i{run(){const t=this.input(0).data;if(typeof t=="string"||typeof t=="number"){const a=new Date(t),r=a.toJSON();r!==null&&(this.output(0).data=r,this.output(1).data=a.getTime())}const s=new Date;this.output(0).data=s.toJSON(),this.output(1).data=s.getTime()}}n(it,"kind","newDate"),n(it,"inputs",i.in(["string","number"],{optional:!0})),n(it,"outputs",bs);class is extends i{run(){const t=Date.now();this.output(0).data=new Date(t).toJSON(),this.output(1).data=t}}n(is,"kind","now"),n(is,"outputs",bs);const Ps={[it.kind]:it,[is.kind]:is};class et extends i{}n(et,"kind","data"),n(et,"isConstant",!0),n(et,"outputs",i.out());class at extends i{run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t:this.output(0).clear()}}n(at,"kind","array"),n(at,"inputs",i.in()),n(at,"outputs",i.out(["array"]));class ut extends i{run(){const t=this.input(0).data;typeof t=="boolean"?this.output(0).data=t:this.output(0).clear()}}n(ut,"kind","boolean"),n(ut,"inputs",i.in()),n(ut,"outputs",i.out(["boolean"]));class rt extends i{run(){const t=this.input(0).data;typeof t=="number"?this.output(0).data=t:this.output(0).clear()}}n(rt,"kind","number"),n(rt,"inputs",i.in()),n(rt,"outputs",i.out(["number"]));class ot extends i{run(){const t=this.input(0).data;typeof t=="object"&&t!==null?this.output(0).data=t:this.output(0).clear()}}n(ot,"kind","object"),n(ot,"inputs",i.in()),n(ot,"outputs",i.out(["object"]));class dt extends i{run(){const t=this.input(0).data;typeof t=="string"?this.output(0).data=t:this.output(0).clear()}}n(dt,"kind","string"),n(dt,"inputs",i.in()),n(dt,"outputs",i.out(["string"]));class ct extends i{run(){const t=this.input(0).data;this.output(0).data=Array.isArray(t)}}n(ct,"kind","isArray"),n(ct,"inputs",i.out()),n(ct,"outputs",i.out(["boolean"]));class pt extends i{run(){const t=this.input(0).data;this.output(0).data=typeof t<"u"}}n(pt,"kind","isDefined"),n(pt,"inputs",i.in()),n(pt,"outputs",i.out(["boolean"]));class ht extends i{run(){const t=this.input(0).data;this.output(0).data=typeof t>"u"}}n(ht,"kind","isUndefined"),n(ht,"inputs",i.in()),n(ht,"outputs",i.out(["boolean"]));const $s={[et.kind]:et,[pt.kind]:pt,[ht.kind]:ht,[at.kind]:at,[ut.kind]:ut,[rt.kind]:rt,[ot.kind]:ot,[dt.kind]:dt,[ct.kind]:ct};class A extends i{run(){const t=this.output(0);t.data=this.host.nodeKinds}}n(A,"kind","dflow"),n(A,"outputs",i.out(["array"],{name:"nodeKinds"}));class lt extends i{}n(lt,"kind","comment"),n(lt,"isConstant",!0),n(lt,"outputs",i.out(["string"]));class yt extends i{}n(yt,"kind","typeNumber"),n(yt,"isConstant",!0),n(yt,"outputs",i.out(["DflowType"],{name:"number",data:"number"}));class U extends i{onBeforeConnectInput(t,s){const a=t.output(s).data;this.output(0).addType(a)}}n(U,"kind","argument"),n(U,"isConstant",!0),n(U,"inputs",[...i.in(["DflowType"],{name:"type"}),...i.in(["number"],{name:"argumentPosition"})]),n(U,"outputs",i.out());class gt extends i{onCreate(){this.output(0).data=this.id}}n(gt,"kind","function"),n(gt,"isConstant",!0),n(gt,"outputs",A.out(["DflowId"],{name:"id"}));class mt extends i{}n(mt,"kind","return"),n(mt,"isConstant",!0),n(mt,"inputs",[...A.in(["DflowId"],{name:"functionId"}),...A.in([],{name:"value"})]);const Cs={[A.kind]:A,[U.kind]:U,[lt.kind]:lt,[gt.kind]:gt,[mt.kind]:mt,[yt.kind]:yt};class kt extends i{run(){this.output(0).data=this.input(0).data&&this.input(1).data}}n(kt,"kind","and"),n(kt,"inputs",i.ins(2,["boolean"])),n(kt,"outputs",i.out(["boolean"]));class ft extends i{run(){this.output(0).data=!this.input(0).data}}n(ft,"kind","not"),n(ft,"inputs",i.in(["boolean"])),n(ft,"outputs",i.out(["boolean"]));class bt extends i{run(){this.output(0).data=this.input(0).data||this.input(1).data}}n(bt,"kind","or"),n(bt,"inputs",i.ins(2,["boolean"])),n(bt,"outputs",i.out(["boolean"]));const Ss={[kt.kind]:kt,[ft.kind]:ft,[bt.kind]:bt};class It extends i{run(){this.output(0).data=Math.abs(this.input(0).data)}}n(It,"kind","mathAbs"),n(It,"inputs",i.in(["number"])),n(It,"outputs",i.out(["number"]));class xt extends i{run(){this.output(0).data=Math.cos(this.input(0).data)}}n(xt,"kind","mathCos"),n(xt,"inputs",i.in(["number"])),n(xt,"outputs",i.out(["number"]));class Nt extends i{run(){this.output(0).data=Math.cosh(this.input(0).data)}}n(Nt,"kind","mathCosh"),n(Nt,"inputs",i.in(["number"])),n(Nt,"outputs",i.out(["number"]));class Ot extends i{run(){this.output(0).data=Math.floor(this.input(0).data)}}n(Ot,"kind","mathFloor"),n(Ot,"inputs",i.in(["number"])),n(Ot,"outputs",i.out(["number"]));class Tt extends i{run(){const t=this.input(0).data,s=Math.max(...t);isNaN(s)?this.output(0).clear():this.output(0).data=s}}n(Tt,"kind","mathMax"),n(Tt,"inputs",i.in(["array"])),n(Tt,"outputs",i.out(["number"]));class Et extends i{run(){const t=this.input(0).data,s=Math.min(...t);isNaN(s)?this.output(0).clear():this.output(0).data=s}}n(Et,"kind","mathMin"),n(Et,"inputs",i.in(["array"])),n(Et,"outputs",i.out(["number"]));class Bt extends i{}n(Bt,"kind","mathPI"),n(Bt,"isConstant",!0),n(Bt,"outputs",i.out(["number"],{name:"\u03C0",data:Math.PI}));class jt extends i{run(){this.output(0).data=Math.round(this.input(0).data)}}n(jt,"kind","mathRound"),n(jt,"inputs",i.in(["number"])),n(jt,"outputs",i.out(["number"]));class vt extends i{run(){this.output(0).data=Math.sin(this.input(0).data)}}n(vt,"kind","mathSin"),n(vt,"inputs",i.in(["number"])),n(vt,"outputs",i.out(["number"]));class Pt extends i{run(){this.output(0).data=Math.sinh(this.input(0).data)}}n(Pt,"kind","mathSinh"),n(Pt,"inputs",i.in(["number"])),n(Pt,"outputs",i.out(["number"]));const As={[It.kind]:It,[xt.kind]:xt,[Nt.kind]:Nt,[Ot.kind]:Ot,[Tt.kind]:Tt,[Et.kind]:Et,[Bt.kind]:Bt,[jt.kind]:jt,[vt.kind]:vt,[Pt.kind]:Pt};class $t extends i{run(){this.output(0).data=Number.isFinite(this.input(0).data)}}n($t,"kind","isFinite"),n($t,"inputs",i.in(["number"])),n($t,"outputs",i.out(["boolean"]));class Ct extends i{run(){this.output(0).data=Number.isInteger(this.input(0).data)}}n(Ct,"kind","isInteger"),n(Ct,"inputs",i.in([])),n(Ct,"outputs",i.out(["boolean"]));class St extends i{run(){this.output(0).data=Number.isNaN(this.input(0).data)}}n(St,"kind","isNaN"),n(St,"inputs",i.in([])),n(St,"outputs",i.out(["boolean"]));class At extends i{run(){this.output(0).data=parseFloat(this.input(0).data)}}n(At,"kind","parseFloat"),n(At,"inputs",i.in(["string"])),n(At,"outputs",i.out(["number"]));class wt extends i{run(){this.output(0).data=parseInt(this.input(0).data)}}n(wt,"kind","parseInt"),n(wt,"inputs",i.in(["number","string"])),n(wt,"outputs",i.out(["number"]));const ws={[$t.kind]:$t,[Ct.kind]:Ct,[St.kind]:St,[At.kind]:At,[wt.kind]:wt};class Gt extends i{run(){this.output(0).data=Object.keys(this.input(0).data)}}n(Gt,"kind","objectKeys"),n(Gt,"inputs",i.in(["object"])),n(Gt,"outputs",i.out(["array"]));class Rt extends i{run(){this.output(0).data=Object.values(this.input(0).data)}}n(Rt,"kind","objectValues"),n(Rt,"inputs",i.in(["object"])),n(Rt,"outputs",i.out(["array"]));const Gs={[Gt.kind]:Gt,[Rt.kind]:Rt};class Ut extends i{run(){this.output(0).data=this.input(0).data+this.input(1).data}}n(Ut,"kind","addition"),n(Ut,"inputs",i.ins(2,["number"])),n(Ut,"outputs",i.out(["number"]));class zt extends i{run(){this.input(1).data?this.output(0).data=this.input(0).data/this.input(1).data:this.output(0).clear()}}n(zt,"kind","division"),n(zt,"inputs",i.ins(2,["number"])),n(zt,"outputs",i.out(["number"]));class Ft extends i{run(){this.output(0).data=this.input(0).data==this.input(1).data}}n(Ft,"kind","equality"),n(Ft,"inputs",i.ins(2)),n(Ft,"outputs",i.out(["boolean"]));class Ht extends i{run(){this.output(0).data=this.input(0).data<this.input(1).data}}n(Ht,"kind","lessThan"),n(Ht,"inputs",i.ins(2,["number"])),n(Ht,"outputs",i.out(["boolean"]));class Jt extends i{run(){this.output(0).data=this.input(0).data<=this.input(1).data}}n(Jt,"kind","lessThanOrEqual"),n(Jt,"inputs",i.ins(2,["number"])),n(Jt,"outputs",i.out(["boolean"]));class Kt extends i{run(){this.output(0).data=this.input(0).data>this.input(1).data}}n(Kt,"kind","greaterThan"),n(Kt,"inputs",i.ins(2,["number"])),n(Kt,"outputs",i.out(["boolean"]));class Wt extends i{run(){this.output(0).data=this.input(0).data>=this.input(1).data}}n(Wt,"kind","greaterThanOrEqual"),n(Wt,"inputs",i.ins(2,["number"])),n(Wt,"outputs",i.out(["boolean"]));class Qt extends i{run(){this.output(0).data=this.input(0).data!=this.input(1).data}}n(Qt,"kind","inequality"),n(Qt,"inputs",i.ins(2)),n(Qt,"outputs",i.out(["boolean"]));class Vt extends i{run(){this.output(0).data=this.input(0).data*this.input(1).data}}n(Vt,"kind","multiplication"),n(Vt,"inputs",i.ins(2,["number"])),n(Vt,"outputs",i.out(["number"]));class Xt extends i{run(){this.output(0).data=this.input(0).data-this.input(1).data}}n(Xt,"kind","subtraction"),n(Xt,"inputs",i.ins(2,["number"])),n(Xt,"outputs",i.out(["number"]));const Rs={[Ut.kind]:Ut,[zt.kind]:zt,[Ft.kind]:Ft,[Kt.kind]:Kt,[Wt.kind]:Wt,[Ht.kind]:Ht,[Jt.kind]:Jt,[Qt.kind]:Qt,[Vt.kind]:Vt,[Xt.kind]:Xt};class Yt extends i{run(){this.output(0).data=this.input(0).data.length}}n(Yt,"kind","stringLength"),n(Yt,"inputs",i.in(["string"])),n(Yt,"outputs",i.out(["number"]));const Us={[Yt.kind]:Yt},zs=l(l(l(l(l(l(l(l(l(l(l(l({},Bs),js),vs),$s),Ps),Cs),Ss),As),ws),Gs),Rs),Us);export{zs as catalog};
