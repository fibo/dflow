var kt=Object.defineProperty,Tt=Object.defineProperties;var Pt=Object.getOwnPropertyDescriptors;var ot=Object.getOwnPropertySymbols;var lt=Object.prototype.hasOwnProperty,gt=Object.prototype.propertyIsEnumerable;var dt=(i,t,e)=>t in i?kt(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e,l=(i,t)=>{for(var e in t||(t={}))lt.call(t,e)&&dt(i,e,t[e]);if(ot)for(var e of ot(t))gt.call(t,e)&&dt(i,e,t[e]);return i},x=(i,t)=>Tt(i,Pt(t));var P=(i,t)=>{var e={};for(var s in i)lt.call(i,s)&&t.indexOf(s)<0&&(e[s]=i[s]);if(i!=null&&ot)for(var s of ot(i))t.indexOf(s)<0&&gt.call(i,s)&&(e[s]=i[s]);return e};var o=(i,t,e)=>(dt(i,typeof t!="symbol"?t+"":t,e),e),at=(i,t,e)=>{if(!t.has(i))throw TypeError("Cannot "+e)};var n=(i,t,e)=>(at(i,t,"read from private field"),e?e.call(i):t.get(i)),y=(i,t,e)=>{if(t.has(i))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(i):t.set(i,e)},k=(i,t,e,s)=>(at(i,t,"write to private field"),s?s.call(i,e):t.set(i,e),e);var j=(i,t,e)=>(at(i,t,"access private method"),e);var $,et,G,B,C,D,R,J,K,st,mt,nt,Ot,m,O,a,it,Et,rt,Nt;const T=i=>`${i} must be a string`,yt=(i,t)=>`${t} pin not found nodeId=${i}`,It=(i,t,e)=>`${yt(i,t)} position=${e}`,wt=(i,t,e)=>`${yt(i,t)} pinId=${e}`,ct=({id:i,kind:t,outputs:e},s)=>{const r={id:i,kind:t,outputs:e==null?void 0:e.map(({id:u,data:c,name:h})=>({id:u,data:c,name:h}))};return s&&(r.error=s),r};class d{static isArray(t){return!!Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowId(t){return d.isStringNotEmpty(t)}static isObject(t){return!(typeof t!="object"||!t||Array.isArray(t))}static isNumber(t){return typeof t=="number"&&!isNaN(t)}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return d.isString(t)&&t!==""}static validate(t,e){return e.length===0?!0:e.some(s=>{switch(s){case"array":return d.isArray(t);case"boolean":return d.isBoolean(t);case"number":return d.isNumber(t);case"object":return d.isObject(t);case"string":return d.isString(t);case"DflowId":return d.isDflowId(t);default:return!1}},!0)}}class M{constructor({id:t,name:e}){o(this,"id");o(this,"name");this.id=t,this.name=e}static isDflowItem(t){if(typeof t!="object"||!t)return!1;const{id:e,name:s}=t;return d.isDflowId(e)&&(typeof s>"u"||d.isStringNotEmpty(s))}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const tt=class extends M{constructor(t,r){var u=r,{types:e=[]}=u,s=P(u,["types"]);super(s);o(this,"kind");o(this,"types");this.kind=t,this.types=e}static isDflowPin(t){if(typeof t!="object"||!t)return!1;const r=t,{types:e}=r,s=P(r,["types"]);return M.isDflowItem(s)&&tt.isDflowPinTypes(e)}static isDflowPinType(t){return typeof t!="string"?!1:tt.types.includes(t)}static isDflowPinTypes(t){return Array.isArray(t)?t.every(e=>tt.isDflowPinType(e)):!1}get hasTypeAny(){return this.types.length===0}hasType(t){return this.hasTypeAny||this.types.includes(t)}toObject(){const t=super.toObject();return this.types.length>0&&(t.types=this.types),t}};let E=tt;o(E,"types",["string","number","boolean","object","array","DflowId"]);class ht extends E{constructor(r){var u=r,{multi:t,optional:e}=u,s=P(u,["multi","optional"]);super("input",s);y(this,$,void 0);y(this,et,void 0);y(this,G,void 0);y(this,B,void 0);k(this,$,t),k(this,et,e)}static isDflowInput(t){if(typeof t!="object"||!t)return!1;const{id:e,types:s,optional:r,multi:u}=t;return E.isDflowPin({id:e,types:s})&&(typeof u>"u"||typeof u=="boolean")&&(typeof r>"u"||typeof r=="boolean")}get data(){var t,e;if(n(this,$)){const s=Array.from((t=n(this,B))!=null?t:[]);return s.length?s.map(r=>r.data):void 0}else return(e=n(this,G))==null?void 0:e.data}get isConnected(){var t;return n(this,$)?Array.from((t=n(this,B))!=null?t:[]).length>0:typeof n(this,G)>"u"}get isMulti(){return n(this,$)}get isOptional(){return n(this,et)}connectTo(t){const{hasTypeAny:e,types:s}=this,{types:r}=t;if(e||s.some(c=>r.includes(c)))n(this,$)?(n(this,B)||k(this,B,new Set),n(this,B).add(t)):k(this,G,t);else throw new Error(`mismatching pinTypes, source has types [${r.join()}] and target has types [${s.join()}]`)}disconnect(){var t;n(this,$)?(t=n(this,B))==null||t.clear():k(this,G,void 0)}toObject(){return super.toObject()}}$=new WeakMap,et=new WeakMap,G=new WeakMap,B=new WeakMap;class pt extends E{constructor(s){var r=s,{data:t}=r,e=P(r,["data"]);super("output",e);y(this,C,void 0);k(this,C,t)}static isDflowOutput({id:t,data:e,types:s=[]}){return E.isDflowPin({id:t,types:s})&&d.validate(e,s)}clear(){k(this,C,void 0)}get data(){return n(this,C)}set data(t){switch(!0){case typeof t>"u":this.clear();break;case this.hasTypeAny:case(this.hasType("string")&&d.isString(t)):case(this.hasType("number")&&d.isNumber(t)):case(this.hasType("boolean")&&d.isBoolean(t)):case(this.hasType("object")&&d.isObject(t)):case(this.hasType("array")&&d.isArray(t)):case(this.hasType("DflowId")&&d.isDflowId(t)):{k(this,C,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=super.toObject();return typeof n(this,C)<"u"&&(t.data=n(this,C)),t}}C=new WeakMap;class g extends M{constructor(I,u,{isAsync:c=!1,isConstant:h=!1}={}){var p=I,{kind:t,inputs:e=[],outputs:s=[]}=p,r=P(p,["kind","inputs","outputs"]);super(r);y(this,st);y(this,nt);y(this,D,new Map);y(this,R,new Map);y(this,J,[]);y(this,K,[]);o(this,"kind");o(this,"meta");o(this,"host");this.host=u,this.kind=t,this.meta={isAsync:c,isConstant:h};for(const w of e)this.newInput(w);for(const w of s)this.newOutput(w)}static input(t=[],e){if(E.isDflowPinType(t))return l({types:[t]},e);if(E.isDflowPinTypes(t))return l({types:t},e);throw new TypeError("invalid input definition")}static output(t=[],e){if(E.isDflowPinType(t))return l({types:[t]},e);if(E.isDflowPinTypes(t))return l({types:t},e);throw new TypeError("invalid output definition")}static in(t=[],e){return[l({types:t},e)]}static out(t=[],e){return[l({types:t},e)]}static isDflowNode(t){if(typeof t!="object"||!t)return!1;const c=t,{kind:e,inputs:s=[],outputs:r=[]}=c,u=P(c,["kind","inputs","outputs"]);return M.isDflowItem(u)&&d.isStringNotEmpty(e)&&s.every(h=>ht.isDflowInput(h))&&r.every(h=>pt.isDflowOutput(h))}get inputs(){return n(this,D).values()}get outputs(){return n(this,R).values()}get numInputs(){return n(this,D).size}get numOutputs(){return n(this,R).size}clearOutputs(){for(const t of this.outputs)t.clear()}getInputById(t){if(typeof t!="string")throw new TypeError(T("inputId"));const e=n(this,D).get(t);if(e)return e;throw new Error(wt(this.id,"input",t))}input(t){const e=n(this,J)[t];if(!e)throw new Error(It(this.id,"input",t));return this.getInputById(e)}getOutputById(t){if(typeof t!="string")throw new TypeError(T("outputId"));const e=n(this,R).get(t);if(e)return e;throw new Error(wt(this.id,"output",t))}output(t){const e=n(this,K)[t];if(!e)throw new Error(It(this.id,"output",t));return this.getOutputById(e)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),n(this,D).delete(t),n(this,J).splice(n(this,J).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),n(this,R).delete(t),n(this,K).splice(n(this,K).indexOf(t),1)}newInput(t){const e=d.isDflowId(t.id)?t.id:j(this,st,mt).call(this),s=new ht(x(l({},t),{id:e}));return n(this,D).set(e,s),n(this,J).push(e),s}newOutput(t){const e=d.isDflowId(t.id)?t.id:j(this,nt,Ot).call(this),s=new pt(x(l({},t),{id:e}));return n(this,R).set(e,s),n(this,K).push(e),s}run(){}toObject(){const t=x(l({},super.toObject()),{kind:this.kind}),e=[],s=[];for(const r of this.inputs)e.push(r.toObject());e.length>0&&(t.inputs=e);for(const r of this.outputs)s.push(r.toObject());return s.length>0&&(t.outputs=s),t}}D=new WeakMap,R=new WeakMap,J=new WeakMap,K=new WeakMap,st=new WeakSet,mt=function(t=this.numInputs){const e=`i${t}`;return n(this,D).has(e)?j(this,st,mt).call(this,t+1):e},nt=new WeakSet,Ot=function(t=this.numOutputs){const e=`o${t}`;return n(this,R).has(e)?j(this,nt,Ot).call(this,t+1):e},o(g,"kind"),o(g,"isAsync"),o(g,"isConstant"),o(g,"inputs"),o(g,"outputs");class bt extends M{constructor(r){var u=r,{source:t,target:e}=u,s=P(u,["source","target"]);super(s);o(this,"source");o(this,"target");const[c,h]=t,[I,p]=e;if(typeof c!="string")throw new TypeError(T("sourceNodeId"));if(typeof h!="string")throw new TypeError(T("sourcePinId"));if(typeof I!="string")throw new TypeError(T("targetNodeId"));if(typeof p!="string")throw new TypeError(T("targetPinId"));this.source=t,this.target=e}static isDflowEdge(t){if(typeof t!="object"||!t)return!1;const u=t,{source:e,target:s}=u,r=P(u,["source","target"]);return!(M.isDflowItem(r)||!Array.isArray(e)||e.length!==2||d.isDflowId(e[0])||d.isDflowId(e[1])||!Array.isArray(s)||s.length!==2||d.isDflowId(s[0])||d.isDflowId(s[1]))}toObject(){return x(l({},super.toObject()),{source:this.source,target:this.target})}}const S=class extends M{constructor(){super(...arguments);y(this,m,new Map);y(this,O,new Map);o(this,"runOptions",{verbose:!1});o(this,"runStatus",null);o(this,"executionReport",null)}static childrenOfNodeId(t,e){return e.filter(({sourceId:s})=>t===s).map(({targetId:s})=>s)}static parentsOfNodeId(t,e){return e.filter(({targetId:s})=>t===s).map(({sourceId:s})=>s)}static levelOfNodeId(t,e){const s=S.parentsOfNodeId(t,e);if(s.length===0)return 0;let r=0;for(const u of s){const c=S.levelOfNodeId(u,e);r=Math.max(c,r)}return r+1}static ancestorsOfNodeId(t,e){const s=S.parentsOfNodeId(t,e);return s.length===0?[]:s.reduce((r,u,c,h)=>{const I=S.ancestorsOfNodeId(u,e),p=r.concat(I);return c===h.length-1?Array.from(new Set(h.concat(p))):p},[])}static sort(t,e){const s={};for(const r of t)s[r]=S.levelOfNodeId(r,e);return t.slice().sort((r,u)=>s[r]<=s[u]?-1:1)}get edges(){return n(this,O).values()}get nodes(){return n(this,m).values()}get nodeConnections(){return[...n(this,O).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...n(this,O).keys()]}get nodeIds(){return[...n(this,m).keys()]}get numEdges(){return n(this,O).size}get numNodes(){return n(this,m).size}addEdge(t){if(n(this,O).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);n(this,O).set(t.id,t)}addNode(t){if(n(this,m).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);n(this,m).set(t.id,t)}clear(){n(this,m).clear(),n(this,O).clear()}deleteEdge(t){n(this,O).delete(t)}deleteNode(t){n(this,m).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(T("nodeId"));const e=n(this,m).get(t);if(e)return e;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(T("edgeId"));const e=n(this,O).get(t);if(e)return e;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const e=`e${t}`;return n(this,O).has(e)?this.generateEdgeId(t+1):e}generateNodeId(t=this.numNodes){const e=`n${t}`;return n(this,m).has(e)?this.generateNodeId(t+1):e}nodeIdsInsideFunctions(){const t=[];for(const e of this.nodes)e.kind==="return"&&t.push(S.ancestorsOfNodeId(e.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){var r,u;const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const e=this.nodeIdsInsideFunctions(),s=S.sort(this.nodeIds.filter(c=>!e.includes(c)),this.nodeConnections);e:for(const c of s){const h=n(this,m).get(c);try{if(!h.meta.isConstant){let I=!1;t:for(const{id:p,data:w,types:b,isOptional:f}of h.inputs){if(f&&typeof w>"u")continue t;if(!d.validate(w,b)){I=!0,t&&((r=this.executionReport.steps)==null||r.push(ct(h.toObject(),`invalid input data nodeId=${c} inputId=${p} data=${w}`)));break t}}if(I){for(const p of h.outputs)p.clear();continue e}h.meta.isAsync?await h.run():h.run()}t&&((u=this.executionReport.steps)==null||u.push(ct(h.toObject())))}catch(I){console.error(I),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=x(l({},super.toObject()),{nodes:[],edges:[]});for(const e of this.nodes)t.nodes.push(e.toObject());for(const e of this.edges)t.edges.push(e.toObject());return t}};let V=S;m=new WeakMap,O=new WeakMap;const W=class{constructor(t={}){y(this,a,void 0);o(this,"nodesCatalog");o(this,"context");this.nodesCatalog=l(l({},t),At),k(this,a,new V({id:"g1"})),this.context={}}get executionReport(){return n(this,a).executionReport}get edges(){return n(this,a).edges}get nodes(){return n(this,a).nodes}get numEdges(){return n(this,a).numEdges}get numNodes(){return n(this,a).numNodes}get nodeKinds(){return Object.keys(this.nodesCatalog)}get runStatusIsSuccess(){return n(this,a).runStatus==="success"}get runStatusIsWaiting(){return n(this,a).runStatus==="waiting"}get runStatusIsFailure(){return n(this,a).runStatus==="failure"}set verbose(t){n(this,a).runOptions.verbose=t}clearGraph(){n(this,a).clear()}connect(t,e=0){return{to:(s,r=0)=>{const u=n(this,a).generateEdgeId(),c=t.output(e),h=s.input(r);this.newEdge({id:u,source:[t.id,c.id],target:[s.id,h.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(T("edgeId"));const e=n(this,a).getEdgeById(t);if(e){const[s,r]=e.target;this.getNodeById(s).getInputById(r).disconnect(),n(this,a).deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(T("nodeId"));const e=this.getNodeById(t);if(e){for(const s of n(this,a).edges){const{source:[r],target:[u]}=s;(r===e.id||u===e.id)&&this.deleteEdge(s.id)}n(this,a).deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,e]){for(const s of this.edges){const[r,u]=s.source,[c,h]=s.target;(r===t&&u===e||c===t&&h===e)&&this.deleteEdge(s.id)}}executeFunction(t,e){var p,w;const{verbose:s}=n(this,a).runOptions,r=n(this,a).nodeConnections,u=V.childrenOfNodeId(t,r),c=[];for(const b of u){const f=this.getNodeById(b);f.kind===F.kind&&c.push(f.id)}const h=c.reduce((b,f,N,L)=>{const xt=V.ancestorsOfNodeId(f,r),ft=b.concat(xt);return N===L.length?Array.from(new Set(ft)):ft},[]),I=V.sort([...c,...h],r);for(const b of I){const f=this.getNodeById(b);try{switch(f.kind){case z.kind:{const N=f.input(0).data,L=typeof N=="number"&&!isNaN(N)?Math.max(N,0):0;f.output(0).data=e[L];break}case F.kind:return f.input(1).data;default:!f.meta.isConstant&&!f.meta.isAsync&&f.run(),s&&((w=(p=this.executionReport)==null?void 0:p.steps)==null||w.push(ct(f.toObject())))}}catch(N){console.error(N)}}}getEdgeById(t){return n(this,a).getEdgeById(t)}getNodeById(t){return n(this,a).getNodeById(t)}newNode(t){var I,p,w,b,f,N,L;const e=(I=this.nodesCatalog[t.kind])!=null?I:jt,s=d.isDflowId(t.id)?t.id:n(this,a).generateNodeId(),r={isAsync:e.isAsync,isConstant:e.isConstant},u=Array.isArray(t.inputs)?j(p=W,it,Et).call(p,t.inputs):j(b=W,it,Et).call(b,(w=e.inputs)!=null?w:[]),c=Array.isArray(t.outputs)?j(f=W,rt,Nt).call(f,t.outputs):j(L=W,rt,Nt).call(L,(N=e.outputs)!=null?N:[]),h=new e(x(l({},t),{id:s,inputs:u,outputs:c}),this,r);return n(this,a).addNode(h),h}newEdge(t){const e=d.isDflowId(t.id)?t.id:n(this,a).generateEdgeId(),s=new bt(x(l({},t),{id:e}));n(this,a).addEdge(s);const[r,u]=s.source,[c,h]=s.target,I=n(this,a).getNodeById(r),p=n(this,a).getNodeById(c),w=I.getOutputById(u);return p.getInputById(h).connectTo(w),s}newInput(t,e){return n(this,a).getNodeById(t).newInput(e)}newOutput(t,e){return n(this,a).getNodeById(t).newOutput(e)}toObject(){return n(this,a).toObject()}async run(){await n(this,a).run()}};let ut=W;a=new WeakMap,it=new WeakSet,Et=function(t=[]){return t.map((e,s)=>x(l({},e),{id:d.isDflowId(e.id)?e.id:`i${s}`}))},rt=new WeakSet,Nt=function(t=[]){return t.map((e,s)=>x(l({},e),{id:d.isDflowId(e.id)?e.id:`o${s}`}))},y(ut,it),y(ut,rt);const{input:A,output:v}=g;class z extends g{}o(z,"kind","argument"),o(z,"isConstant",!0),o(z,"inputs",[A("number",{name:"position",optional:!0})]),o(z,"outputs",[v()]);class q extends g{run(){const t=this.input(0).data;d.isArray(t)?this.output(0).data=t:this.output(0).clear()}}o(q,"kind","array"),o(q,"inputs",[A()]),o(q,"outputs",[v("array")]);class H extends g{run(){const t=this.input(0).data;d.isBoolean(t)?this.output(0).data=t:this.output(0).clear()}}o(H,"kind","boolean"),o(H,"inputs",[A()]),o(H,"outputs",[v("boolean")]);class Q extends g{}o(Q,"kind","data"),o(Q,"isConstant",!0),o(Q,"outputs",[v()]);class U extends g{constructor(...t){super(...t);this.output(0).data=this.id}}o(U,"kind","function"),o(U,"isConstant",!0),o(U,"outputs",[v("DflowId",{name:"id"})]);class X extends g{run(){this.output(0).data=typeof this.input(0).data>"u"}}o(X,"kind","isUndefined"),o(X,"inputs",[A()]),o(X,"outputs",[v("boolean")]);class Y extends g{run(){const t=this.input(0).data;d.isNumber(t)?this.output(0).data=t:this.output(0).clear()}}o(Y,"kind","number"),o(Y,"inputs",[A()]),o(Y,"outputs",[v("number")]);class Z extends g{run(){const t=this.input(0).data;d.isObject(t)?this.output(0).data=t:this.output(0).clear()}}o(Z,"kind","object"),o(Z,"inputs",[A()]),o(Z,"outputs",[v("object")]);class F extends g{}o(F,"kind","return"),o(F,"isConstant",!0),o(F,"inputs",[A("DflowId",{name:"functionId"}),A([],{name:"value"})]);class _ extends g{run(){const t=this.input(0).data;d.isString(t)?this.output(0).data=t:this.output(0).clear()}}o(_,"kind","string"),o(_,"inputs",[A()]),o(_,"outputs",[v("string")]);class jt extends g{}const At={[z.kind]:z,[q.kind]:q,[H.kind]:H,[Q.kind]:Q,[X.kind]:X,[Y.kind]:Y,[Z.kind]:Z,[U.kind]:U,[_.kind]:_,[F.kind]:F};export{d as DflowData};export{M as DflowItem};export{E as DflowPin};export{ht as DflowInput};export{pt as DflowOutput};export{g as DflowNode};export{bt as DflowEdge};export{V as DflowGraph};export{ut as DflowHost};
