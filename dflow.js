var ps=Object.defineProperty,hs=Object.defineProperties;var ls=Object.getOwnPropertyDescriptors;var Vt=Object.getOwnPropertySymbols;var es=Object.prototype.hasOwnProperty,ns=Object.prototype.propertyIsEnumerable;var _t=(i,t,s)=>t in i?ps(i,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):i[t]=s,l=(i,t)=>{for(var s in t||(t={}))es.call(t,s)&&_t(i,s,t[s]);if(Vt)for(var s of Vt(t))ns.call(t,s)&&_t(i,s,t[s]);return i},b=(i,t)=>hs(i,ls(t));var E=(i,t)=>{var s={};for(var a in i)es.call(i,a)&&t.indexOf(a)<0&&(s[a]=i[a]);if(i!=null&&Vt)for(var a of Vt(i))t.indexOf(a)<0&&ns.call(i,a)&&(s[a]=i[a]);return s};var e=(i,t,s)=>(_t(i,typeof t!="symbol"?t+"":t,s),s),is=(i,t,s)=>{if(!t.has(i))throw TypeError("Cannot "+s)};var u=(i,t,s)=>(is(i,t,"read from private field"),s?s.call(i):t.get(i)),k=(i,t,s)=>{if(t.has(i))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(i):t.set(i,s)},x=(i,t,s,a)=>(is(i,t,"write to private field"),a?a.call(i,s):t.set(i,s),s);var S,Jt,j,v,P,G,R,Qt,f,I,p,z;const N=i=>`${i} must be a string`,as=i=>`${i} must be a number`,us=(i,t)=>`${t} pin not found nodeId=${i}`,rs=(i,t,s)=>`${us(i,t)} position=${s}`,os=(i,t,s)=>`${us(i,t)} pinId=${s}`,Dt=({id:i,kind:t,outputs:s})=>({id:i,kind:t,outputs:s==null?void 0:s.map(({id:a,data:r,name:d})=>({id:a,data:r,name:d}))});class o{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowGraph(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&Array.isArray(t.nodes)&&Array.isArray(t.edges)&&C.isDflowGraph(t)}static isDflowId(t){return o.isStringNotEmpty(t)}static isDflowType(t){return typeof t=="string"&&w.types.includes(t)}static isObject(t){return!o.isUndefined(t)&&!o.isNull(t)&&!o.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return o.isString(t)&&t.length>0}static isUndefined(t){return typeof t>"u"}static validate(t,s){return s.length===0?!0:s.some(a=>{switch(a){case"array":return o.isArray(t);case"boolean":return o.isBoolean(t);case"null":return o.isNull(t);case"number":return o.isNumber(t);case"object":return o.isObject(t);case"string":return o.isString(t);case"DflowGraph":return o.isDflowGraph(t);case"DflowId":return o.isDflowId(t);case"DflowType":return o.isDflowType(t);default:return!1}},!0)}}class ${constructor({id:t,name:s}){e(this,"id");e(this,"name");this.id=t,this.name=s}static isDflowItem({id:t,name:s}){return o.isDflowId(t)&&(o.isUndefined(s)||o.isStringNotEmpty(s))}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const Mt=class extends ${constructor(t,r){var d=r,{types:s=[]}=d,a=E(d,["types"]);super(a);e(this,"kind");e(this,"types");this.kind=t,this.types=s}static isDflowPin(a){var r=a,{types:t=[]}=r,s=E(r,["types"]);return $.isDflowItem(s)&&t.every(d=>Mt.isDflowPinType(d))}static isDflowPinType(t){Mt.types.includes(t)}get hasTypeAny(){return this.types.length===0}get hasTypeDflowId(){return this.hasTypeAny||this.types.includes("DflowId")}get hasTypeDflowGraph(){return this.hasTypeAny||this.types.includes("DflowGraph")}get hasTypeDflowType(){return this.hasTypeAny||this.types.includes("DflowType")}get hasTypeString(){return this.hasTypeAny||this.types.includes("string")}get hasTypeNumber(){return this.hasTypeAny||this.types.includes("number")}get hasTypeBoolean(){return this.hasTypeAny||this.types.includes("boolean")}get hasTypeNull(){return this.hasTypeAny||this.types.includes("null")}get hasTypeObject(){return this.hasTypeAny||this.types.includes("object")}get hasTypeArray(){return this.hasTypeAny||this.types.includes("array")}addType(t){this.types.push(t)}removeType(t){this.types.splice(this.types.indexOf(t),1)}};let w=Mt;e(w,"types",["string","number","boolean","null","object","array","DflowId","DflowGraph","DflowType"]);class Xt extends w{constructor(a){var r=a,{optional:t}=r,s=E(r,["optional"]);super("input",s);k(this,S,void 0);k(this,Jt,void 0);x(this,Jt,t)}static isDflowInput({id:t,types:s}){return w.isDflowPin({id:t,types:s})}get data(){var t;return(t=u(this,S))==null?void 0:t.data}get isConnected(){return typeof u(this,S)>"u"}get isOptional(){return u(this,Jt)}connectTo(t){const{hasTypeAny:s,types:a}=this,{types:r}=t;if(s||a.some(d=>r.includes(d)))x(this,S,t);else throw new Error(`mismatching pinTypes, source has types [${r.join()}] and target has types [${a.join()}]`)}disconnect(){x(this,S,void 0)}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}S=new WeakMap,Jt=new WeakMap;class Yt extends w{constructor(a){var r=a,{data:t}=r,s=E(r,["data"]);super("output",s);k(this,j,void 0);x(this,j,t)}static isDflowOutput({id:t,data:s,types:a=[]}){return w.isDflowPin({id:t,types:a})&&o.validate(s,a)}clear(){x(this,j,void 0)}get data(){return u(this,j)}set data(t){switch(!0){case o.isUndefined(t):this.clear();break;case this.hasTypeAny:case(o.isDflowGraph(t)&&this.hasTypeDflowGraph):case(o.isDflowId(t)&&this.hasTypeDflowId):case(o.isString(t)&&this.hasTypeString):case(o.isNumber(t)&&this.hasTypeNumber):case(o.isBoolean(t)&&this.hasTypeBoolean):case(o.isNull(t)&&this.hasTypeNull):case(o.isObject(t)&&this.hasTypeObject):case(o.isArray(t)&&this.hasTypeArray):{x(this,j,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=l({},super.toObject());return o.isUndefined(u(this,j))||(t.data=u(this,j)),this.types.length>0&&(t.types=this.types),t}}j=new WeakMap;const Lt=class extends ${constructor(g,d,{isAsync:h=!1,isConstant:c=!1,label:y}={}){var O=g,{kind:t,inputs:s=[],outputs:a=[]}=O,r=E(O,["kind","inputs","outputs"]);super(r);k(this,v,new Map);k(this,P,new Map);k(this,G,[]);k(this,R,[]);k(this,Qt,void 0);e(this,"kind");e(this,"meta");e(this,"host");x(this,Qt,y),this.host=d,this.kind=t,this.meta={isAsync:h,isConstant:c};for(const T of s)this.newInput(T);for(const T of a)this.newOutput(T);this.onCreate()}static generateInputIds(t=[]){return t.map((s,a)=>b(l({},s),{id:`i${a}`}))}static generateOutputIds(t=[]){return t.map((s,a)=>b(l({},s),{id:`o${a}`}))}static in(t=[],s){return[l({types:t},s)]}static ins(t,s=[]){return Array(t).fill(Lt.in(s)).flat()}static out(t=[],s){return[l({types:t},s)]}static outs(t,s=[]){return Array(t).fill(Lt.out(s)).flat()}static outputNumber(t){return b(l({},t),{types:["number"]})}static isDflowNode(d){var h=d,{kind:t,inputs:s=[],outputs:a=[]}=h,r=E(h,["kind","inputs","outputs"]);return $.isDflowItem(r)&&o.isStringNotEmpty(t)&&s.every(c=>Xt.isDflowInput(c))&&a.every(c=>Yt.isDflowOutput(c))}get label(){return u(this,Qt)||this.kind}get inputs(){return u(this,v).values()}get outputs(){return u(this,P).values()}get numInputs(){return u(this,v).size}get numOutputs(){return u(this,P).size}generateInputId(t=this.numInputs){const s=`i${t}`;return u(this,v).has(s)?this.generateInputId(t+1):s}generateOutputId(t=this.numOutputs){const s=`o${t}`;return u(this,P).has(s)?this.generateOutputId(t+1):s}getInputById(t){if(typeof t!="string")throw new TypeError(N("inputId"));const s=u(this,v).get(t);if(s instanceof Xt)return s;throw new Error(os(this.id,"input",t))}input(t){if(typeof t!="number")throw new TypeError(as("position"));const s=u(this,G)[t];if(o.isUndefined(s))throw new Error(rs(this.id,"input",t));return this.getInputById(s)}getOutputById(t){if(typeof t!="string")throw new TypeError(N("outputId"));const s=u(this,P).get(t);if(s instanceof Yt)return s;throw new Error(os(this.id,"output",t))}output(t){if(typeof t!="number")throw new TypeError(as("position"));const s=u(this,R)[t];if(o.isUndefined(s))throw new Error(rs(this.id,"output",t));return this.getOutputById(s)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),u(this,v).delete(t),u(this,G).splice(u(this,G).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),u(this,P).delete(t),u(this,R).splice(u(this,R).indexOf(t),1)}onBeforeConnectInput(t,s){}onCreate(){}newInput(t){const s=o.isDflowId(t.id)?t.id:this.generateInputId(),a=new Xt(b(l({},t),{id:s}));return u(this,v).set(s,a),u(this,G).push(s),a}newOutput(t){const s=o.isDflowId(t.id)?t.id:this.generateOutputId(),a=new Yt(b(l({},t),{id:s}));return u(this,P).set(s,a),u(this,R).push(s),a}run(){}toObject(){const t=b(l({},super.toObject()),{kind:this.kind}),s=[],a=[];for(const r of this.inputs)s.push(r.toObject());s.length>0&&(t.inputs=s);for(const r of this.outputs)a.push(r.toObject());return a.length>0&&(t.outputs=a),t}};let n=Lt;v=new WeakMap,P=new WeakMap,G=new WeakMap,R=new WeakMap,Qt=new WeakMap,e(n,"kind"),e(n,"isAsync"),e(n,"isConstant"),e(n,"label"),e(n,"inputs"),e(n,"outputs");const ts=class extends n{constructor(t,s){super(b(l({},t),{kind:ts.kind}),s)}run(){}};let Zt=ts;e(Zt,"kind","Unknown");class K extends ${constructor(r){var d=r,{source:t,target:s}=d,a=E(d,["source","target"]);super(a);e(this,"source");e(this,"target");const[h,c]=t,[y,g]=s;if(typeof h!="string")throw new TypeError(N("sourceNodeId"));if(typeof c!="string")throw new TypeError(N("sourcePinId"));if(typeof y!="string")throw new TypeError(N("targetNodeId"));if(typeof g!="string")throw new TypeError(N("targetPinId"));this.source=t,this.target=s}static isDflowEdge(d,r){var h=d,{source:t,target:s}=h,a=E(h,["source","target"]);return $.isDflowItem(a)&&Array.isArray(t)&&t.length===2&&r.nodes.find(({id:c,outputs:y=[]})=>c===t[0]&&y.find(({id:g})=>g===t[1]))&&Array.isArray(s)&&s.length===2&&r.nodes.find(({id:c,inputs:y=[]})=>c===s[0]&&y.find(({id:g})=>g===s[1]))}toObject(){return b(l({},super.toObject()),{source:this.source,target:this.target})}}const B=class extends ${constructor(){super(...arguments);k(this,f,new Map);k(this,I,new Map);e(this,"runOptions",{verbose:!1});e(this,"runStatus",null);e(this,"executionReport",null)}static isDflowGraph(t){return t.nodes.every(s=>n.isDflowNode(s))&&t.edges.every(s=>K.isDflowEdge(s,t))}static childrenOfNodeId(t,s){return s.filter(({sourceId:a})=>t===a).map(({targetId:a})=>a)}static parentsOfNodeId(t,s){return s.filter(({targetId:a})=>t===a).map(({sourceId:a})=>a)}static levelOfNodeId(t,s){const a=B.parentsOfNodeId(t,s);if(a.length===0)return 0;let r=0;for(const d of a){const h=B.levelOfNodeId(d,s);r=Math.max(h,r)}return r+1}static ancestorsOfNodeId(t,s){const a=B.parentsOfNodeId(t,s);return a.length===0?[]:a.reduce((r,d,h,c)=>{const y=B.ancestorsOfNodeId(d,s),g=r.concat(y);return h===c.length-1?Array.from(new Set(c.concat(g))):g},[])}static sort(t,s){const a={};for(const r of t)a[r]=B.levelOfNodeId(r,s);return t.slice().sort((r,d)=>a[r]<=a[d]?-1:1)}get edges(){return u(this,I).values()}get nodes(){return u(this,f).values()}get nodeConnections(){return[...u(this,I).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...u(this,I).keys()]}get nodeIds(){return[...u(this,f).keys()]}get numEdges(){return u(this,I).size}get numNodes(){return u(this,f).size}addEdge(t){if(u(this,I).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);u(this,I).set(t.id,t)}addNode(t){if(u(this,f).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);u(this,f).set(t.id,t)}clear(){u(this,f).clear(),u(this,I).clear()}deleteEdge(t){u(this,I).delete(t)}deleteNode(t){u(this,f).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(N("nodeId"));const s=u(this,f).get(t);if(s instanceof n)return s;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(N("edgeId"));const s=u(this,I).get(t);if(s instanceof K)return s;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const s=`e${t}`;return u(this,I).has(s)?this.generateEdgeId(t+1):s}generateNodeId(t=this.numNodes){const s=`n${t}`;return u(this,f).has(s)?this.generateNodeId(t+1):s}nodeIdsInsideFunctions(){const t=[];for(const s of this.nodes)s.kind==="return"&&t.push(B.ancestorsOfNodeId(s.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){var r,d;const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const s=this.nodeIdsInsideFunctions(),a=B.sort(this.nodeIds.filter(h=>!s.includes(h)),this.nodeConnections);s:for(const h of a){const c=u(this,f).get(h);try{if(!c.meta.isConstant){let y=!1;t:for(const{data:g,types:O,isOptional:T}of c.inputs){if(T&&typeof g>"u")continue t;if(!o.validate(g,O)){y=!0;break t}}if(y){for(const g of c.outputs)g.clear();t&&((r=this.executionReport.steps)==null||r.push(Dt(c.toObject())));continue s}c.meta.isAsync?await c.run():c.run()}t&&((d=this.executionReport.steps)==null||d.push(Dt(c.toObject())))}catch(y){console.error(y),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=b(l({},super.toObject()),{nodes:[],edges:[]});for(const s of this.nodes)t.nodes.push(s.toObject());for(const s of this.edges)t.edges.push(s.toObject());return t}};let C=B;f=new WeakMap,I=new WeakMap;class ys{constructor(t={}){k(this,p,void 0);k(this,z,void 0);e(this,"context");x(this,z,t),x(this,p,new C({id:"g1"})),this.context={}}get executionReport(){return u(this,p).executionReport}get edges(){return u(this,p).edges}get nodes(){return u(this,p).nodes}get numEdges(){return u(this,p).numEdges}get numNodes(){return u(this,p).numNodes}get nodeKinds(){return Object.keys(u(this,z))}get runStatusIsSuccess(){return u(this,p).runStatus==="success"}get runStatusIsWaiting(){return u(this,p).runStatus==="waiting"}get runStatusIsFailure(){return u(this,p).runStatus==="failure"}set verbose(t){u(this,p).runOptions.verbose=t}clearGraph(){u(this,p).clear()}connect(t,s=0){return{to:(a,r=0)=>{const d=u(this,p).generateEdgeId(),h=t.output(s),c=a.input(r);a.onBeforeConnectInput(t,s),this.newEdge({id:d,source:[t.id,h.id],target:[a.id,c.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(N("edgeId"));const s=u(this,p).getEdgeById(t);if(s instanceof K){const[a,r]=s.target;this.getNodeById(a).getInputById(r).disconnect(),u(this,p).deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(N("nodeId"));const s=this.getNodeById(t);if(s instanceof n){for(const a of u(this,p).edges){const{source:[r],target:[d]}=a;(r===s.id||d===s.id)&&this.deleteEdge(a.id)}u(this,p).deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,s]){for(const a of this.edges){const[r,d]=a.source,[h,c]=a.target;(r===t&&d===s||h===t&&c===s)&&this.deleteEdge(a.id)}}executeFunction(t,s){var g,O,T;const{verbose:a}=u(this,p).runOptions,r=u(this,p).nodeConnections,d=C.childrenOfNodeId(t,r),h=[];for(const F of d){const m=this.getNodeById(F);m.kind==="return"&&h.push(m.id)}const c=h.reduce((F,m,H,ds)=>{const cs=C.ancestorsOfNodeId(m,r),ss=F.concat(cs);return H===ds.length?Array.from(new Set(ss)):ss},[]),y=C.sort([...h,...c],r);for(const F of y){const m=this.getNodeById(F);try{switch(m.kind){case"argument":{const H=Math.max((g=m.input(1).data)!=null?g:0,0);m.output(0).data=s[H];break}case"return":return m.input(1).data;default:!m.meta.isConstant&&!m.meta.isAsync&&m.run(),a&&((T=(O=this.executionReport)==null?void 0:O.steps)==null||T.push(Dt(m.toObject())))}}catch(H){console.error(H)}}}getEdgeById(t){return u(this,p).getEdgeById(t)}getNodeById(t){return u(this,p).getNodeById(t)}newNode(t){var y;const s=(y=u(this,z)[t.kind])!=null?y:Zt,a=o.isDflowId(t.id)?t.id:u(this,p).generateNodeId(),r={isAsync:s.isAsync,isConstant:s.isConstant,label:s.label},d=Array.isArray(t.inputs)?t.inputs:n.generateInputIds(s.inputs),h=Array.isArray(t.outputs)?t.outputs:n.generateOutputIds(s.outputs),c=new s(b(l({},t),{id:a,inputs:d,outputs:h}),this,r);return u(this,p).addNode(c),c}newEdge(t){const s=o.isDflowId(t.id)?t.id:u(this,p).generateEdgeId(),a=new K(b(l({},t),{id:s}));u(this,p).addEdge(a);const[r,d]=a.source,[h,c]=a.target,y=u(this,p).getNodeById(r),g=u(this,p).getNodeById(h),O=y.getOutputById(d);return g.getInputById(c).connectTo(O),a}newInput(t,s){return u(this,p).getNodeById(t).newInput(s)}newOutput(t,s){return u(this,p).getNodeById(t).newOutput(s)}toObject(){return u(this,p).toObject()}async run(){await u(this,p).run()}}p=new WeakMap,z=new WeakMap;export{o as DflowData};export{$ as DflowItem};export{w as DflowPin};export{Xt as DflowInput};export{Yt as DflowOutput};export{n as DflowNode};export{Zt as DflowUnknownNode};export{K as DflowEdge};export{C as DflowGraph};export{ys as DflowHost};class W extends n{run(){const t=this.input(0).data,s=this.input(1).data;this.output(0).data=t.at(s)}}e(W,"kind","arrayAt"),e(W,"inputs",[...n.in(["array"]),...n.in(["number"],{name:"index"})]),e(W,"outputs",n.out());class J extends n{run(){this.output(0).data=this.input(0).data.filter((...t)=>this.host.executeFunction(this.input(1).data,t))}}e(J,"kind","arrayFilter"),e(J,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),e(J,"outputs",n.out(["array"]));class Q extends n{run(){this.output(0).data=this.input(0).data.findLastIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}e(Q,"kind","arrayFindLastIndex"),e(Q,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),e(Q,"outputs",n.out(["number"]));class V extends n{run(){this.output(0).data=this.input(0).data.findIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}e(V,"kind","arrayFindIndex"),e(V,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),e(V,"outputs",n.out(["number"]));class X extends n{run(){const t=this.input(0).data,s=this.input(1).data;Array.isArray(t)&&(this.output(0).data=t.includes(s))}}e(X,"kind","arrayIncludes"),e(X,"inputs",[...n.in(["array"],{name:"array"}),...n.in(["string"],{name:"element"})]),e(X,"outputs",n.out(["boolean"]));class Y extends n{run(){var a;const t=this.input(0).data,s=(a=this.input(1).data)!=null?a:",";Array.isArray(t)&&(this.output(0).data=t.join(s))}}e(Y,"kind","arrayJoin"),e(Y,"inputs",[...n.in(["array"],{name:"array"}),...n.in(["string"],{name:"separator",optional:!0})]),e(Y,"outputs",n.out(["string"]));class Z extends n{run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t.length:this.output(0).clear}}e(Z,"kind","arrayLength"),e(Z,"inputs",n.in(["array"])),e(Z,"outputs",n.out(["number"]));class q extends n{run(){this.output(0).data=this.input(0).data.map((...t)=>this.host.executeFunction(this.input(1).data,t))}}e(q,"kind","arrayMap"),e(q,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),e(q,"outputs",n.out(["array"]));class M extends n{run(){const t=this.input(0).data.slice(),s=t.pop();this.output(0).data=s,this.output(1).data=t}}e(M,"kind","arrayPop"),e(M,"inputs",n.in(["array"])),e(M,"outputs",[...n.out([],{name:"element"}),...n.out(["array"],{name:"rest"})]);class L extends n{run(){const t=this.input(0).data.slice(),s=this.input(1).data;s&&t.push(s),this.output(0).data=t}}e(L,"kind","arrayPush"),e(L,"inputs",[...n.in(["array"]),...n.in([],{name:"element"})]),e(L,"outputs",n.out(["array"]));class _ extends n{run(){const t=this.input(0).data.slice();this.output(0).data=t.reverse()}}e(_,"kind","arrayReverse"),e(_,"inputs",n.in(["array"])),e(_,"outputs",n.in(["array"]));class D extends n{run(){const t=this.input(0).data.slice(),s=t.shift();this.output(0).data=s,this.output(1).data=t}}e(D,"kind","arrayShift"),e(D,"inputs",n.in(["array"])),e(D,"outputs",[...n.out([],{name:"element"}),...n.out(["array"],{name:"rest"})]);class tt extends n{run(){const t=this.input(0).data,s=this.input(1).data,a=this.input(2).data;typeof a=="number"?this.output(0).data=t.slice(s,a):this.output(0).data=t.slice(s)}}e(tt,"kind","arraySlice"),e(tt,"inputs",[...n.in(["array"]),...n.in(["number"],{name:"start"}),...n.in(["number"],{name:"end",optional:!0})]),e(tt,"outputs",n.out(["array"]));const gs={[W.kind]:W,[J.kind]:J,[Q.kind]:Q,[V.kind]:V,[X.kind]:X,[Y.kind]:Y,[Z.kind]:Z,[q.kind]:q,[M.kind]:M,[L.kind]:L,[_.kind]:_,[D.kind]:D,[tt.kind]:tt};class st extends n{run(){this.output(0).data=this.input(0).data?this.input(1).data:this.input(2).data}}e(st,"kind","if"),e(st,"inputs",[...n.in(["boolean"],{name:"condition"}),...n.in([],{name:"then"}),...n.in([],{name:"else"})]),e(st,"outputs",n.out());const ms={[st.kind]:st};class qt extends n{run(){console.log(this.input(0).data)}}e(qt,"kind","consoleLog"),e(qt,"inputs",[...n.in([])]);const ks={[qt.kind]:qt};class et extends n{}e(et,"kind","data"),e(et,"isConstant",!0),e(et,"outputs",n.out());class nt extends n{run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t:this.output(0).clear()}}e(nt,"kind","array"),e(nt,"inputs",n.in()),e(nt,"outputs",n.out(["array"]));class it extends n{run(){const t=this.input(0).data;typeof t=="boolean"?this.output(0).data=t:this.output(0).clear()}}e(it,"kind","boolean"),e(it,"inputs",n.in()),e(it,"outputs",n.out(["boolean"]));class at extends n{run(){const t=this.input(0).data;typeof t=="number"?this.output(0).data=t:this.output(0).clear()}}e(at,"kind","number"),e(at,"inputs",n.in()),e(at,"outputs",n.out(["number"]));class ut extends n{run(){const t=this.input(0).data;typeof t=="object"&&t!==null?this.output(0).data=t:this.output(0).clear()}}e(ut,"kind","object"),e(ut,"inputs",n.in()),e(ut,"outputs",n.out(["object"]));class rt extends n{run(){const t=this.input(0).data;typeof t=="string"?this.output(0).data=t:this.output(0).clear()}}e(rt,"kind","string"),e(rt,"inputs",n.in()),e(rt,"outputs",n.out(["string"]));class ot extends n{run(){const t=this.input(0).data;this.output(0).data=Array.isArray(t)}}e(ot,"kind","isArray"),e(ot,"inputs",n.out()),e(ot,"outputs",n.out(["boolean"]));class dt extends n{run(){const t=this.input(0).data;console.log(t),this.output(0).data=typeof t<"u"}}e(dt,"kind","isDefined"),e(dt,"inputs",n.in()),e(dt,"outputs",n.out(["boolean"]));class ct extends n{run(){const t=this.input(0).data;console.log(t),this.output(0).data=typeof t>"u"}}e(ct,"kind","isUndefined"),e(ct,"inputs",n.in()),e(ct,"outputs",n.out(["boolean"]));const fs={[et.kind]:et,[dt.kind]:dt,[ct.kind]:ct,[nt.kind]:nt,[it.kind]:it,[at.kind]:at,[ut.kind]:ut,[rt.kind]:rt,[ot.kind]:ot};class A extends n{run(){const t=this.output(0);t.data=this.host.nodeKinds}}e(A,"kind","dflow"),e(A,"outputs",n.out(["array"],{name:"nodeKinds"}));class pt extends n{}e(pt,"kind","comment"),e(pt,"isConstant",!0),e(pt,"outputs",n.out(["string"]));class ht extends n{}e(ht,"kind","typeNumber"),e(ht,"isConstant",!0),e(ht,"outputs",n.out(["DflowType"],{name:"number",data:"number"}));class U extends n{onBeforeConnectInput(t,s){const a=t.output(s).data;this.output(0).addType(a)}}e(U,"kind","argument"),e(U,"isConstant",!0),e(U,"inputs",[...n.in(["DflowType"],{name:"type"}),...n.in(["number"],{name:"argumentPosition"})]),e(U,"outputs",n.out());class lt extends n{onCreate(){this.output(0).data=this.id}}e(lt,"kind","function"),e(lt,"isConstant",!0),e(lt,"outputs",A.out(["DflowId"],{name:"id"}));class yt extends n{}e(yt,"kind","return"),e(yt,"isConstant",!0),e(yt,"inputs",[...A.in(["DflowId"],{name:"functionId"}),...A.in([],{name:"value"})]);const Is={[A.kind]:A,[U.kind]:U,[pt.kind]:pt,[lt.kind]:lt,[yt.kind]:yt,[ht.kind]:ht};class gt extends n{run(){this.output(0).data=this.input(0).data&&this.input(1).data}}e(gt,"kind","and"),e(gt,"inputs",n.ins(2,["boolean"])),e(gt,"outputs",n.out(["boolean"]));class mt extends n{run(){this.output(0).data=!this.input(0).data}}e(mt,"kind","not"),e(mt,"inputs",n.in(["boolean"])),e(mt,"outputs",n.out(["boolean"]));class kt extends n{run(){this.output(0).data=this.input(0).data||this.input(1).data}}e(kt,"kind","or"),e(kt,"inputs",n.ins(2,["boolean"])),e(kt,"outputs",n.out(["boolean"]));const bs={[gt.kind]:gt,[mt.kind]:mt,[kt.kind]:kt};class ft extends n{run(){this.output(0).data=Math.cos(this.input(0).data)}}e(ft,"kind","mathCos"),e(ft,"inputs",n.in(["number"])),e(ft,"outputs",n.out(["number"]));class It extends n{run(){this.output(0).data=Math.cosh(this.input(0).data)}}e(It,"kind","mathCosh"),e(It,"inputs",n.in(["number"])),e(It,"outputs",n.out(["number"]));class bt extends n{run(){const t=this.input(0).data,s=Math.max(...t);isNaN(s)?this.output(0).clear():this.output(0).data=s}}e(bt,"kind","mathMax"),e(bt,"inputs",n.in(["array"])),e(bt,"outputs",n.out(["number"]));class xt extends n{run(){const t=this.input(0).data,s=Math.min(...t);isNaN(s)?this.output(0).clear():this.output(0).data=s}}e(xt,"kind","mathMin"),e(xt,"inputs",n.in(["array"])),e(xt,"outputs",n.out(["number"]));class Nt extends n{}e(Nt,"kind","mathPI"),e(Nt,"isConstant",!0),e(Nt,"outputs",n.out(["number"],{name:"\u03C0",data:Math.PI}));class Ot extends n{run(){this.output(0).data=Math.sin(this.input(0).data)}}e(Ot,"kind","mathSin"),e(Ot,"inputs",n.in(["number"])),e(Ot,"outputs",n.out(["number"]));class Tt extends n{run(){this.output(0).data=Math.sinh(this.input(0).data)}}e(Tt,"kind","mathSinh"),e(Tt,"inputs",n.in(["number"])),e(Tt,"outputs",n.out(["number"]));const xs={[ft.kind]:ft,[It.kind]:It,[bt.kind]:bt,[xt.kind]:xt,[Nt.kind]:Nt,[Ot.kind]:Ot,[Tt.kind]:Tt};class Et extends n{run(){this.output(0).data=Number.isFinite(this.input(0).data)}}e(Et,"kind","isFinite"),e(Et,"inputs",n.in(["number"])),e(Et,"outputs",n.out(["boolean"]));class Bt extends n{run(){this.output(0).data=Number.isInteger(this.input(0).data)}}e(Bt,"kind","isInteger"),e(Bt,"inputs",n.in([])),e(Bt,"outputs",n.out(["boolean"]));class jt extends n{run(){this.output(0).data=Number.isNaN(this.input(0).data)}}e(jt,"kind","isNaN"),e(jt,"inputs",n.in([])),e(jt,"outputs",n.out(["boolean"]));class vt extends n{run(){this.output(0).data=parseFloat(this.input(0).data)}}e(vt,"kind","parseFloat"),e(vt,"inputs",n.in(["string"])),e(vt,"outputs",n.out(["number"]));class Pt extends n{run(){this.output(0).data=parseInt(this.input(0).data)}}e(Pt,"kind","parseInt"),e(Pt,"inputs",n.in(["number","string"])),e(Pt,"outputs",n.out(["number"]));const Ns={[Et.kind]:Et,[Bt.kind]:Bt,[jt.kind]:jt,[vt.kind]:vt,[Pt.kind]:Pt};class $t extends n{run(){this.output(0).data=Object.keys(this.input(0).data)}}e($t,"kind","objectKeys"),e($t,"inputs",n.in(["object"])),e($t,"outputs",n.out(["array"]));class wt extends n{run(){this.output(0).data=Object.values(this.input(0).data)}}e(wt,"kind","objectValues"),e(wt,"inputs",n.in(["object"])),e(wt,"outputs",n.out(["array"]));const Os={[$t.kind]:$t,[wt.kind]:wt};class Ct extends n{run(){this.output(0).data=this.input(0).data+this.input(1).data}}e(Ct,"kind","addition"),e(Ct,"inputs",n.ins(2,["number"])),e(Ct,"outputs",n.out(["number"]));class At extends n{run(){this.input(1).data?this.output(0).data=this.input(0).data/this.input(1).data:this.output(0).clear()}}e(At,"kind","division"),e(At,"inputs",n.ins(2,["number"])),e(At,"outputs",n.out(["number"]));class St extends n{run(){this.output(0).data=this.input(0).data==this.input(1).data}}e(St,"kind","equality"),e(St,"inputs",n.ins(2)),e(St,"outputs",n.out(["boolean"]));class Gt extends n{run(){this.output(0).data=this.input(0).data<this.input(1).data}}e(Gt,"kind","lessThan"),e(Gt,"inputs",n.ins(2,["number"])),e(Gt,"outputs",n.out(["boolean"]));class Rt extends n{run(){this.output(0).data=this.input(0).data<=this.input(1).data}}e(Rt,"kind","lessThanOrEqual"),e(Rt,"inputs",n.ins(2,["number"])),e(Rt,"outputs",n.out(["boolean"]));class Ut extends n{run(){this.output(0).data=this.input(0).data>this.input(1).data}}e(Ut,"kind","greaterThan"),e(Ut,"inputs",n.ins(2,["number"])),e(Ut,"outputs",n.out(["boolean"]));class zt extends n{run(){this.output(0).data=this.input(0).data>=this.input(1).data}}e(zt,"kind","greaterThanOrEqual"),e(zt,"inputs",n.ins(2,["number"])),e(zt,"outputs",n.out(["boolean"]));class Ft extends n{run(){this.output(0).data=this.input(0).data!=this.input(1).data}}e(Ft,"kind","inequality"),e(Ft,"inputs",n.ins(2)),e(Ft,"outputs",n.out(["boolean"]));class Ht extends n{run(){this.output(0).data=this.input(0).data*this.input(1).data}}e(Ht,"kind","multiplication"),e(Ht,"inputs",n.ins(2,["number"])),e(Ht,"outputs",n.out(["number"]));class Kt extends n{run(){this.output(0).data=this.input(0).data-this.input(1).data}}e(Kt,"kind","subtraction"),e(Kt,"inputs",n.ins(2,["number"])),e(Kt,"outputs",n.out(["number"]));const Ts={[Ct.kind]:Ct,[At.kind]:At,[St.kind]:St,[Ut.kind]:Ut,[zt.kind]:zt,[Gt.kind]:Gt,[Rt.kind]:Rt,[Ft.kind]:Ft,[Ht.kind]:Ht,[Kt.kind]:Kt};class Wt extends n{run(){this.output(0).data=this.input(0).data.length}}e(Wt,"kind","stringLength"),e(Wt,"inputs",n.in(["string"])),e(Wt,"outputs",n.out(["number"]));const Es={[Wt.kind]:Wt},Bs=l(l(l(l(l(l(l(l(l(l(l({},gs),ms),ks),fs),Is),bs),xs),Ns),Os),Ts),Es);export{Bs as catalog};
