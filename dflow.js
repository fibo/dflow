const c=n=>`${n} must be a string`,P=n=>`${n} must be a number`,S=(n,t)=>`${t} pin not found nodeId=${n}`,j=(n,t,e)=>`${S(n,t)} position=${e}`,$=(n,t,e)=>`${S(n,t)} pinId=${e}`;class r{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowGraph(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&Array.isArray(t.nodes)&&Array.isArray(t.edges)&&m.isDflowGraph(t)}static isObject(t){return!r.isUndefined(t)&&!r.isNull(t)&&!r.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return r.isString(t)&&t.length>0}static isUndefined(t){return typeof t=="undefined"}static validate(t,e){return e.length===0?!0:e.some(s=>{switch(s){case"array":return r.isArray(t);case"boolean":return r.isBoolean(t);case"null":return r.isNull(t);case"number":return r.isNumber(t);case"object":return r.isObject(t);case"string":return r.isString(t);case"DflowGraph":return r.isDflowGraph(t);default:return!1}},!0)}}class l{id;name;static isDflowItem({id:t,name:e}){return typeof t=="string"&&["undefined","string"].includes(typeof e)}constructor({id:t,name:e}){this.id=t,this.name=e}toJSON(){return JSON.stringify(this.toObject())}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}class h extends l{kind;types;static types=["string","number","boolean","null","object","array","DflowArguments","DflowGraph"];static isDflowPin({types:t=[],...e}){return l.isDflowItem(e)&&t.every(s=>h.isDflowPinType(s))}static isDflowPinType(t){h.types.includes(t)}constructor(t,{types:e=[],...s}){super(s);this.kind=t,this.types=e}get hasTypeAny(){return this.types.length===0}get hasTypeString(){return this.hasTypeAny||this.types.includes("string")}get hasTypeNumber(){return this.hasTypeAny||this.types.includes("number")}get hasTypeBoolean(){return this.hasTypeAny||this.types.includes("boolean")}get hasTypeNull(){return this.hasTypeAny||this.types.includes("null")}get hasTypeObject(){return this.hasTypeAny||this.types.includes("object")}get hasTypeArray(){return this.hasTypeAny||this.types.includes("array")}}class O extends h{#t;static isDflowInput({id:t,types:e}){return h.isDflowPin({id:t,types:e})}constructor(t){super("input",t)}get data(){return this.#t?.data}get isConnected(){return typeof this.#t=="undefined"}connectTo(t){const{hasTypeAny:e,types:s}=this,{types:i}=t;if(e||s.some(o=>i.includes(o)))this.#t=t;else throw new Error(`mismatching pinTypes, source has types [${i.join()}] and target has types [${s.join()}]`)}disconnect(){this.#t=void 0}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}class b extends h{#t;static isDflowOutput({id:t,data:e,types:s=[]}){return h.isDflowPin({id:t,types:s})&&r.validate(e,s)}constructor({data:t,...e}){super("output",e);this.#t=t}clear(){this.#t=void 0}get data(){return this.#t}set data(t){switch(!0){case r.isUndefined(t):this.clear();break;case this.hasTypeAny:case(r.isString(t)&&this.hasTypeString):case(r.isNumber(t)&&this.hasTypeNumber):case(r.isBoolean(t)&&this.hasTypeBoolean):case(r.isNull(t)&&this.hasTypeNull):case(r.isObject(t)&&this.hasTypeObject):case(r.isArray(t)&&this.hasTypeArray):{this.#t=t;break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t={...super.toObject()};return r.isUndefined(this.#t)||(t.data=this.#t),this.types.length>0&&(t.types=this.types),t}}class d extends l{kind;meta;#t=new Map;#e=new Map;#s=[];#n=[];static isDflowNode({kind:t,inputs:e=[],outputs:s=[],...i}){return l.isDflowItem(i)&&r.isStringNotEmpty(t)&&e.every(o=>O.isDflowInput(o))&&s.every(o=>b.isDflowOutput(o))}constructor({kind:t,inputs:e=[],outputs:s=[],...i},{isAsync:o=!1,isConstant:u=!1}={}){super(i);this.kind=t,this.meta={isAsync:o,isConstant:u};for(const a of e)this.newInput(a);for(const a of s)this.newOutput(a)}get inputs(){return this.#t.values()}get outputs(){return this.#e.values()}get numInputs(){return this.#t.size}get numOutputs(){return this.#e.size}generateInputId(t=this.numInputs){const e=`i${t}`;return this.#t.has(e)?this.generateInputId(t+1):e}generateOutputId(t=this.numOutputs){const e=`o${t}`;return this.#e.has(e)?this.generateOutputId(t+1):e}getInputById(t){if(typeof t!="string")throw new TypeError(c("inputId"));const e=this.#t.get(t);if(e instanceof O)return e;throw new Error($(this.id,"input",t))}getInputByPosition(t){if(typeof t!="number")throw new TypeError(P("position"));const e=this.#s[t];if(r.isUndefined(e))throw new Error(j(this.id,"input",t));return this.getInputById(e)}getOutputById(t){if(typeof t!="string")throw new TypeError(c("outputId"));const e=this.#e.get(t);if(e instanceof b)return e;throw new Error($(this.id,"output",t))}getOutputByPosition(t){if(typeof t!="number")throw new TypeError(P("position"));const e=this.#n[t];if(r.isUndefined(e))throw new Error(j(this.id,"output",t));return this.getOutputById(e)}deleteInput(t){this.#t.delete(t),this.#s.splice(this.#s.indexOf(t),1)}deleteOutput(t){this.#e.delete(t),this.#n.splice(this.#n.indexOf(t),1)}newInput(t){const e=r.isStringNotEmpty(t.id)?t.id:this.generateInputId(),s=new O({...t,id:e});return this.#t.set(e,s),this.#s.push(e),s}newOutput(t){const e=r.isStringNotEmpty(t.id)?t.id:this.generateOutputId(),s=new b({...t,id:e});return this.#e.set(e,s),this.#n.push(e),s}run(t){throw new Error(`${this.constructor.name} does not implement a run() method`)}toObject(){const t={...super.toObject(),kind:this.kind},e=[],s=[];for(const i of this.inputs)e.push(i.toObject());e.length>0&&(t.inputs=e);for(const i of this.outputs)s.push(i.toObject());return s.length>0&&(t.outputs=s),t}}class N extends d{static kind="Unknown";constructor(t){super({...t,kind:N.kind})}run(){}}class I extends l{source;target;static isDflowEdge({source:t,target:e,...s},i){return l.isDflowItem(s)&&Array.isArray(t)&&t.length===2&&i.nodes.find(({id:o,outputs:u=[]})=>o===t[0]&&u.find(({id:a})=>a===t[1]))&&Array.isArray(e)&&e.length===2&&i.nodes.find(({id:o,inputs:u=[]})=>o===e[0]&&u.find(({id:a})=>a===e[1]))}constructor({source:t,target:e,...s}){super(s);const[i,o]=t,[u,a]=e;if(typeof i!="string")throw new TypeError(c("sourceNodeId"));if(typeof o!="string")throw new TypeError(c("sourcePinId"));if(typeof u!="string")throw new TypeError(c("targetNodeId"));if(typeof a!="string")throw new TypeError(c("targetPinId"));this.source=t,this.target=e}toObject(){return{...super.toObject(),source:this.source,target:this.target}}}class m extends l{#t="success";#e=new Map;#s=new Map;static isDflowGraph(t){return t.nodes.every(e=>d.isDflowNode(e))&&t.edges.every(e=>I.isDflowEdge(e,t))}static sort(t,e){const s={},i=u=>e.filter(({targetId:a})=>u===a).map(({sourceId:a})=>a),o=u=>{const a=i(u);if(a.length===0)return 0;let k=0;for(const A of a){const T=o(A);k=Math.max(T,k)}return k+1};for(const u of t)s[u]=o(u);return t.slice().sort((u,a)=>s[u]<=s[a]?-1:1)}get edges(){return this.#s.values()}get nodes(){return this.#e.values()}get numEdges(){return this.#s.size}get numNodes(){return this.#e.size}get runStatusIsSuccess(){return this.#t==="success"}get runStatusIsWaiting(){return this.#t==="waiting"}get runStatusIsFailure(){return this.#t==="failure"}addEdge(t){if(this.#s.has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);this.#s.set(t.id,t)}addNode(t){if(this.#e.has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);this.#e.set(t.id,t)}clear(){this.#e.clear(),this.#s.clear()}deleteEdge(t){this.#s.delete(t)}deleteNode(t){this.#e.delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(c("nodeId"));const e=this.#e.get(t);if(e instanceof d)return e;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(c("edgeId"));const e=this.#s.get(t);if(e instanceof I)return e;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const e=`e${t}`;return this.#s.has(e)?this.generateEdgeId(t+1):e}generateNodeId(t=this.numNodes){const e=`n${t}`;return this.#e.has(e)?this.generateNodeId(t+1):e}async run(t){this.runStatusIsSuccess&&(this.#t="waiting");const e=m.sort([...this.#e.keys()],[...this.#s.values()].map(s=>({sourceId:s.source[0],targetId:s.target[0]})));for(const s of e){const i=this.#e.get(s);try{i.meta.isConstant===!1&&(i.meta.isAsync?await i.run(t):i.run(t))}catch(o){console.error(o),this.#t="failure"}}this.runStatusIsWaiting&&(this.#t="success")}toObject(){const t={...super.toObject(),nodes:[],edges:[]};for(const e of this.nodes)t.nodes.push(e.toObject());for(const e of this.edges)t.edges.push(e.toObject());return t}}class bt{#t;#e;constructor(t={}){this.#e=t,this.#t=new m({id:"g1"})}get numEdges(){return this.#t.numEdges}get numNodes(){return this.#t.numNodes}get nodeKinds(){return Object.keys(this.#e)}get runStatusIsSuccess(){return this.#t.runStatusIsSuccess}get runStatusIsWaiting(){return this.#t.runStatusIsWaiting}get runStatusIsFailure(){return this.#t.runStatusIsFailure}clearGraph(){this.#t.clear()}connect(t,e=0){return{to:(s,i=0)=>{const o=this.#t.generateEdgeId(),u=t.getOutputByPosition(e),a=s.getInputByPosition(i);this.newEdge({id:o,source:[t.id,u.id],target:[s.id,a.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(c("edgeId"));const e=this.#t.getEdgeById(t);if(e instanceof I){const[s,i]=e.target;this.getNodeById(s).getInputById(i).disconnect(),this.#t.deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(c("nodeId"));const e=this.getNodeById(t);if(e instanceof d){for(const s of this.#t.edges){const{source:[i],target:[o]}=s;(i===e.id||o===e.id)&&this.deleteEdge(s.id)}this.#t.deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){return this.#t.getEdgeById(t)}getNodeById(t){return this.#t.getNodeById(t)}newNode(t){const e=this.#e[t.kind]??N,s=r.isStringNotEmpty(t.id)?t.id:this.#t.generateNodeId(),i=new e({...t,id:s});return this.#t.addNode(i),i}newEdge(t){const e=r.isStringNotEmpty(t.id)?t.id:this.#t.generateEdgeId(),s=new I({...t,id:e});this.#t.addEdge(s);const[i,o]=s.source,[u,a]=s.target,k=this.#t.getNodeById(i),A=this.#t.getNodeById(u),T=k.getOutputById(o);return A.getInputById(a).connectTo(T),s}newInput(t,e){return this.#t.getNodeById(t).newInput(e)}newOutput(t,e){return this.#t.getNodeById(t).newOutput(e)}toJSON(){return this.#t.toJSON()}toObject(){return this.#t.toObject()}async run(){await this.#t.run(this)}}export{r as DflowData};export{l as DflowItem};export{h as DflowPin};export{O as DflowInput};export{b as DflowOutput};export{d as DflowNode};export{N as DflowUnknownNode};export{I as DflowEdge};export{m as DflowGraph};export{bt as DflowHost};const p=(n,t)=>`unimplemented method ${n} nodeKind=${t}`,Nt=()=>({id:"i1"}),Dt=()=>({id:"o1"}),Et=()=>({id:"i1",types:["array"]}),v=n=>({id:"o1",types:["array"],data:n}),xt=()=>({id:"i1",types:["boolean"]}),g=n=>({id:"o1",types:["boolean"],data:n}),At=()=>({id:"i1",types:["object"]}),Tt=n=>({id:"o1",types:["object"],data:n}),M=()=>({id:"i1",types:["number"]}),f=n=>({id:"o1",types:["number"],data:n}),Bt=n=>({id:"o1",types:["number","string"],data:n}),Pt=()=>({id:"i1",types:["string"]}),St=n=>({id:"o1",types:["string"],data:n}),U=()=>[{id:"1i",types:["boolean"]},{id:"i2",types:["boolean"]}],G=()=>[{id:"1i",types:["number"]},{id:"i2",types:["number"]}];class y extends d{get input(){return this.getInputByPosition(0)}get output(){return this.getOutputByPosition(0)}run(){const{input:{data:t,types:e},output:s,task:i}=this;r.isUndefined(t)?s.clear():r.validate(t,e)&&(s.data=i(t))}task(t){throw new Error(p("task",this.kind))}}class F extends y{constructor(t){super({...t,inputs:[Nt()],outputs:[g()]})}task(t){throw new Error(p("task",this.kind))}}class jt extends y{constructor(t){super({...t,inputs:[Et()],outputs:[f()]})}task(t){throw new Error(p("task",this.kind))}}class L extends y{constructor(t){super({...t,inputs:[At()],outputs:[v()]})}task(t){throw new Error(p("task",this.kind))}}class $t extends y{constructor(t){super({...t,inputs:[M()],outputs:[g()]})}task(t){throw new Error(p("task",this.kind))}}class D extends y{constructor(t){super({...t,inputs:[M()],outputs:[f()]})}task(t){throw new Error(p("task",this.kind))}}class B extends y{constructor(t){super({...t,inputs:[Pt()],outputs:[f()]})}task(t){throw new Error(p("task",this.kind))}}class w extends d{get input1(){return this.getInputByPosition(0)}get input2(){return this.getInputByPosition(1)}get output(){return this.getOutputByPosition(0)}run(){const{input1:{data:t,types:e},input2:{data:s,types:i},output:o,task:u}=this;r.isUndefined(t)||r.isUndefined(s)?o.clear():r.validate(t,e)&&r.validate(s,i)&&(o.data=u(t,s))}task(t,e){throw new Error(p("task",this.kind))}}class E extends w{constructor(t){super({...t,inputs:G(),outputs:[g()]})}task(t,e){throw new Error(p("task",this.kind))}}class C extends w{constructor(t){super({...t,inputs:G(),outputs:[f()]})}task(t,e){throw new Error(p("task",this.kind))}}class q extends jt{static kind="arrayLength";task(t){return t.length}}const vt={[q.kind]:q};class K extends d{static kind="if";constructor(t){super({...t,inputs:[{id:"i1",name:"condition",types:["boolean"]},{id:"i2",name:"then"},{id:"i3",name:"else"}],outputs:[{id:"o1"}]})}run(){const t=this.getInputByPosition(0).data,e=this.getInputByPosition(1).data,s=this.getInputByPosition(2).data,i=this.getOutputByPosition(0);t?i.data=e:i.data=s}}const Mt={[K.kind]:K};class J extends d{static kind="data";constructor(t){super({...t,outputs:[Dt()]})}run(){}}class z extends d{static kind="array";constructor(t){super({...t,outputs:[v()]})}run(){}}class W extends d{static kind="boolean";constructor(t){super({...t,outputs:[g()]})}run(){}}class _ extends d{static kind="number";constructor(t){super({...t,outputs:[f()]})}run(){}}class H extends d{static kind="numberOrString";constructor(t){super({...t,outputs:[Bt()]})}run(){}}class V extends d{static kind="object";constructor(t){super({...t,outputs:[Tt()]})}run(){}}class Q extends d{static kind="string";constructor(t){super({...t,outputs:[St()]})}run(){}}const Ut={[J.kind]:J,[z.kind]:z,[W.kind]:W,[_.kind]:_,[H.kind]:H,[V.kind]:V,[Q.kind]:Q};class R extends d{static kind="dflow";constructor(t){super({...t,outputs:[{id:"o1",name:"nodeKinds",types:["array"]}]})}run(t){const e=this.getOutputByPosition(0);e.data=t.nodeKinds}}class X extends d{static kind="arguments";constructor(t){super({...t,inputs:[{id:"in",types:["number"],name:"signature"}],outputs:[{id:"out",types:["DflowArguments"]}]})}get numArguments(){return this.signature.data??0}get signature(){return this.getInputByPosition(0)}run(){const{numArguments:t,numOutputs:e}=this;switch(!0){case t===0:{for(let s=1;s<e;s++){const i=this.getOutputByPosition(s);this.deleteOutput(i.id)}break}case Number.isInteger(t):{for(let s=e;s>1;s--){const i=this.getOutputByPosition(s);this.deleteOutput(i.id)}for(let s=e-1;s<t;s++)this.newOutput({id:`a${s}`,name:`argument${s}`});break}default:this.getOutputByPosition(0).clear()}}}class Y extends d{static kind="function";constructor(t){super({...t,inputs:[{id:"in1",name:"arguments",types:["DflowArguments"]},{id:"in2",name:"return"}],outputs:[{id:"o1",types:["DflowGraph"]}]})}run(){}}const Gt={[R.kind]:R,[X.kind]:X,[Y.kind]:Y};class Z extends w{static kind="logicAnd";constructor(t){super({...t,inputs:U(),outputs:[g()]})}task(t,e){return t&&e}}class tt extends y{static kind="logicNot";constructor(t){super({...t,inputs:[xt()],outputs:[g()]})}task(t){return!t}}class et extends w{static kind="logicOr";constructor(t){super({...t,inputs:U(),outputs:[g()]})}task(t,e){return t||e}}const Ft={[Z.kind]:Z,[tt.kind]:tt,[et.kind]:et};class st extends D{static kind="mathCos";task(t){return Math.cos(t)}}class nt extends D{static kind="mathCosh";task(t){return Math.cosh(t)}}class x extends d{static kind="mathPI";static metadata={isConstant:!0};constructor(t){super({...t,outputs:[f(Math.PI)]},x.metadata)}}class it extends D{static kind="mathSin";task(t){return Math.sin(t)}}class rt extends D{static kind="mathSinh";task(t){return Math.sinh(t)}}const Lt={[st.kind]:st,[nt.kind]:nt,[x.kind]:x,[it.kind]:it,[rt.kind]:rt};class ot extends $t{static kind="isFinite";task(t){return Number.isFinite(t)}}class ut extends F{static kind="isInteger";task(t){return Number.isInteger(t)}}class at extends F{static kind="isNaN";task(t){return Number.isNaN(t)}}class dt extends B{static kind="parseFloat";task(t){return Number.parseFloat(t)}}class ct extends B{static kind="parseInt";task(t){return Number.parseInt(t)}}const Ct={[ot.kind]:ot,[ut.kind]:ut,[at.kind]:at,[dt.kind]:dt,[ct.kind]:ct};class pt extends L{static kind="objectKeys";task(t){return Object.keys(t)}}class lt extends L{static kind="objectValues";task(t){return Object.values(t)}}const qt={[pt.kind]:pt,[lt.kind]:lt};class ht extends C{static kind="addition";task(t,e){return t+e}}class gt extends w{static kind="equality";constructor(t){super({...t,inputs:[{id:"i1",types:["number","string"]},{id:"i2",types:["number","string"]}],outputs:[{id:"o1",types:["boolean"]}]})}run(){const{input1:{data:t,types:e},input2:{data:s},output:i}=this;r.isUndefined(t)||r.isUndefined(s)?i.clear():r.validate(t,e)&&r.validate(s,e)&&(i.data=t==s)}}class yt extends E{static kind="lessThan";task(t,e){return t<e}}class ft extends E{static kind="lessThanOrEqual";task(t,e){return t<=e}}class wt extends E{static kind="greaterThan";task(t,e){return t>e}}class kt extends E{static kind="greaterThanOrEqual";task(t,e){return t>=e}}class It extends w{static kind="inequality";constructor(t){super({...t,inputs:[{id:"i1",types:["number","string"]},{id:"i2",types:["number","string"]}],outputs:[{id:"o1",types:["boolean"]}]})}run(){const{input1:{data:t,types:e},input2:{data:s},output:i}=this;r.isUndefined(t)||r.isUndefined(s)?i.clear():r.validate(t,e)&&r.validate(s,e)&&(i.data=t!=s)}}class mt extends C{static kind="subtraction";task(t,e){return t-e}}const Kt={[ht.kind]:ht,[gt.kind]:gt,[wt.kind]:wt,[kt.kind]:kt,[yt.kind]:yt,[ft.kind]:ft,[It.kind]:It,[mt.kind]:mt};class Ot extends B{static kind="stringLength";task(t){return t.length}}const Jt={[Ot.kind]:Ot},zt={...vt,...Mt,...Ut,...Gt,...Ft,...Lt,...Ct,...qt,...Kt,...Jt};export{zt as catalog};
