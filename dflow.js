var gs=Object.defineProperty,ms=Object.defineProperties;var ks=Object.getOwnPropertyDescriptors;var Zt=Object.getOwnPropertySymbols;var us=Object.prototype.hasOwnProperty,rs=Object.prototype.propertyIsEnumerable;var ns=(i,t,n)=>t in i?gs(i,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):i[t]=n,l=(i,t)=>{for(var n in t||(t={}))us.call(t,n)&&ns(i,n,t[n]);if(Zt)for(var n of Zt(t))rs.call(t,n)&&ns(i,n,t[n]);return i},I=(i,t)=>ms(i,ks(t));var E=(i,t)=>{var n={};for(var a in i)us.call(i,a)&&t.indexOf(a)<0&&(n[a]=i[a]);if(i!=null&&Zt)for(var a of Zt(i))t.indexOf(a)<0&&rs.call(i,a)&&(n[a]=i[a]);return n};var s=(i,t,n)=>(ns(i,typeof t!="symbol"?t+"":t,n),n),os=(i,t,n)=>{if(!t.has(i))throw TypeError("Cannot "+n)};var u=(i,t,n)=>(os(i,t,"read from private field"),n?n.call(i):t.get(i)),k=(i,t,n)=>{if(t.has(i))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(i):t.set(i,n)},x=(i,t,n,a)=>(os(i,t,"write to private field"),a?a.call(i,n):t.set(i,n),n);var w,Xt,j,v,P,G,R,Yt,f,b,p,z;const N=i=>`${i} must be a string`,ds=i=>`${i} must be a number`,cs=(i,t)=>`${t} pin not found nodeId=${i}`,ps=(i,t,n)=>`${cs(i,t)} position=${n}`,hs=(i,t,n)=>`${cs(i,t)} pinId=${n}`,es=({id:i,kind:t,outputs:n})=>({id:i,kind:t,outputs:n==null?void 0:n.map(({id:a,data:r,name:d})=>({id:a,data:r,name:d}))});class o{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowGraph(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&Array.isArray(t.nodes)&&Array.isArray(t.edges)&&S.isDflowGraph(t)}static isDflowId(t){return o.isStringNotEmpty(t)}static isDflowType(t){return typeof t=="string"&&C.types.includes(t)}static isObject(t){return!o.isUndefined(t)&&!o.isNull(t)&&!o.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return o.isString(t)&&t.length>0}static isUndefined(t){return typeof t>"u"}static validate(t,n){return n.length===0?!0:n.some(a=>{switch(a){case"array":return o.isArray(t);case"boolean":return o.isBoolean(t);case"null":return o.isNull(t);case"number":return o.isNumber(t);case"object":return o.isObject(t);case"string":return o.isString(t);case"DflowGraph":return o.isDflowGraph(t);case"DflowId":return o.isDflowId(t);case"DflowType":return o.isDflowType(t);default:return!1}},!0)}}class ${constructor({id:t,name:n}){s(this,"id");s(this,"name");this.id=t,this.name=n}static isDflowItem({id:t,name:n}){return o.isDflowId(t)&&(o.isUndefined(n)||o.isStringNotEmpty(n))}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const ts=class extends ${constructor(t,r){var d=r,{types:n=[]}=d,a=E(d,["types"]);super(a);s(this,"kind");s(this,"types");this.kind=t,this.types=n}static isDflowPin(a){var r=a,{types:t=[]}=r,n=E(r,["types"]);return $.isDflowItem(n)&&t.every(d=>ts.isDflowPinType(d))}static isDflowPinType(t){ts.types.includes(t)}get hasTypeAny(){return this.types.length===0}get hasTypeDflowId(){return this.hasTypeAny||this.types.includes("DflowId")}get hasTypeDflowGraph(){return this.hasTypeAny||this.types.includes("DflowGraph")}get hasTypeDflowType(){return this.hasTypeAny||this.types.includes("DflowType")}get hasTypeString(){return this.hasTypeAny||this.types.includes("string")}get hasTypeNumber(){return this.hasTypeAny||this.types.includes("number")}get hasTypeBoolean(){return this.hasTypeAny||this.types.includes("boolean")}get hasTypeNull(){return this.hasTypeAny||this.types.includes("null")}get hasTypeObject(){return this.hasTypeAny||this.types.includes("object")}get hasTypeArray(){return this.hasTypeAny||this.types.includes("array")}addType(t){this.types.push(t)}removeType(t){this.types.splice(this.types.indexOf(t),1)}};let C=ts;s(C,"types",["string","number","boolean","null","object","array","DflowId","DflowGraph","DflowType"]);class qt extends C{constructor(a){var r=a,{optional:t}=r,n=E(r,["optional"]);super("input",n);k(this,w,void 0);k(this,Xt,void 0);x(this,Xt,t)}static isDflowInput({id:t,types:n}){return C.isDflowPin({id:t,types:n})}get data(){var t;return(t=u(this,w))==null?void 0:t.data}get isConnected(){return typeof u(this,w)>"u"}get isOptional(){return u(this,Xt)}connectTo(t){const{hasTypeAny:n,types:a}=this,{types:r}=t;if(n||a.some(d=>r.includes(d)))x(this,w,t);else throw new Error(`mismatching pinTypes, source has types [${r.join()}] and target has types [${a.join()}]`)}disconnect(){x(this,w,void 0)}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}w=new WeakMap,Xt=new WeakMap;class Mt extends C{constructor(a){var r=a,{data:t}=r,n=E(r,["data"]);super("output",n);k(this,j,void 0);x(this,j,t)}static isDflowOutput({id:t,data:n,types:a=[]}){return C.isDflowPin({id:t,types:a})&&o.validate(n,a)}clear(){x(this,j,void 0)}get data(){return u(this,j)}set data(t){switch(!0){case o.isUndefined(t):this.clear();break;case this.hasTypeAny:case(o.isDflowGraph(t)&&this.hasTypeDflowGraph):case(o.isDflowId(t)&&this.hasTypeDflowId):case(o.isString(t)&&this.hasTypeString):case(o.isNumber(t)&&this.hasTypeNumber):case(o.isBoolean(t)&&this.hasTypeBoolean):case(o.isNull(t)&&this.hasTypeNull):case(o.isObject(t)&&this.hasTypeObject):case(o.isArray(t)&&this.hasTypeArray):{x(this,j,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=l({},super.toObject());return o.isUndefined(u(this,j))||(t.data=u(this,j)),this.types.length>0&&(t.types=this.types),t}}j=new WeakMap;const ss=class extends ${constructor(g,d,{isAsync:h=!1,isConstant:c=!1,label:y}={}){var O=g,{kind:t,inputs:n=[],outputs:a=[]}=O,r=E(O,["kind","inputs","outputs"]);super(r);k(this,v,new Map);k(this,P,new Map);k(this,G,[]);k(this,R,[]);k(this,Yt,void 0);s(this,"kind");s(this,"meta");s(this,"host");x(this,Yt,y),this.host=d,this.kind=t,this.meta={isAsync:h,isConstant:c};for(const T of n)this.newInput(T);for(const T of a)this.newOutput(T);this.onCreate()}static generateInputIds(t=[]){return t.map((n,a)=>I(l({},n),{id:`i${a}`}))}static generateOutputIds(t=[]){return t.map((n,a)=>I(l({},n),{id:`o${a}`}))}static in(t=[],n){return[l({types:t},n)]}static ins(t,n=[]){return Array(t).fill(ss.in(n)).flat()}static out(t=[],n){return[l({types:t},n)]}static outs(t,n=[]){return Array(t).fill(ss.out(n)).flat()}static outputNumber(t){return I(l({},t),{types:["number"]})}static isDflowNode(d){var h=d,{kind:t,inputs:n=[],outputs:a=[]}=h,r=E(h,["kind","inputs","outputs"]);return $.isDflowItem(r)&&o.isStringNotEmpty(t)&&n.every(c=>qt.isDflowInput(c))&&a.every(c=>Mt.isDflowOutput(c))}get label(){return u(this,Yt)||this.kind}get inputs(){return u(this,v).values()}get outputs(){return u(this,P).values()}get numInputs(){return u(this,v).size}get numOutputs(){return u(this,P).size}generateInputId(t=this.numInputs){const n=`i${t}`;return u(this,v).has(n)?this.generateInputId(t+1):n}generateOutputId(t=this.numOutputs){const n=`o${t}`;return u(this,P).has(n)?this.generateOutputId(t+1):n}getInputById(t){if(typeof t!="string")throw new TypeError(N("inputId"));const n=u(this,v).get(t);if(n instanceof qt)return n;throw new Error(hs(this.id,"input",t))}input(t){if(typeof t!="number")throw new TypeError(ds("position"));const n=u(this,G)[t];if(o.isUndefined(n))throw new Error(ps(this.id,"input",t));return this.getInputById(n)}getOutputById(t){if(typeof t!="string")throw new TypeError(N("outputId"));const n=u(this,P).get(t);if(n instanceof Mt)return n;throw new Error(hs(this.id,"output",t))}output(t){if(typeof t!="number")throw new TypeError(ds("position"));const n=u(this,R)[t];if(o.isUndefined(n))throw new Error(ps(this.id,"output",t));return this.getOutputById(n)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),u(this,v).delete(t),u(this,G).splice(u(this,G).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),u(this,P).delete(t),u(this,R).splice(u(this,R).indexOf(t),1)}onBeforeConnectInput(t,n){}onCreate(){}newInput(t){const n=o.isDflowId(t.id)?t.id:this.generateInputId(),a=new qt(I(l({},t),{id:n}));return u(this,v).set(n,a),u(this,G).push(n),a}newOutput(t){const n=o.isDflowId(t.id)?t.id:this.generateOutputId(),a=new Mt(I(l({},t),{id:n}));return u(this,P).set(n,a),u(this,R).push(n),a}run(){}toObject(){const t=I(l({},super.toObject()),{kind:this.kind}),n=[],a=[];for(const r of this.inputs)n.push(r.toObject());n.length>0&&(t.inputs=n);for(const r of this.outputs)a.push(r.toObject());return a.length>0&&(t.outputs=a),t}};let e=ss;v=new WeakMap,P=new WeakMap,G=new WeakMap,R=new WeakMap,Yt=new WeakMap,s(e,"kind"),s(e,"isAsync"),s(e,"isConstant"),s(e,"label"),s(e,"inputs"),s(e,"outputs");const is=class extends e{constructor(t,n){super(I(l({},t),{kind:is.kind}),n)}run(){}};let Lt=is;s(Lt,"kind","Unknown");class K extends ${constructor(r){var d=r,{source:t,target:n}=d,a=E(d,["source","target"]);super(a);s(this,"source");s(this,"target");const[h,c]=t,[y,g]=n;if(typeof h!="string")throw new TypeError(N("sourceNodeId"));if(typeof c!="string")throw new TypeError(N("sourcePinId"));if(typeof y!="string")throw new TypeError(N("targetNodeId"));if(typeof g!="string")throw new TypeError(N("targetPinId"));this.source=t,this.target=n}static isDflowEdge(d,r){var h=d,{source:t,target:n}=h,a=E(h,["source","target"]);return $.isDflowItem(a)&&Array.isArray(t)&&t.length===2&&r.nodes.find(({id:c,outputs:y=[]})=>c===t[0]&&y.find(({id:g})=>g===t[1]))&&Array.isArray(n)&&n.length===2&&r.nodes.find(({id:c,inputs:y=[]})=>c===n[0]&&y.find(({id:g})=>g===n[1]))}toObject(){return I(l({},super.toObject()),{source:this.source,target:this.target})}}const B=class extends ${constructor(){super(...arguments);k(this,f,new Map);k(this,b,new Map);s(this,"runOptions",{verbose:!1});s(this,"runStatus",null);s(this,"executionReport",null)}static isDflowGraph(t){return t.nodes.every(n=>e.isDflowNode(n))&&t.edges.every(n=>K.isDflowEdge(n,t))}static childrenOfNodeId(t,n){return n.filter(({sourceId:a})=>t===a).map(({targetId:a})=>a)}static parentsOfNodeId(t,n){return n.filter(({targetId:a})=>t===a).map(({sourceId:a})=>a)}static levelOfNodeId(t,n){const a=B.parentsOfNodeId(t,n);if(a.length===0)return 0;let r=0;for(const d of a){const h=B.levelOfNodeId(d,n);r=Math.max(h,r)}return r+1}static ancestorsOfNodeId(t,n){const a=B.parentsOfNodeId(t,n);return a.length===0?[]:a.reduce((r,d,h,c)=>{const y=B.ancestorsOfNodeId(d,n),g=r.concat(y);return h===c.length-1?Array.from(new Set(c.concat(g))):g},[])}static sort(t,n){const a={};for(const r of t)a[r]=B.levelOfNodeId(r,n);return t.slice().sort((r,d)=>a[r]<=a[d]?-1:1)}get edges(){return u(this,b).values()}get nodes(){return u(this,f).values()}get nodeConnections(){return[...u(this,b).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...u(this,b).keys()]}get nodeIds(){return[...u(this,f).keys()]}get numEdges(){return u(this,b).size}get numNodes(){return u(this,f).size}addEdge(t){if(u(this,b).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);u(this,b).set(t.id,t)}addNode(t){if(u(this,f).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);u(this,f).set(t.id,t)}clear(){u(this,f).clear(),u(this,b).clear()}deleteEdge(t){u(this,b).delete(t)}deleteNode(t){u(this,f).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(N("nodeId"));const n=u(this,f).get(t);if(n instanceof e)return n;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(N("edgeId"));const n=u(this,b).get(t);if(n instanceof K)return n;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const n=`e${t}`;return u(this,b).has(n)?this.generateEdgeId(t+1):n}generateNodeId(t=this.numNodes){const n=`n${t}`;return u(this,f).has(n)?this.generateNodeId(t+1):n}nodeIdsInsideFunctions(){const t=[];for(const n of this.nodes)n.kind==="return"&&t.push(B.ancestorsOfNodeId(n.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){var r,d;const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const n=this.nodeIdsInsideFunctions(),a=B.sort(this.nodeIds.filter(h=>!n.includes(h)),this.nodeConnections);s:for(const h of a){const c=u(this,f).get(h);try{if(!c.meta.isConstant){let y=!1;t:for(const{data:g,types:O,isOptional:T}of c.inputs){if(T&&typeof g>"u")continue t;if(!o.validate(g,O)){y=!0;break t}}if(y){for(const g of c.outputs)g.clear();t&&((r=this.executionReport.steps)==null||r.push(es(c.toObject())));continue s}c.meta.isAsync?await c.run():c.run()}t&&((d=this.executionReport.steps)==null||d.push(es(c.toObject())))}catch(y){console.error(y),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=I(l({},super.toObject()),{nodes:[],edges:[]});for(const n of this.nodes)t.nodes.push(n.toObject());for(const n of this.edges)t.edges.push(n.toObject());return t}};let S=B;f=new WeakMap,b=new WeakMap;class fs{constructor(t={}){k(this,p,void 0);k(this,z,void 0);s(this,"context");x(this,z,t),x(this,p,new S({id:"g1"})),this.context={}}get executionReport(){return u(this,p).executionReport}get edges(){return u(this,p).edges}get nodes(){return u(this,p).nodes}get numEdges(){return u(this,p).numEdges}get numNodes(){return u(this,p).numNodes}get nodeKinds(){return Object.keys(u(this,z))}get runStatusIsSuccess(){return u(this,p).runStatus==="success"}get runStatusIsWaiting(){return u(this,p).runStatus==="waiting"}get runStatusIsFailure(){return u(this,p).runStatus==="failure"}set verbose(t){u(this,p).runOptions.verbose=t}clearGraph(){u(this,p).clear()}connect(t,n=0){return{to:(a,r=0)=>{const d=u(this,p).generateEdgeId(),h=t.output(n),c=a.input(r);a.onBeforeConnectInput(t,n),this.newEdge({id:d,source:[t.id,h.id],target:[a.id,c.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(N("edgeId"));const n=u(this,p).getEdgeById(t);if(n instanceof K){const[a,r]=n.target;this.getNodeById(a).getInputById(r).disconnect(),u(this,p).deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(N("nodeId"));const n=this.getNodeById(t);if(n instanceof e){for(const a of u(this,p).edges){const{source:[r],target:[d]}=a;(r===n.id||d===n.id)&&this.deleteEdge(a.id)}u(this,p).deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,n]){for(const a of this.edges){const[r,d]=a.source,[h,c]=a.target;(r===t&&d===n||h===t&&c===n)&&this.deleteEdge(a.id)}}executeFunction(t,n){var g,O,T;const{verbose:a}=u(this,p).runOptions,r=u(this,p).nodeConnections,d=S.childrenOfNodeId(t,r),h=[];for(const F of d){const m=this.getNodeById(F);m.kind==="return"&&h.push(m.id)}const c=h.reduce((F,m,H,ls)=>{const ys=S.ancestorsOfNodeId(m,r),as=F.concat(ys);return H===ls.length?Array.from(new Set(as)):as},[]),y=S.sort([...h,...c],r);for(const F of y){const m=this.getNodeById(F);try{switch(m.kind){case"argument":{const H=Math.max((g=m.input(1).data)!=null?g:0,0);m.output(0).data=n[H];break}case"return":return m.input(1).data;default:!m.meta.isConstant&&!m.meta.isAsync&&m.run(),a&&((T=(O=this.executionReport)==null?void 0:O.steps)==null||T.push(es(m.toObject())))}}catch(H){console.error(H)}}}getEdgeById(t){return u(this,p).getEdgeById(t)}getNodeById(t){return u(this,p).getNodeById(t)}newNode(t){var y;const n=(y=u(this,z)[t.kind])!=null?y:Lt,a=o.isDflowId(t.id)?t.id:u(this,p).generateNodeId(),r={isAsync:n.isAsync,isConstant:n.isConstant,label:n.label},d=Array.isArray(t.inputs)?t.inputs:e.generateInputIds(n.inputs),h=Array.isArray(t.outputs)?t.outputs:e.generateOutputIds(n.outputs),c=new n(I(l({},t),{id:a,inputs:d,outputs:h}),this,r);return u(this,p).addNode(c),c}newEdge(t){const n=o.isDflowId(t.id)?t.id:u(this,p).generateEdgeId(),a=new K(I(l({},t),{id:n}));u(this,p).addEdge(a);const[r,d]=a.source,[h,c]=a.target,y=u(this,p).getNodeById(r),g=u(this,p).getNodeById(h),O=y.getOutputById(d);return g.getInputById(c).connectTo(O),a}newInput(t,n){return u(this,p).getNodeById(t).newInput(n)}newOutput(t,n){return u(this,p).getNodeById(t).newOutput(n)}toObject(){return u(this,p).toObject()}async run(){await u(this,p).run()}}p=new WeakMap,z=new WeakMap;export{o as DflowData};export{$ as DflowItem};export{C as DflowPin};export{qt as DflowInput};export{Mt as DflowOutput};export{e as DflowNode};export{Lt as DflowUnknownNode};export{K as DflowEdge};export{S as DflowGraph};export{fs as DflowHost};class W extends e{run(){const t=this.input(0).data,n=this.input(1).data;this.output(0).data=t.at(n)}}s(W,"kind","arrayAt"),s(W,"inputs",[...e.in(["array"]),...e.in(["number"],{name:"index"})]),s(W,"outputs",e.out());class J extends e{run(){this.output(0).data=this.input(0).data.filter((...t)=>this.host.executeFunction(this.input(1).data,t))}}s(J,"kind","arrayFilter"),s(J,"inputs",[...e.in(["array"]),...e.in(["DflowId"],{name:"functionId"})]),s(J,"outputs",e.out(["array"]));class Q extends e{run(){this.output(0).data=this.input(0).data.findLastIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}s(Q,"kind","arrayFindLastIndex"),s(Q,"inputs",[...e.in(["array"]),...e.in(["DflowId"],{name:"functionId"})]),s(Q,"outputs",e.out(["number"]));class V extends e{run(){this.output(0).data=this.input(0).data.findIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}s(V,"kind","arrayFindIndex"),s(V,"inputs",[...e.in(["array"]),...e.in(["DflowId"],{name:"functionId"})]),s(V,"outputs",e.out(["number"]));class X extends e{run(){const t=this.input(0).data,n=this.input(1).data;Array.isArray(t)&&(this.output(0).data=t.includes(n))}}s(X,"kind","arrayIncludes"),s(X,"inputs",[...e.in(["array"],{name:"array"}),...e.in(["string"],{name:"element"})]),s(X,"outputs",e.out(["boolean"]));class Y extends e{run(){var a;const t=this.input(0).data,n=(a=this.input(1).data)!=null?a:",";Array.isArray(t)&&(this.output(0).data=t.join(n))}}s(Y,"kind","arrayJoin"),s(Y,"inputs",[...e.in(["array"],{name:"array"}),...e.in(["string"],{name:"separator",optional:!0})]),s(Y,"outputs",e.out(["string"]));class Z extends e{run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t.length:this.output(0).clear}}s(Z,"kind","arrayLength"),s(Z,"inputs",e.in(["array"])),s(Z,"outputs",e.out(["number"]));class q extends e{run(){this.output(0).data=this.input(0).data.map((...t)=>this.host.executeFunction(this.input(1).data,t))}}s(q,"kind","arrayMap"),s(q,"inputs",[...e.in(["array"]),...e.in(["DflowId"],{name:"functionId"})]),s(q,"outputs",e.out(["array"]));class M extends e{run(){const t=this.input(0).data.slice(),n=t.pop();this.output(0).data=n,this.output(1).data=t}}s(M,"kind","arrayPop"),s(M,"inputs",e.in(["array"])),s(M,"outputs",[...e.out([],{name:"element"}),...e.out(["array"],{name:"rest"})]);class L extends e{run(){const t=this.input(0).data.slice(),n=this.input(1).data;n&&t.push(n),this.output(0).data=t}}s(L,"kind","arrayPush"),s(L,"inputs",[...e.in(["array"]),...e.in([],{name:"element"})]),s(L,"outputs",e.out(["array"]));class _ extends e{run(){const t=this.input(0).data.slice();this.output(0).data=t.reverse()}}s(_,"kind","arrayReverse"),s(_,"inputs",e.in(["array"])),s(_,"outputs",e.in(["array"]));class D extends e{run(){const t=this.input(0).data.slice(),n=t.shift();this.output(0).data=n,this.output(1).data=t}}s(D,"kind","arrayShift"),s(D,"inputs",e.in(["array"])),s(D,"outputs",[...e.out([],{name:"element"}),...e.out(["array"],{name:"rest"})]);class tt extends e{run(){const t=this.input(0).data,n=this.input(1).data,a=this.input(2).data;typeof a=="number"?this.output(0).data=t.slice(n,a):this.output(0).data=t.slice(n)}}s(tt,"kind","arraySlice"),s(tt,"inputs",[...e.in(["array"]),...e.in(["number"],{name:"start"}),...e.in(["number"],{name:"end",optional:!0})]),s(tt,"outputs",e.out(["array"]));const bs={[W.kind]:W,[J.kind]:J,[Q.kind]:Q,[V.kind]:V,[X.kind]:X,[Y.kind]:Y,[Z.kind]:Z,[q.kind]:q,[M.kind]:M,[L.kind]:L,[_.kind]:_,[D.kind]:D,[tt.kind]:tt};class st extends e{run(){this.output(0).data=this.input(0).data?this.input(1).data:this.input(2).data}}s(st,"kind","if"),s(st,"inputs",[...e.in(["boolean"],{name:"condition"}),...e.in([],{name:"then"}),...e.in([],{name:"else"})]),s(st,"outputs",e.out());const Is={[st.kind]:st};class _t extends e{run(){console.log(this.input(0).data)}}s(_t,"kind","consoleLog"),s(_t,"inputs",[...e.in([])]);const xs={[_t.kind]:_t};class Dt extends e{run(){this.output(0).data=Date.now()}}s(Dt,"kind","now"),s(Dt,"outputs",e.out(["number"]));const Ns={[Dt.kind]:Dt};class nt extends e{}s(nt,"kind","data"),s(nt,"isConstant",!0),s(nt,"outputs",e.out());class et extends e{run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t:this.output(0).clear()}}s(et,"kind","array"),s(et,"inputs",e.in()),s(et,"outputs",e.out(["array"]));class it extends e{run(){const t=this.input(0).data;typeof t=="boolean"?this.output(0).data=t:this.output(0).clear()}}s(it,"kind","boolean"),s(it,"inputs",e.in()),s(it,"outputs",e.out(["boolean"]));class at extends e{run(){const t=this.input(0).data;typeof t=="number"?this.output(0).data=t:this.output(0).clear()}}s(at,"kind","number"),s(at,"inputs",e.in()),s(at,"outputs",e.out(["number"]));class ut extends e{run(){const t=this.input(0).data;typeof t=="object"&&t!==null?this.output(0).data=t:this.output(0).clear()}}s(ut,"kind","object"),s(ut,"inputs",e.in()),s(ut,"outputs",e.out(["object"]));class rt extends e{run(){const t=this.input(0).data;typeof t=="string"?this.output(0).data=t:this.output(0).clear()}}s(rt,"kind","string"),s(rt,"inputs",e.in()),s(rt,"outputs",e.out(["string"]));class ot extends e{run(){const t=this.input(0).data;this.output(0).data=Array.isArray(t)}}s(ot,"kind","isArray"),s(ot,"inputs",e.out()),s(ot,"outputs",e.out(["boolean"]));class dt extends e{run(){const t=this.input(0).data;this.output(0).data=typeof t<"u"}}s(dt,"kind","isDefined"),s(dt,"inputs",e.in()),s(dt,"outputs",e.out(["boolean"]));class ct extends e{run(){const t=this.input(0).data;this.output(0).data=typeof t>"u"}}s(ct,"kind","isUndefined"),s(ct,"inputs",e.in()),s(ct,"outputs",e.out(["boolean"]));const Os={[nt.kind]:nt,[dt.kind]:dt,[ct.kind]:ct,[et.kind]:et,[it.kind]:it,[at.kind]:at,[ut.kind]:ut,[rt.kind]:rt,[ot.kind]:ot};class A extends e{run(){const t=this.output(0);t.data=this.host.nodeKinds}}s(A,"kind","dflow"),s(A,"outputs",e.out(["array"],{name:"nodeKinds"}));class pt extends e{}s(pt,"kind","comment"),s(pt,"isConstant",!0),s(pt,"outputs",e.out(["string"]));class ht extends e{}s(ht,"kind","typeNumber"),s(ht,"isConstant",!0),s(ht,"outputs",e.out(["DflowType"],{name:"number",data:"number"}));class U extends e{onBeforeConnectInput(t,n){const a=t.output(n).data;this.output(0).addType(a)}}s(U,"kind","argument"),s(U,"isConstant",!0),s(U,"inputs",[...e.in(["DflowType"],{name:"type"}),...e.in(["number"],{name:"argumentPosition"})]),s(U,"outputs",e.out());class lt extends e{onCreate(){this.output(0).data=this.id}}s(lt,"kind","function"),s(lt,"isConstant",!0),s(lt,"outputs",A.out(["DflowId"],{name:"id"}));class yt extends e{}s(yt,"kind","return"),s(yt,"isConstant",!0),s(yt,"inputs",[...A.in(["DflowId"],{name:"functionId"}),...A.in([],{name:"value"})]);const Ts={[A.kind]:A,[U.kind]:U,[pt.kind]:pt,[lt.kind]:lt,[yt.kind]:yt,[ht.kind]:ht};class gt extends e{run(){this.output(0).data=this.input(0).data&&this.input(1).data}}s(gt,"kind","and"),s(gt,"inputs",e.ins(2,["boolean"])),s(gt,"outputs",e.out(["boolean"]));class mt extends e{run(){this.output(0).data=!this.input(0).data}}s(mt,"kind","not"),s(mt,"inputs",e.in(["boolean"])),s(mt,"outputs",e.out(["boolean"]));class kt extends e{run(){this.output(0).data=this.input(0).data||this.input(1).data}}s(kt,"kind","or"),s(kt,"inputs",e.ins(2,["boolean"])),s(kt,"outputs",e.out(["boolean"]));const Es={[gt.kind]:gt,[mt.kind]:mt,[kt.kind]:kt};class ft extends e{run(){this.output(0).data=Math.abs(this.input(0).data)}}s(ft,"kind","mathAbs"),s(ft,"inputs",e.in(["number"])),s(ft,"outputs",e.out(["number"]));class bt extends e{run(){this.output(0).data=Math.cos(this.input(0).data)}}s(bt,"kind","mathCos"),s(bt,"inputs",e.in(["number"])),s(bt,"outputs",e.out(["number"]));class It extends e{run(){this.output(0).data=Math.cosh(this.input(0).data)}}s(It,"kind","mathCosh"),s(It,"inputs",e.in(["number"])),s(It,"outputs",e.out(["number"]));class xt extends e{run(){this.output(0).data=Math.floor(this.input(0).data)}}s(xt,"kind","mathFloor"),s(xt,"inputs",e.in(["number"])),s(xt,"outputs",e.out(["number"]));class Nt extends e{run(){const t=this.input(0).data,n=Math.max(...t);isNaN(n)?this.output(0).clear():this.output(0).data=n}}s(Nt,"kind","mathMax"),s(Nt,"inputs",e.in(["array"])),s(Nt,"outputs",e.out(["number"]));class Ot extends e{run(){const t=this.input(0).data,n=Math.min(...t);isNaN(n)?this.output(0).clear():this.output(0).data=n}}s(Ot,"kind","mathMin"),s(Ot,"inputs",e.in(["array"])),s(Ot,"outputs",e.out(["number"]));class Tt extends e{}s(Tt,"kind","mathPI"),s(Tt,"isConstant",!0),s(Tt,"outputs",e.out(["number"],{name:"\u03C0",data:Math.PI}));class Et extends e{run(){this.output(0).data=Math.round(this.input(0).data)}}s(Et,"kind","mathRound"),s(Et,"inputs",e.in(["number"])),s(Et,"outputs",e.out(["number"]));class Bt extends e{run(){this.output(0).data=Math.sin(this.input(0).data)}}s(Bt,"kind","mathSin"),s(Bt,"inputs",e.in(["number"])),s(Bt,"outputs",e.out(["number"]));class jt extends e{run(){this.output(0).data=Math.sinh(this.input(0).data)}}s(jt,"kind","mathSinh"),s(jt,"inputs",e.in(["number"])),s(jt,"outputs",e.out(["number"]));const Bs={[ft.kind]:ft,[bt.kind]:bt,[It.kind]:It,[xt.kind]:xt,[Nt.kind]:Nt,[Ot.kind]:Ot,[Tt.kind]:Tt,[Et.kind]:Et,[Bt.kind]:Bt,[jt.kind]:jt};class vt extends e{run(){this.output(0).data=Number.isFinite(this.input(0).data)}}s(vt,"kind","isFinite"),s(vt,"inputs",e.in(["number"])),s(vt,"outputs",e.out(["boolean"]));class Pt extends e{run(){this.output(0).data=Number.isInteger(this.input(0).data)}}s(Pt,"kind","isInteger"),s(Pt,"inputs",e.in([])),s(Pt,"outputs",e.out(["boolean"]));class $t extends e{run(){this.output(0).data=Number.isNaN(this.input(0).data)}}s($t,"kind","isNaN"),s($t,"inputs",e.in([])),s($t,"outputs",e.out(["boolean"]));class Ct extends e{run(){this.output(0).data=parseFloat(this.input(0).data)}}s(Ct,"kind","parseFloat"),s(Ct,"inputs",e.in(["string"])),s(Ct,"outputs",e.out(["number"]));class St extends e{run(){this.output(0).data=parseInt(this.input(0).data)}}s(St,"kind","parseInt"),s(St,"inputs",e.in(["number","string"])),s(St,"outputs",e.out(["number"]));const js={[vt.kind]:vt,[Pt.kind]:Pt,[$t.kind]:$t,[Ct.kind]:Ct,[St.kind]:St};class At extends e{run(){this.output(0).data=Object.keys(this.input(0).data)}}s(At,"kind","objectKeys"),s(At,"inputs",e.in(["object"])),s(At,"outputs",e.out(["array"]));class wt extends e{run(){this.output(0).data=Object.values(this.input(0).data)}}s(wt,"kind","objectValues"),s(wt,"inputs",e.in(["object"])),s(wt,"outputs",e.out(["array"]));const vs={[At.kind]:At,[wt.kind]:wt};class Gt extends e{run(){this.output(0).data=this.input(0).data+this.input(1).data}}s(Gt,"kind","addition"),s(Gt,"inputs",e.ins(2,["number"])),s(Gt,"outputs",e.out(["number"]));class Rt extends e{run(){this.input(1).data?this.output(0).data=this.input(0).data/this.input(1).data:this.output(0).clear()}}s(Rt,"kind","division"),s(Rt,"inputs",e.ins(2,["number"])),s(Rt,"outputs",e.out(["number"]));class Ut extends e{run(){this.output(0).data=this.input(0).data==this.input(1).data}}s(Ut,"kind","equality"),s(Ut,"inputs",e.ins(2)),s(Ut,"outputs",e.out(["boolean"]));class zt extends e{run(){this.output(0).data=this.input(0).data<this.input(1).data}}s(zt,"kind","lessThan"),s(zt,"inputs",e.ins(2,["number"])),s(zt,"outputs",e.out(["boolean"]));class Ft extends e{run(){this.output(0).data=this.input(0).data<=this.input(1).data}}s(Ft,"kind","lessThanOrEqual"),s(Ft,"inputs",e.ins(2,["number"])),s(Ft,"outputs",e.out(["boolean"]));class Ht extends e{run(){this.output(0).data=this.input(0).data>this.input(1).data}}s(Ht,"kind","greaterThan"),s(Ht,"inputs",e.ins(2,["number"])),s(Ht,"outputs",e.out(["boolean"]));class Kt extends e{run(){this.output(0).data=this.input(0).data>=this.input(1).data}}s(Kt,"kind","greaterThanOrEqual"),s(Kt,"inputs",e.ins(2,["number"])),s(Kt,"outputs",e.out(["boolean"]));class Wt extends e{run(){this.output(0).data=this.input(0).data!=this.input(1).data}}s(Wt,"kind","inequality"),s(Wt,"inputs",e.ins(2)),s(Wt,"outputs",e.out(["boolean"]));class Jt extends e{run(){this.output(0).data=this.input(0).data*this.input(1).data}}s(Jt,"kind","multiplication"),s(Jt,"inputs",e.ins(2,["number"])),s(Jt,"outputs",e.out(["number"]));class Qt extends e{run(){this.output(0).data=this.input(0).data-this.input(1).data}}s(Qt,"kind","subtraction"),s(Qt,"inputs",e.ins(2,["number"])),s(Qt,"outputs",e.out(["number"]));const Ps={[Gt.kind]:Gt,[Rt.kind]:Rt,[Ut.kind]:Ut,[Ht.kind]:Ht,[Kt.kind]:Kt,[zt.kind]:zt,[Ft.kind]:Ft,[Wt.kind]:Wt,[Jt.kind]:Jt,[Qt.kind]:Qt};class Vt extends e{run(){this.output(0).data=this.input(0).data.length}}s(Vt,"kind","stringLength"),s(Vt,"inputs",e.in(["string"])),s(Vt,"outputs",e.out(["number"]));const $s={[Vt.kind]:Vt},Cs=l(l(l(l(l(l(l(l(l(l(l(l({},bs),Is),xs),Os),Ns),Ts),Es),Bs),js),vs),Ps),$s);export{Cs as catalog};
