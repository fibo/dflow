const l=i=>`${i} must be a string`,pt=(i,t)=>`unimplemented method ${i} nodeKind=${t}`,D=i=>`${i} must be a number`,O=(i,t)=>`${t} pin not found nodeId=${i}`,E=(i,t,s)=>`${O(i,t)} position=${s}`,x=(i,t,s)=>`${O(i,t)} pinId=${s}`;class o{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowGraph(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&Array.isArray(t.nodes)&&Array.isArray(t.edges)&&h.isDflowGraph(t)}static isDflowId(t){return o.isStringNotEmpty(t)}static isDflowType(t){return typeof t=="string"&&f.types.includes(t)}static isObject(t){return!o.isUndefined(t)&&!o.isNull(t)&&!o.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return o.isString(t)&&t.length>0}static isUndefined(t){return typeof t=="undefined"}static validate(t,s){return s.length===0?!0:s.some(n=>{switch(n){case"array":return o.isArray(t);case"boolean":return o.isBoolean(t);case"null":return o.isNull(t);case"number":return o.isNumber(t);case"object":return o.isObject(t);case"string":return o.isString(t);case"DflowGraph":return o.isDflowGraph(t);case"DflowId":return o.isDflowId(t);case"DflowType":return o.isDflowType(t);default:return!1}},!0)}}class g{id;name;static isDflowItem({id:t,name:s}){return o.isDflowId(t)&&(o.isUndefined(s)||o.isStringNotEmpty(s))}constructor({id:t,name:s}){this.id=t,this.name=s}toJSON(){return JSON.stringify(this.toObject())}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}class f extends g{kind;types;static types=["string","number","boolean","null","object","array","DflowId","DflowGraph","DflowType"];static isDflowPin({types:t=[],...s}){return g.isDflowItem(s)&&t.every(n=>f.isDflowPinType(n))}static isDflowPinType(t){f.types.includes(t)}constructor(t,{types:s=[],...n}){super(n);this.kind=t,this.types=s}get hasTypeAny(){return this.types.length===0}get hasTypeDflowId(){return this.hasTypeAny||this.types.includes("DflowId")}get hasTypeDflowGraph(){return this.hasTypeAny||this.types.includes("DflowGraph")}get hasTypeDflowType(){return this.hasTypeAny||this.types.includes("DflowType")}get hasTypeString(){return this.hasTypeAny||this.types.includes("string")}get hasTypeNumber(){return this.hasTypeAny||this.types.includes("number")}get hasTypeBoolean(){return this.hasTypeAny||this.types.includes("boolean")}get hasTypeNull(){return this.hasTypeAny||this.types.includes("null")}get hasTypeObject(){return this.hasTypeAny||this.types.includes("object")}get hasTypeArray(){return this.hasTypeAny||this.types.includes("array")}addType(t){this.types.push(t)}removeType(t){this.types.splice(this.types.indexOf(t),1)}}class k extends f{#t;static isDflowInput({id:t,types:s}){return f.isDflowPin({id:t,types:s})}constructor(t){super("input",t)}get data(){return this.#t?.data}get isConnected(){return typeof this.#t=="undefined"}connectTo(t){const{hasTypeAny:s,types:n}=this,{types:r}=t;if(s||n.some(a=>r.includes(a)))this.#t=t;else throw new Error(`mismatching pinTypes, source has types [${r.join()}] and target has types [${n.join()}]`)}disconnect(){this.#t=void 0}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}class m extends f{#t;static isDflowOutput({id:t,data:s,types:n=[]}){return f.isDflowPin({id:t,types:n})&&o.validate(s,n)}constructor({data:t,...s}){super("output",s);this.#t=t}clear(){this.#t=void 0}get data(){return this.#t}set data(t){switch(!0){case o.isUndefined(t):this.clear();break;case this.hasTypeAny:case(o.isDflowGraph(t)&&this.hasTypeDflowGraph):case(o.isDflowId(t)&&this.hasTypeDflowId):case(o.isString(t)&&this.hasTypeString):case(o.isNumber(t)&&this.hasTypeNumber):case(o.isBoolean(t)&&this.hasTypeBoolean):case(o.isNull(t)&&this.hasTypeNull):case(o.isObject(t)&&this.hasTypeObject):case(o.isArray(t)&&this.hasTypeArray):{this.#t=t;break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t={...super.toObject()};return o.isUndefined(this.#t)||(t.data=this.#t),this.types.length>0&&(t.types=this.types),t}}class e extends g{#t=new Map;#s=new Map;#e=[];#n=[];#i;kind;meta;host;static Task=class extends e{task(){throw new Error(pt("task",this.kind))}run(){for(const{data:s,types:n}of this.inputs)if(o.isUndefined(s)||!o.validate(s,n)){this.output(0).clear();return}this.output(0).data=this.task()}};static kind;static isAsync;static isConstant;static label;static inputs;static outputs;static generateInputIds(t=[]){return t.map((s,n)=>({...s,id:`i${n}`}))}static generateOutputIds(t=[]){return t.map((s,n)=>({...s,id:`o${n}`}))}static in(t=[],s){return[{types:t,...s}]}static ins(t,s=[]){return Array(t).fill(e.in(s)).flat()}static out(t=[],s){return[{types:t,...s}]}static outs(t,s=[]){return Array(t).fill(e.out(s)).flat()}static outputNumber(t){return{...t,types:["number"]}}static isDflowNode({kind:t,inputs:s=[],outputs:n=[],...r}){return g.isDflowItem(r)&&o.isStringNotEmpty(t)&&s.every(a=>k.isDflowInput(a))&&n.every(a=>m.isDflowOutput(a))}constructor({kind:t,inputs:s=[],outputs:n=[],...r},a,{isAsync:u=!1,isConstant:d=!1,label:p}={}){super(r);this.#i=p,this.host=a,this.kind=t,this.meta={isAsync:u,isConstant:d};for(const c of s)this.newInput(c);for(const c of n)this.newOutput(c);this.onCreate()}get label(){return this.#i||this.kind}get inputs(){return this.#t.values()}get outputs(){return this.#s.values()}get numInputs(){return this.#t.size}get numOutputs(){return this.#s.size}generateInputId(t=this.numInputs){const s=`i${t}`;return this.#t.has(s)?this.generateInputId(t+1):s}generateOutputId(t=this.numOutputs){const s=`o${t}`;return this.#s.has(s)?this.generateOutputId(t+1):s}getInputById(t){if(typeof t!="string")throw new TypeError(l("inputId"));const s=this.#t.get(t);if(s instanceof k)return s;throw new Error(x(this.id,"input",t))}input(t){if(typeof t!="number")throw new TypeError(D("position"));const s=this.#e[t];if(o.isUndefined(s))throw new Error(E(this.id,"input",t));return this.getInputById(s)}getOutputById(t){if(typeof t!="string")throw new TypeError(l("outputId"));const s=this.#s.get(t);if(s instanceof m)return s;throw new Error(x(this.id,"output",t))}output(t){if(typeof t!="number")throw new TypeError(D("position"));const s=this.#n[t];if(o.isUndefined(s))throw new Error(E(this.id,"output",t));return this.getOutputById(s)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),this.#t.delete(t),this.#e.splice(this.#e.indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),this.#s.delete(t),this.#n.splice(this.#n.indexOf(t),1)}onBeforeConnectInput(t,s){}onCreate(){}newInput(t){const s=o.isDflowId(t.id)?t.id:this.generateInputId(),n=new k({...t,id:s});return this.#t.set(s,n),this.#e.push(s),n}newOutput(t){const s=o.isDflowId(t.id)?t.id:this.generateOutputId(),n=new m({...t,id:s});return this.#s.set(s,n),this.#n.push(s),n}run(){throw new Error(`${this.constructor.name} does not implement a run() method`)}toObject(){const t={...super.toObject(),kind:this.kind},s=[],n=[];for(const r of this.inputs)s.push(r.toObject());s.length>0&&(t.inputs=s);for(const r of this.outputs)n.push(r.toObject());return n.length>0&&(t.outputs=n),t}}class b extends e{static kind="Unknown";constructor(t,s){super({...t,kind:b.kind},s)}run(){}}class w extends g{source;target;static isDflowEdge({source:t,target:s,...n},r){return g.isDflowItem(n)&&Array.isArray(t)&&t.length===2&&r.nodes.find(({id:a,outputs:u=[]})=>a===t[0]&&u.find(({id:d})=>d===t[1]))&&Array.isArray(s)&&s.length===2&&r.nodes.find(({id:a,inputs:u=[]})=>a===s[0]&&u.find(({id:d})=>d===s[1]))}constructor({source:t,target:s,...n}){super(n);const[r,a]=t,[u,d]=s;if(typeof r!="string")throw new TypeError(l("sourceNodeId"));if(typeof a!="string")throw new TypeError(l("sourcePinId"));if(typeof u!="string")throw new TypeError(l("targetNodeId"));if(typeof d!="string")throw new TypeError(l("targetPinId"));this.source=t,this.target=s}toObject(){return{...super.toObject(),source:this.source,target:this.target}}}class h extends g{#t="success";#s=new Map;#e=new Map;static isDflowGraph(t){return t.nodes.every(s=>e.isDflowNode(s))&&t.edges.every(s=>w.isDflowEdge(s,t))}static childrenOfNodeId(t,s){return s.filter(({sourceId:n})=>t===n).map(({targetId:n})=>n)}static parentsOfNodeId(t,s){return s.filter(({targetId:n})=>t===n).map(({sourceId:n})=>n)}static levelOfNodeId(t,s){const n=h.parentsOfNodeId(t,s);if(n.length===0)return 0;let r=0;for(const a of n){const u=h.levelOfNodeId(a,s);r=Math.max(u,r)}return r+1}static ancestorsOfNodeId(t,s){const n=h.parentsOfNodeId(t,s);return n.length===0?[]:n.reduce((r,a,u,d)=>{const p=h.ancestorsOfNodeId(a,s),c=r.concat(p);return u===d.length-1?Array.from(new Set(d.concat(c))):c},[])}static sort(t,s){const n={};for(const r of t)n[r]=h.levelOfNodeId(r,s);return t.slice().sort((r,a)=>n[r]<=n[a]?-1:1)}get edges(){return this.#e.values()}get nodes(){return this.#s.values()}get nodeConnections(){return[...this.#e.values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...this.#e.keys()]}get nodeIds(){return[...this.#s.keys()]}get numEdges(){return this.#e.size}get numNodes(){return this.#s.size}get runStatusIsSuccess(){return this.#t==="success"}get runStatusIsWaiting(){return this.#t==="waiting"}get runStatusIsFailure(){return this.#t==="failure"}addEdge(t){if(this.#e.has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);this.#e.set(t.id,t)}addNode(t){if(this.#s.has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);this.#s.set(t.id,t)}clear(){this.#s.clear(),this.#e.clear()}deleteEdge(t){this.#e.delete(t)}deleteNode(t){this.#s.delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(l("nodeId"));const s=this.#s.get(t);if(s instanceof e)return s;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(l("edgeId"));const s=this.#e.get(t);if(s instanceof w)return s;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const s=`e${t}`;return this.#e.has(s)?this.generateEdgeId(t+1):s}generateNodeId(t=this.numNodes){const s=`n${t}`;return this.#s.has(s)?this.generateNodeId(t+1):s}nodeIdsInsideFunctions(){const t=[];for(const s of this.nodes)s.kind==="return"&&t.push(h.ancestorsOfNodeId(s.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){this.runStatusIsSuccess&&(this.#t="waiting");const t=this.nodeIdsInsideFunctions(),s=h.sort(this.nodeIds.filter(n=>!t.includes(n)),this.nodeConnections);for(const n of s){const r=this.#s.get(n);try{r.meta.isConstant===!1&&(r.meta.isAsync?await r.run():r.run())}catch(a){console.error(a),this.#t="failure"}}this.runStatusIsWaiting&&(this.#t="success")}toObject(){const t={...super.toObject(),nodes:[],edges:[]};for(const s of this.nodes)t.nodes.push(s.toObject());for(const s of this.edges)t.edges.push(s.toObject());return t}}class lt{#t;#s;constructor(t={}){this.#s=t,this.#t=new h({id:"g1"})}get edges(){return this.#t.edges}get nodes(){return this.#t.nodes}get numEdges(){return this.#t.numEdges}get numNodes(){return this.#t.numNodes}get nodeKinds(){return Object.keys(this.#s)}get runStatusIsSuccess(){return this.#t.runStatusIsSuccess}get runStatusIsWaiting(){return this.#t.runStatusIsWaiting}get runStatusIsFailure(){return this.#t.runStatusIsFailure}clearGraph(){this.#t.clear()}connect(t,s=0){return{to:(n,r=0)=>{const a=this.#t.generateEdgeId(),u=t.output(s),d=n.input(r);n.onBeforeConnectInput(t,s),this.newEdge({id:a,source:[t.id,u.id],target:[n.id,d.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(l("edgeId"));const s=this.#t.getEdgeById(t);if(s instanceof w){const[n,r]=s.target;this.getNodeById(n).getInputById(r).disconnect(),this.#t.deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(l("nodeId"));const s=this.getNodeById(t);if(s instanceof e){for(const n of this.#t.edges){const{source:[r],target:[a]}=n;(r===s.id||a===s.id)&&this.deleteEdge(n.id)}this.#t.deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,s]){for(const n of this.edges){const[r,a]=n.source,[u,d]=n.target;(r===t&&a===s||u===t&&d===s)&&this.deleteEdge(n.id)}}async executeFunction(t,s){const n=this.#t.nodeConnections,r=h.childrenOfNodeId(t,n),a=[];for(const p of r){const c=this.getNodeById(p);c.kind==="return"&&a.push(c.id)}const u=a.reduce((p,c,y,T)=>{const ht=h.ancestorsOfNodeId(c,n),N=p.concat(ht);return y===T.length?Array.from(new Set(N)):N},[]),d=h.sort(u,n);for(const p of d){const c=this.getNodeById(p);try{switch(c.kind){case"argument":{const y=0;c.output(0).data=s[y];break}case"return":return c.input(1).data;default:c.meta.isConstant===!1&&(c.meta.isAsync?await c.run():c.run())}}catch(y){console.error(y)}}}getEdgeById(t){return this.#t.getEdgeById(t)}getNodeById(t){return this.#t.getNodeById(t)}newNode(t){const s=this.#s[t.kind]??b,n=o.isDflowId(t.id)?t.id:this.#t.generateNodeId(),r={isAsync:s.isAsync,isConstant:s.isConstant,label:s.label},a=Array.isArray(t.inputs)?t.inputs:e.generateInputIds(s.inputs),u=Array.isArray(t.outputs)?t.outputs:e.generateOutputIds(s.outputs),d=new s({...t,id:n,inputs:a,outputs:u},this,r);return this.#t.addNode(d),d}newEdge(t){const s=o.isDflowId(t.id)?t.id:this.#t.generateEdgeId(),n=new w({...t,id:s});this.#t.addEdge(n);const[r,a]=n.source,[u,d]=n.target,p=this.#t.getNodeById(r),c=this.#t.getNodeById(u),y=p.getOutputById(a);return c.getInputById(d).connectTo(y),n}newInput(t,s){return this.#t.getNodeById(t).newInput(s)}newOutput(t,s){return this.#t.getNodeById(t).newOutput(s)}toJSON(){return this.#t.toJSON()}toObject(){return this.#t.toObject()}async run(){await this.#t.run()}}export{o as DflowData};export{g as DflowItem};export{f as DflowPin};export{k as DflowInput};export{m as DflowOutput};export{e as DflowNode};export{b as DflowUnknownNode};export{w as DflowEdge};export{h as DflowGraph};export{lt as DflowHost};class A extends e.Task{static kind="arrayFilter";static inputs=[...e.in(["array"]),...e.in(["DflowId"],{name:"functionId"})];static outputs=e.out(["array"]);task(){return this.input(0).data.filter((...t)=>this.host.executeFunction(this.input(1).data,t))}}class S extends e.Task{static kind="arrayLength";static inputs=e.in(["array"]);static outputs=e.out(["number"]);task(){return this.input(0).data.length}}const ft={[A.kind]:A,[S.kind]:S};class C extends e{static kind="if";constructor(t,s){super({...t,inputs:[{id:"i1",name:"condition",types:["boolean"]},{id:"i2",name:"then"},{id:"i3",name:"else"}],outputs:[{id:"o1"}]},s)}run(){const t=this.input(0).data,s=this.input(1).data,n=this.input(2).data,r=this.output(0);t?r.data=s:r.data=n}}const gt={[C.kind]:C};class P extends e{static kind="data";static outputs=e.out();static isConstant=!0}class j extends e{static kind="array";static outputs=e.out(["array"]);static isConstant=!0}class B extends e{static kind="boolean";static outputs=e.out(["boolean"]);static isConstant=!0}class $ extends e{static kind="number";static outputs=e.out(["number"]);static isConstant=!0}class v extends e{static kind="object";static outputs=e.out(["object"]);static isConstant=!0}class F extends e{static kind="string";static outputs=e.out(["string"]);static isConstant=!0}const yt={[P.kind]:P,[j.kind]:j,[B.kind]:B,[$.kind]:$,[v.kind]:v,[F.kind]:F};class I extends e{static kind="dflow";static outputs=e.out(["array"],{name:"nodeKinds"});run(){const t=this.output(0);t.data=this.host.nodeKinds}}class M extends e{static kind="typeNumber";static isConstant=!0;static outputs=e.out(["DflowType"],{name:"number",data:"number"})}class U extends e{static kind="argument";static isConstant=!0;static inputs=[...e.in(["DflowType"],{name:"type"})];static outputs=e.out();onBeforeConnectInput(t,s){const n=t.output(s).data;this.output(0).addType(n)}}class L extends e{static kind="function";static isConstant=!0;static outputs=I.out(["DflowId"],{name:"id"});onCreate(){this.output(0).data=this.id}}class q extends e{static kind="return";static isConstant=!0;static inputs=[...I.in(["DflowId"],{name:"functionId"}),...I.in([],{name:"value"})]}const wt={[I.kind]:I,[U.kind]:U,[L.kind]:L,[q.kind]:q,[M.kind]:M};class G extends e.Task{static kind="and";static inputs=e.ins(2,["boolean"]);static outputs=e.out(["boolean"]);task(){return this.input(0).data&&this.input(1).data}}class K extends e.Task{static kind="not";static inputs=e.in(["boolean"]);static outputs=e.out(["boolean"]);task(){return!this.input(0).data}}class J extends e.Task{static kind="or";static inputs=e.ins(2,["boolean"]);static outputs=e.out(["boolean"]);task(){return this.input(0).data||this.input(1).data}}const It={[G.kind]:G,[K.kind]:K,[J.kind]:J};class z extends e.Task{static kind="mathCos";static inputs=e.in(["number"]);static outputs=e.out(["number"]);task(){return Math.cos(this.input(0).data)}}class W extends e.Task{static kind="mathCosh";static inputs=e.in(["number"]);static outputs=e.out(["number"]);task(){return Math.cosh(this.input(0).data)}}class H extends e{static kind="mathPI";static isConstant=!0;static outputs=e.out(["number"],{data:Math.PI})}class R extends e.Task{static kind="mathSin";static inputs=e.in(["number"]);static outputs=e.out(["number"]);task(){return Math.sin(this.input(0).data)}}class V extends e.Task{static kind="mathSinh";static inputs=e.in(["number"]);static outputs=e.out(["number"]);task(){return Math.sinh(this.input(0).data)}}const kt={[z.kind]:z,[W.kind]:W,[H.kind]:H,[R.kind]:R,[V.kind]:V};class Q extends e.Task{static kind="isFinite";static inputs=e.in(["number"]);static outputs=e.out(["boolean"]);task(){return Number.isFinite(this.input(0).data)}}class X extends e.Task{static kind="isInteger";static inputs=e.in([]);static outputs=e.out(["boolean"]);task(){return Number.isInteger(this.input(0).data)}}class Y extends e.Task{static kind="isNaN";static inputs=e.in([]);static outputs=e.out(["boolean"]);task(){return Number.isNaN(this.input(0).data)}}class Z extends e.Task{static kind="parseFloat";static inputs=e.in(["string"]);static outputs=e.out(["number"]);task(){return parseFloat(this.input(0).data)}}class _ extends e.Task{static kind="parseInt";static inputs=e.in(["number","string"]);static outputs=e.out(["number"]);task(){return parseInt(this.input(0).data)}}const mt={[Q.kind]:Q,[X.kind]:X,[Y.kind]:Y,[Z.kind]:Z,[_.kind]:_};class tt extends e.Task{static kind="objectKeys";static inputs=e.in(["object"]);static outputs=e.out(["array"]);task(){return Object.keys(this.input(0).data)}}class st extends e.Task{static kind="objectValues";static inputs=e.in(["object"]);static outputs=e.out(["array"]);task(){return Object.values(this.input(0).data)}}const bt={[tt.kind]:tt,[st.kind]:st};class et extends e.Task{static kind="addition";static inputs=e.ins(2,["number"]);static outputs=e.out(["number"]);task(){return this.input(0).data+this.input(1).data}}class nt extends e.Task{static kind="equality";static inputs=e.ins(2);static outputs=e.out(["boolean"]);task(){return this.input(0).data==this.input(1).data}}class it extends e.Task{static kind="lessThan";static inputs=e.ins(2,["number"]);static outputs=e.out(["boolean"]);task(){return this.input(0).data<this.input(1).data}}class rt extends e.Task{static kind="lessThanOrEqual";static inputs=e.ins(2,["number"]);static outputs=e.out(["boolean"]);task(){return this.input(0).data<=this.input(1).data}}class ot extends e.Task{static kind="greaterThan";static inputs=e.ins(2,["number"]);static outputs=e.out(["boolean"]);task(){return this.input(0).data>this.input(1).data}}class at extends e.Task{static kind="greaterThanOrEqual";static inputs=e.ins(2,["number"]);static outputs=e.out(["boolean"]);task(){return this.input(0).data>=this.input(1).data}}class ut extends e.Task{static kind="inequality";static inputs=e.ins(2);static outputs=e.out(["boolean"]);task(){return this.input(0).data!=this.input(1).data}}class dt extends e.Task{static kind="subtraction";static inputs=e.ins(2,["number"]);static outputs=e.out(["number"]);task(){return this.input(0).data-this.input(1).data}}const Tt={[et.kind]:et,[nt.kind]:nt,[ot.kind]:ot,[at.kind]:at,[it.kind]:it,[rt.kind]:rt,[ut.kind]:ut,[dt.kind]:dt};class ct extends e.Task{static kind="stringLength";static inputs=e.in(["string"]);static outputs=e.out(["number"]);task(){return this.input(0).data.length}}const Nt={[ct.kind]:ct},Dt={...ft,...gt,...yt,...wt,...It,...kt,...mt,...bt,...Tt,...Nt};export{Dt as catalog};
