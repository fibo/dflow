var wt=Object.defineProperty,bt=Object.defineProperties;var xt=Object.getOwnPropertyDescriptors;var st=Object.getOwnPropertySymbols;var ht=Object.prototype.hasOwnProperty,pt=Object.prototype.propertyIsEnumerable;var rt=(n,t,s)=>t in n?wt(n,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):n[t]=s,g=(n,t)=>{for(var s in t||(t={}))ht.call(t,s)&&rt(n,s,t[s]);if(st)for(var s of st(t))pt.call(t,s)&&rt(n,s,t[s]);return n},b=(n,t)=>bt(n,xt(t));var F=(n,t)=>{var s={};for(var e in n)ht.call(n,e)&&t.indexOf(e)<0&&(s[e]=n[e]);if(n!=null&&st)for(var e of st(n))t.indexOf(e)<0&&pt.call(n,e)&&(s[e]=n[e]);return s};var r=(n,t,s)=>(rt(n,typeof t!="symbol"?t+"":t,s),s),ut=(n,t,s)=>{if(!t.has(n))throw TypeError("Cannot "+s)};var o=(n,t,s)=>(ut(n,t,"read from private field"),s?s.call(n):t.get(n)),I=(n,t,s)=>{if(t.has(n))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(n):t.set(n,s)},x=(n,t,s,e)=>(ut(n,t,"write to private field"),e?e.call(n,s):t.set(n,s),s);var G=(n,t,s)=>(ut(n,t,"access private method"),s);var S,D,R,A,C,T,v,M,z,ot,Nt,h,_,mt,tt,Ot;class et extends Error{constructor(t,s){super(`${t} not found id=${s}`)}}const lt=n=>`${n} must be a string`,kt=(n,t)=>`${t} pin not found nodeId=${n}`,ft=(n,t,s)=>`${kt(n,t)} position=${s}`,ct=({id:n,kind:t,outputs:s},e)=>{const i={id:n,kind:t,outputs:s==null?void 0:s.map(({id:u,data:c,name:a})=>({id:u,data:c,name:a}))};return e&&(i.error=e),i};class d{static isArray(t){return!!Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowId(t){return d.isStringNotEmpty(t)}static isObject(t){return!(typeof t!="object"||!t||Array.isArray(t))}static isNumber(t){return typeof t=="number"&&!isNaN(t)}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return d.isString(t)&&t!==""}static validate(t,s){return s.length===0?!0:s.some(e=>{switch(e){case"array":return d.isArray(t);case"boolean":return d.isBoolean(t);case"number":return d.isNumber(t);case"object":return d.isObject(t);case"string":return d.isString(t);case"DflowId":return d.isDflowId(t);default:return!1}},!0)}}class W{constructor({id:t,name:s}){r(this,"id");r(this,"name");this.id=t,this.name=s}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}class nt extends W{constructor(t,i){var u=i,{types:s=[]}=u,e=F(u,["types"]);super(e);r(this,"kind");r(this,"types");this.kind=t,this.types=s}get hasTypeAny(){return this.types.length===0}hasType(t){return this.hasTypeAny||this.types.includes(t)}toObject(){const t=super.toObject();return this.types.length>0&&(t.types=this.types),t}}r(nt,"types",["string","number","boolean","object","array","DflowId"]);class gt extends nt{constructor(i){var u=i,{multi:t,optional:s}=u,e=F(u,["multi","optional"]);super("input",e);I(this,S,void 0);I(this,D,void 0);I(this,R,void 0);I(this,A,void 0);x(this,S,t),x(this,D,s)}get data(){var t,s;if(o(this,S)){const e=Array.from((t=o(this,A))!=null?t:[]);return e.length?e.map(i=>i.data):void 0}else return(s=o(this,R))==null?void 0:s.data}get isConnected(){var t;return o(this,S)?Array.from((t=o(this,A))!=null?t:[]).length>0:typeof o(this,R)>"u"}get isMulti(){return o(this,S)}get isOptional(){return o(this,D)}connectTo(t){const{hasTypeAny:s,types:e}=this,{types:i}=t;if(s||e.some(c=>i.includes(c)))o(this,S)?(o(this,A)||x(this,A,new Set),o(this,A).add(t)):x(this,R,t);else throw new Error(`mismatching pinTypes, source has types [${i.join()}] and target has types [${e.join()}]`)}disconnect(){var t;o(this,S)?(t=o(this,A))==null||t.clear():x(this,R,void 0)}toObject(){return super.toObject()}}S=new WeakMap,D=new WeakMap,R=new WeakMap,A=new WeakMap;class yt extends nt{constructor(e){var i=e,{data:t}=i,s=F(i,["data"]);super("output",s);I(this,C,void 0);x(this,C,t)}clear(){x(this,C,void 0)}get data(){return o(this,C)}set data(t){switch(!0){case typeof t>"u":this.clear();break;case this.hasTypeAny:case(this.hasType("string")&&d.isString(t)):case(this.hasType("number")&&d.isNumber(t)):case(this.hasType("boolean")&&d.isBoolean(t)):case(this.hasType("object")&&d.isObject(t)):case(this.hasType("array")&&d.isArray(t)):case(this.hasType("DflowId")&&d.isDflowId(t)):{x(this,C,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof data is ${typeof t}`)}}toObject(){const t=super.toObject();return typeof o(this,C)<"u"&&(t.data=o(this,C)),t}}C=new WeakMap;class f extends W{constructor(m,u,{isAsync:c=!1,isConstant:a=!1}={}){var l=m,{kind:t,inputs:s=[],outputs:e=[]}=l,i=F(l,["kind","inputs","outputs"]);super(i);I(this,T,new Map);I(this,v,new Map);I(this,M,[]);I(this,z,[]);r(this,"kind");r(this,"meta");r(this,"host");this.host=u,this.kind=t,this.meta={isAsync:c,isConstant:a};for(const y of s)this.newInput(y);for(const y of e)this.newOutput(y)}static input(t=[],s){return g(typeof t=="string"?{types:[t]}:{types:t},s)}static output(t=[],s){return g(typeof t=="string"?{types:[t]}:{types:t},s)}get inputs(){return o(this,T).values()}get outputs(){return o(this,v).values()}clearOutputs(){for(const t of this.outputs)t.clear()}getInputById(t){const s=o(this,T).get(t);if(!s)throw new et("input",t);return s}input(t){const s=o(this,M)[t];if(!s)throw new Error(ft(this.id,"input",t));return this.getInputById(s)}getOutputById(t){const s=o(this,v).get(t);if(!s)throw new et("output",t);return s}output(t){const s=o(this,z)[t];if(!s)throw new Error(ft(this.id,"output",t));return this.getOutputById(s)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),o(this,T).delete(t),o(this,M).splice(o(this,M).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),o(this,v).delete(t),o(this,z).splice(o(this,z).indexOf(t),1)}newInput(t){const s=o(this,T).size,e=(c=s)=>{const a=`i${c}`;return o(this,T).has(a)?e(c+1):a},i=d.isDflowId(t.id)?t.id:e(),u=new gt(b(g({},t),{id:i}));return o(this,T).set(i,u),o(this,M).push(i),u}newOutput(t){const s=o(this,v).size,e=(c=s)=>{const a=`o${c}`;return o(this,v).has(a)?e(c+1):a},i=d.isDflowId(t.id)?t.id:e(),u=new yt(b(g({},t),{id:i}));return o(this,v).set(i,u),o(this,z).push(i),u}run(){}toObject(){const t=b(g({},super.toObject()),{kind:this.kind}),s=[],e=[];for(const i of this.inputs)s.push(i.toObject());s.length>0&&(t.inputs=s);for(const i of this.outputs)e.push(i.toObject());return e.length>0&&(t.outputs=e),t}}T=new WeakMap,v=new WeakMap,M=new WeakMap,z=new WeakMap,r(f,"kind"),r(f,"isAsync"),r(f,"isConstant"),r(f,"inputs"),r(f,"outputs");class It extends W{constructor(i){var u=i,{source:t,target:s}=u,e=F(u,["source","target"]);super(e);r(this,"source");r(this,"target");this.source=t,this.target=s}toObject(){return b(g({},super.toObject()),{source:this.source,target:this.target})}}const j=class extends W{constructor(){super(...arguments);I(this,ot);r(this,"nodes",new Map);r(this,"edges",new Map);r(this,"runOptions",{verbose:!1});r(this,"runStatus",null);r(this,"executionReport",null)}static childrenOfNodeId(t,s){return s.filter(({sourceId:e})=>t===e).map(({targetId:e})=>e)}static parentsOfNodeId(t,s){return s.filter(({targetId:e})=>t===e).map(({sourceId:e})=>e)}static levelOfNodeId(t,s){const e=j.parentsOfNodeId(t,s);if(e.length===0)return 0;let i=0;for(const u of e){const c=j.levelOfNodeId(u,s);i=Math.max(c,i)}return i+1}static ancestorsOfNodeId(t,s){const e=j.parentsOfNodeId(t,s);return e.length===0?[]:e.reduce((i,u,c,a)=>{const m=j.ancestorsOfNodeId(u,s),l=i.concat(m);return c===a.length-1?Array.from(new Set(a.concat(l))):l},[])}static sort(t,s){const e={};for(const i of t)e[i]=j.levelOfNodeId(i,s);return t.slice().sort((i,u)=>e[i]<=e[u]?-1:1)}get nodeConnections(){return[...this.edges.values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}async run(){var i,u;const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const s=G(this,ot,Nt).call(this),e=j.sort([...this.nodes.keys()].filter(c=>!s.includes(c)),this.nodeConnections);s:for(const c of e){const a=this.nodes.get(c);try{if(!a.meta.isConstant){let m=!1;t:for(const{id:l,data:y,types:O,isOptional:p}of a.inputs){if(p&&typeof y>"u")continue t;if(!d.validate(y,O)){m=!0,t&&((i=this.executionReport.steps)==null||i.push(ct(a.toObject(),`invalid input data nodeId=${c} inputId=${l} data=${y}`)));break t}}if(m){for(const l of a.outputs)l.clear();continue s}a.meta.isAsync?await a.run():a.run()}t&&((u=this.executionReport.steps)==null||u.push(ct(a.toObject())))}catch(m){console.error(m),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=b(g({},super.toObject()),{nodes:[],edges:[]});for(const s of this.nodes.values())t.nodes.push(s.toObject());for(const s of this.edges.values())t.edges.push(s.toObject());return t}};let J=j;ot=new WeakSet,Nt=function(){const t=[];for(const s of[...this.nodes.values()])s.kind==="return"&&t.push(j.ancestorsOfNodeId(s.id,this.nodeConnections));return Array.from(new Set(t.flat()))};const L=class{constructor(t={}){I(this,h,void 0);r(this,"nodesCatalog");r(this,"context");this.nodesCatalog=g(g({},t),jt),x(this,h,new J({id:"g1"})),this.context={}}get executionReport(){return o(this,h).executionReport}get edges(){return Array.from(o(this,h).edges.values())}get nodes(){return o(this,h).nodes}get runStatusIsSuccess(){return o(this,h).runStatus==="success"}get runStatusIsWaiting(){return o(this,h).runStatus==="waiting"}get runStatusIsFailure(){return o(this,h).runStatus==="failure"}set verbose(t){o(this,h).runOptions.verbose=t}clearGraph(){o(this,h).nodes.clear(),o(this,h).edges.clear()}connect(t,s=0){return{to:(e,i=0)=>{const u=t.output(s),c=e.input(i);this.newEdge({source:[t.id,u.id],target:[e.id,c.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(lt("edgeId"));const s=this.getEdgeById(t);if(!s)return;const[e,i]=s.target;this.getNodeById(e).getInputById(i).disconnect(),o(this,h).edges.delete(t)}deleteNode(t){if(typeof t!="string")throw new TypeError(lt("nodeId"));const s=this.getNodeById(t);if(s){for(const e of this.edges){const{source:[i],target:[u]}=e;(i===s.id||u===s.id)&&this.deleteEdge(e.id)}o(this,h).nodes.delete(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,s]){for(const e of this.edges){const[i,u]=e.source,[c,a]=e.target;(i===t&&u===s||c===t&&a===s)&&this.deleteEdge(e.id)}}executeFunction(t,s){var l,y;const{verbose:e}=o(this,h).runOptions,i=o(this,h).nodeConnections,u=J.childrenOfNodeId(t,i),c=[];for(const O of u){const p=this.getNodeById(O);p.kind===B.kind&&c.push(p.id)}const a=c.reduce((O,p,w,k)=>{const P=J.ancestorsOfNodeId(p,i),V=O.concat(P);return w===k.length?Array.from(new Set(V)):V},[]),m=J.sort([...c,...a],i);for(const O of m){const p=this.getNodeById(O);try{switch(p.kind){case $.kind:{const w=p.input(0).data,k=typeof w=="number"&&!isNaN(w)?Math.max(w,0):0;p.output(0).data=s[k];break}case B.kind:return p.input(1).data;default:!p.meta.isConstant&&!p.meta.isAsync&&p.run(),e&&((y=(l=this.executionReport)==null?void 0:l.steps)==null||y.push(ct(p.toObject())))}}catch(w){console.error(w)}}}getEdgeById(t){const s=o(this,h).edges.get(t);if(!s)throw new et("edge",t);return s}getNodeById(t){const s=o(this,h).nodes.get(t);if(!s)throw new et("node",t);return s}newNode(t){var y,O,p,w,k,P,V;const s=o(this,h).nodes.size,e=(at=s)=>{const dt=`n${at}`;return o(this,h).nodes.has(dt)?e(at+1):dt},i=(y=this.nodesCatalog[t.kind])!=null?y:Et,u=d.isDflowId(t.id)?t.id:e(),c={isAsync:i.isAsync,isConstant:i.isConstant},a=Array.isArray(t.inputs)?G(O=L,_,mt).call(O,t.inputs):G(w=L,_,mt).call(w,(p=i.inputs)!=null?p:[]),m=Array.isArray(t.outputs)?G(k=L,tt,Ot).call(k,t.outputs):G(V=L,tt,Ot).call(V,(P=i.outputs)!=null?P:[]),l=new i(b(g({},t),{id:u,inputs:a,outputs:m}),this,c);return o(this,h).nodes.set(l.id,l),l}newEdge(t){const s=o(this,h).edges.size,e=(k=s)=>{const P=`e${k}`;return o(this,h).edges.has(P)?e(k+1):P},i=d.isDflowId(t.id)?t.id:e(),u=new It(b(g({},t),{id:i}));o(this,h).edges.set(u.id,u);const[c,a]=u.source,[m,l]=u.target,y=this.getNodeById(c),O=this.getNodeById(m),p=y.getOutputById(a);return O.getInputById(l).connectTo(p),u}newInput(t,s){return this.getNodeById(t).newInput(s)}newOutput(t,s){return this.getNodeById(t).newOutput(s)}toObject(){return o(this,h).toObject()}async run(){await o(this,h).run()}};let it=L;h=new WeakMap,_=new WeakSet,mt=function(t=[]){return t.map((s,e)=>b(g({},s),{id:d.isDflowId(s.id)?s.id:`i${e}`}))},tt=new WeakSet,Ot=function(t=[]){return t.map((s,e)=>b(g({},s),{id:d.isDflowId(s.id)?s.id:`o${e}`}))},I(it,_),I(it,tt);const{input:N,output:E}=f;class $ extends f{}r($,"kind","argument"),r($,"isConstant",!0),r($,"inputs",[N("number",{name:"position",optional:!0})]),r($,"outputs",[E()]);class q extends f{run(){const t=this.input(0).data;d.isArray(t)?this.output(0).data=t:this.output(0).clear()}}r(q,"kind","array"),r(q,"inputs",[N()]),r(q,"outputs",[E("array")]);class H extends f{run(){const t=this.input(0).data;d.isBoolean(t)?this.output(0).data=t:this.output(0).clear()}}r(H,"kind","boolean"),r(H,"inputs",[N()]),r(H,"outputs",[E("boolean")]);class K extends f{}r(K,"kind","data"),r(K,"isConstant",!0),r(K,"outputs",[E()]);class Q extends f{constructor(...t){super(...t);this.output(0).data=this.id}}r(Q,"kind","function"),r(Q,"isConstant",!0),r(Q,"outputs",[E("DflowId",{name:"id"})]);class U extends f{run(){this.output(0).data=typeof this.input(0).data>"u"}}r(U,"kind","isUndefined"),r(U,"inputs",[N()]),r(U,"outputs",[E("boolean")]);class X extends f{run(){const t=this.input(0).data;d.isNumber(t)?this.output(0).data=t:this.output(0).clear()}}r(X,"kind","number"),r(X,"inputs",[N()]),r(X,"outputs",[E("number")]);class Y extends f{run(){const t=this.input(0).data;d.isObject(t)?this.output(0).data=t:this.output(0).clear()}}r(Y,"kind","object"),r(Y,"inputs",[N()]),r(Y,"outputs",[E("object")]);class B extends f{}r(B,"kind","return"),r(B,"isConstant",!0),r(B,"inputs",[N("DflowId",{name:"functionId"}),N([],{name:"value"})]);class Z extends f{run(){const t=this.input(0).data;d.isString(t)?this.output(0).data=t:this.output(0).clear()}}r(Z,"kind","string"),r(Z,"inputs",[N()]),r(Z,"outputs",[E("string")]);class Et extends f{}const jt={[$.kind]:$,[q.kind]:q,[H.kind]:H,[K.kind]:K,[U.kind]:U,[X.kind]:X,[Y.kind]:Y,[Q.kind]:Q,[Z.kind]:Z,[B.kind]:B};export{d as DflowData};export{W as DflowItem};export{nt as DflowPin};export{gt as DflowInput};export{yt as DflowOutput};export{f as DflowNode};export{It as DflowEdge};export{J as DflowGraph};export{it as DflowHost};
