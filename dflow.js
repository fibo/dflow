var Mt=Object.defineProperty,Qt=Object.defineProperties;var Xt=Object.getOwnPropertyDescriptors;var Et=Object.getOwnPropertySymbols;var Ut=Object.prototype.hasOwnProperty,Gt=Object.prototype.propertyIsEnumerable;var $t=(r,t,s)=>t in r?Mt(r,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):r[t]=s,h=(r,t)=>{for(var s in t||(t={}))Ut.call(t,s)&&$t(r,s,t[s]);if(Et)for(var s of Et(t))Gt.call(t,s)&&$t(r,s,t[s]);return r},b=(r,t)=>Qt(r,Xt(t));var C=(r,t)=>{var s={};for(var i in r)Ut.call(r,i)&&t.indexOf(i)<0&&(s[i]=r[i]);if(r!=null&&Et)for(var i of Et(r))t.indexOf(i)<0&&Gt.call(r,i)&&(s[i]=r[i]);return s};var e=(r,t,s)=>($t(r,typeof t!="symbol"?t+"":t,s),s),Ft=(r,t,s)=>{if(!t.has(r))throw TypeError("Cannot "+s)};var u=(r,t,s)=>(Ft(r,t,"read from private field"),s?s.call(r):t.get(r)),k=(r,t,s)=>{if(t.has(r))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(r):t.set(r,s)},N=(r,t,s,i)=>(Ft(r,t,"write to private field"),i?i.call(r,s):t.set(r,s),s);var v,w,E,O,U,G,wt,A,I,m,c,z;const T=r=>`${r} must be a string`,Yt=(r,t)=>`unimplemented method ${r} nodeKind=${t}`,Jt=r=>`${r} must be a number`,zt=(r,t)=>`${t} pin not found nodeId=${r}`,Kt=(r,t,s)=>`${zt(r,t)} position=${s}`,Wt=(r,t,s)=>`${zt(r,t)} pinId=${s}`;class a{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowGraph(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&Array.isArray(t.nodes)&&Array.isArray(t.edges)&&$.isDflowGraph(t)}static isDflowId(t){return a.isStringNotEmpty(t)}static isDflowType(t){return typeof t=="string"&&S.types.includes(t)}static isObject(t){return!a.isUndefined(t)&&!a.isNull(t)&&!a.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return a.isString(t)&&t.length>0}static isUndefined(t){return typeof t=="undefined"}static validate(t,s){return s.length===0?!0:s.some(i=>{switch(i){case"array":return a.isArray(t);case"boolean":return a.isBoolean(t);case"null":return a.isNull(t);case"number":return a.isNumber(t);case"object":return a.isObject(t);case"string":return a.isString(t);case"DflowGraph":return a.isDflowGraph(t);case"DflowId":return a.isDflowId(t);case"DflowType":return a.isDflowType(t);default:return!1}},!0)}}class P{constructor({id:t,name:s}){e(this,"id");e(this,"name");this.id=t,this.name=s}static isDflowItem({id:t,name:s}){return a.isDflowId(t)&&(a.isUndefined(s)||a.isStringNotEmpty(s))}toJSON(){return JSON.stringify(this.toObject())}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const Pt=class extends P{constructor(t,o){var d=o,{types:s=[]}=d,i=C(d,["types"]);super(i);e(this,"kind");e(this,"types");this.kind=t,this.types=s}static isDflowPin(i){var o=i,{types:t=[]}=o,s=C(o,["types"]);return P.isDflowItem(s)&&t.every(d=>Pt.isDflowPinType(d))}static isDflowPinType(t){Pt.types.includes(t)}get hasTypeAny(){return this.types.length===0}get hasTypeDflowId(){return this.hasTypeAny||this.types.includes("DflowId")}get hasTypeDflowGraph(){return this.hasTypeAny||this.types.includes("DflowGraph")}get hasTypeDflowType(){return this.hasTypeAny||this.types.includes("DflowType")}get hasTypeString(){return this.hasTypeAny||this.types.includes("string")}get hasTypeNumber(){return this.hasTypeAny||this.types.includes("number")}get hasTypeBoolean(){return this.hasTypeAny||this.types.includes("boolean")}get hasTypeNull(){return this.hasTypeAny||this.types.includes("null")}get hasTypeObject(){return this.hasTypeAny||this.types.includes("object")}get hasTypeArray(){return this.hasTypeAny||this.types.includes("array")}addType(t){this.types.push(t)}removeType(t){this.types.splice(this.types.indexOf(t),1)}};let S=Pt;e(S,"types",["string","number","boolean","null","object","array","DflowId","DflowGraph","DflowType"]);class Ot extends S{constructor(t){super("input",t);k(this,v,void 0)}static isDflowInput({id:t,types:s}){return S.isDflowPin({id:t,types:s})}get data(){var t;return(t=u(this,v))==null?void 0:t.data}get isConnected(){return typeof u(this,v)=="undefined"}connectTo(t){const{hasTypeAny:s,types:i}=this,{types:o}=t;if(s||i.some(d=>o.includes(d)))N(this,v,t);else throw new Error(`mismatching pinTypes, source has types [${o.join()}] and target has types [${i.join()}]`)}disconnect(){N(this,v,void 0)}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}v=new WeakMap;class At extends S{constructor(i){var o=i,{data:t}=o,s=C(o,["data"]);super("output",s);k(this,w,void 0);N(this,w,t)}static isDflowOutput({id:t,data:s,types:i=[]}){return S.isDflowPin({id:t,types:i})&&a.validate(s,i)}clear(){N(this,w,void 0)}get data(){return u(this,w)}set data(t){switch(!0){case a.isUndefined(t):this.clear();break;case this.hasTypeAny:case(a.isDflowGraph(t)&&this.hasTypeDflowGraph):case(a.isDflowId(t)&&this.hasTypeDflowId):case(a.isString(t)&&this.hasTypeString):case(a.isNumber(t)&&this.hasTypeNumber):case(a.isBoolean(t)&&this.hasTypeBoolean):case(a.isNull(t)&&this.hasTypeNull):case(a.isObject(t)&&this.hasTypeObject):case(a.isArray(t)&&this.hasTypeArray):{N(this,w,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=h({},super.toObject());return a.isUndefined(u(this,w))||(t.data=u(this,w)),this.types.length>0&&(t.types=this.types),t}}w=new WeakMap;const St=class extends P{constructor(y,d,{isAsync:g=!1,isConstant:l=!1,label:f}={}){var x=y,{kind:t,inputs:s=[],outputs:i=[]}=x,o=C(x,["kind","inputs","outputs"]);super(o);k(this,E,new Map);k(this,O,new Map);k(this,U,[]);k(this,G,[]);k(this,wt,void 0);e(this,"kind");e(this,"meta");e(this,"host");N(this,wt,f),this.host=d,this.kind=t,this.meta={isAsync:g,isConstant:l};for(const F of s)this.newInput(F);for(const F of i)this.newOutput(F);this.onCreate()}static generateInputIds(t=[]){return t.map((s,i)=>b(h({},s),{id:`i${i}`}))}static generateOutputIds(t=[]){return t.map((s,i)=>b(h({},s),{id:`o${i}`}))}static in(t=[],s){return[h({types:t},s)]}static ins(t,s=[]){return Array(t).fill(St.in(s)).flat()}static out(t=[],s){return[h({types:t},s)]}static outs(t,s=[]){return Array(t).fill(St.out(s)).flat()}static outputNumber(t){return b(h({},t),{types:["number"]})}static isDflowNode(d){var g=d,{kind:t,inputs:s=[],outputs:i=[]}=g,o=C(g,["kind","inputs","outputs"]);return P.isDflowItem(o)&&a.isStringNotEmpty(t)&&s.every(l=>Ot.isDflowInput(l))&&i.every(l=>At.isDflowOutput(l))}get label(){return u(this,wt)||this.kind}get inputs(){return u(this,E).values()}get outputs(){return u(this,O).values()}get numInputs(){return u(this,E).size}get numOutputs(){return u(this,O).size}generateInputId(t=this.numInputs){const s=`i${t}`;return u(this,E).has(s)?this.generateInputId(t+1):s}generateOutputId(t=this.numOutputs){const s=`o${t}`;return u(this,O).has(s)?this.generateOutputId(t+1):s}getInputById(t){if(typeof t!="string")throw new TypeError(T("inputId"));const s=u(this,E).get(t);if(s instanceof Ot)return s;throw new Error(Wt(this.id,"input",t))}input(t){if(typeof t!="number")throw new TypeError(Jt("position"));const s=u(this,U)[t];if(a.isUndefined(s))throw new Error(Kt(this.id,"input",t));return this.getInputById(s)}getOutputById(t){if(typeof t!="string")throw new TypeError(T("outputId"));const s=u(this,O).get(t);if(s instanceof At)return s;throw new Error(Wt(this.id,"output",t))}output(t){if(typeof t!="number")throw new TypeError(Jt("position"));const s=u(this,G)[t];if(a.isUndefined(s))throw new Error(Kt(this.id,"output",t));return this.getOutputById(s)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),u(this,E).delete(t),u(this,U).splice(u(this,U).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),u(this,O).delete(t),u(this,G).splice(u(this,G).indexOf(t),1)}onBeforeConnectInput(t,s){}onCreate(){}newInput(t){const s=a.isDflowId(t.id)?t.id:this.generateInputId(),i=new Ot(b(h({},t),{id:s}));return u(this,E).set(s,i),u(this,U).push(s),i}newOutput(t){const s=a.isDflowId(t.id)?t.id:this.generateOutputId(),i=new At(b(h({},t),{id:s}));return u(this,O).set(s,i),u(this,G).push(s),i}run(){throw new Error(`${this.constructor.name} does not implement a run() method`)}toObject(){const t=b(h({},super.toObject()),{kind:this.kind}),s=[],i=[];for(const o of this.inputs)s.push(o.toObject());s.length>0&&(t.inputs=s);for(const o of this.outputs)i.push(o.toObject());return i.length>0&&(t.outputs=i),t}};let n=St;E=new WeakMap,O=new WeakMap,U=new WeakMap,G=new WeakMap,wt=new WeakMap,e(n,"kind"),e(n,"isAsync"),e(n,"isConstant"),e(n,"label"),e(n,"inputs"),e(n,"outputs");class p extends n{task(){throw new Error(Yt("task",this.kind))}run(){for(const{data:t,types:s}of this.inputs)if(a.isUndefined(t)||!a.validate(t,s)){this.output(0).clear();return}this.output(0).data=this.task()}}const jt=class extends n{constructor(t,s){super(b(h({},t),{kind:jt.kind}),s)}run(){}};let Bt=jt;e(Bt,"kind","Unknown");class K extends P{constructor(o){var d=o,{source:t,target:s}=d,i=C(d,["source","target"]);super(i);e(this,"source");e(this,"target");const[g,l]=t,[f,y]=s;if(typeof g!="string")throw new TypeError(T("sourceNodeId"));if(typeof l!="string")throw new TypeError(T("sourcePinId"));if(typeof f!="string")throw new TypeError(T("targetNodeId"));if(typeof y!="string")throw new TypeError(T("targetPinId"));this.source=t,this.target=s}static isDflowEdge(d,o){var g=d,{source:t,target:s}=g,i=C(g,["source","target"]);return P.isDflowItem(i)&&Array.isArray(t)&&t.length===2&&o.nodes.find(({id:l,outputs:f=[]})=>l===t[0]&&f.find(({id:y})=>y===t[1]))&&Array.isArray(s)&&s.length===2&&o.nodes.find(({id:l,inputs:f=[]})=>l===s[0]&&f.find(({id:y})=>y===s[1]))}toObject(){return b(h({},super.toObject()),{source:this.source,target:this.target})}}const B=class extends P{constructor(){super(...arguments);k(this,A,"success");k(this,I,new Map);k(this,m,new Map)}static isDflowGraph(t){return t.nodes.every(s=>n.isDflowNode(s))&&t.edges.every(s=>K.isDflowEdge(s,t))}static childrenOfNodeId(t,s){return s.filter(({sourceId:i})=>t===i).map(({targetId:i})=>i)}static parentsOfNodeId(t,s){return s.filter(({targetId:i})=>t===i).map(({sourceId:i})=>i)}static levelOfNodeId(t,s){const i=B.parentsOfNodeId(t,s);if(i.length===0)return 0;let o=0;for(const d of i){const g=B.levelOfNodeId(d,s);o=Math.max(g,o)}return o+1}static ancestorsOfNodeId(t,s){const i=B.parentsOfNodeId(t,s);return i.length===0?[]:i.reduce((o,d,g,l)=>{const f=B.ancestorsOfNodeId(d,s),y=o.concat(f);return g===l.length-1?Array.from(new Set(l.concat(y))):y},[])}static sort(t,s){const i={};for(const o of t)i[o]=B.levelOfNodeId(o,s);return t.slice().sort((o,d)=>i[o]<=i[d]?-1:1)}get edges(){return u(this,m).values()}get nodes(){return u(this,I).values()}get nodeConnections(){return[...u(this,m).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...u(this,m).keys()]}get nodeIds(){return[...u(this,I).keys()]}get numEdges(){return u(this,m).size}get numNodes(){return u(this,I).size}get runStatusIsSuccess(){return u(this,A)==="success"}get runStatusIsWaiting(){return u(this,A)==="waiting"}get runStatusIsFailure(){return u(this,A)==="failure"}addEdge(t){if(u(this,m).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);u(this,m).set(t.id,t)}addNode(t){if(u(this,I).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);u(this,I).set(t.id,t)}clear(){u(this,I).clear(),u(this,m).clear()}deleteEdge(t){u(this,m).delete(t)}deleteNode(t){u(this,I).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(T("nodeId"));const s=u(this,I).get(t);if(s instanceof n)return s;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(T("edgeId"));const s=u(this,m).get(t);if(s instanceof K)return s;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const s=`e${t}`;return u(this,m).has(s)?this.generateEdgeId(t+1):s}generateNodeId(t=this.numNodes){const s=`n${t}`;return u(this,I).has(s)?this.generateNodeId(t+1):s}nodeIdsInsideFunctions(){const t=[];for(const s of this.nodes)s.kind==="return"&&t.push(B.ancestorsOfNodeId(s.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){this.runStatusIsSuccess&&N(this,A,"waiting");const t=this.nodeIdsInsideFunctions(),s=B.sort(this.nodeIds.filter(i=>!t.includes(i)),this.nodeConnections);for(const i of s){const o=u(this,I).get(i);try{o.meta.isConstant===!1&&(o.meta.isAsync?await o.run():o.run())}catch(d){console.error(d),N(this,A,"failure")}}this.runStatusIsWaiting&&N(this,A,"success")}toObject(){const t=b(h({},super.toObject()),{nodes:[],edges:[]});for(const s of this.nodes)t.nodes.push(s.toObject());for(const s of this.edges)t.edges.push(s.toObject());return t}};let $=B;A=new WeakMap,I=new WeakMap,m=new WeakMap;class Zt{constructor(t={}){k(this,c,void 0);k(this,z,void 0);N(this,z,t),N(this,c,new $({id:"g1"}))}get edges(){return u(this,c).edges}get nodes(){return u(this,c).nodes}get numEdges(){return u(this,c).numEdges}get numNodes(){return u(this,c).numNodes}get nodeKinds(){return Object.keys(u(this,z))}get runStatusIsSuccess(){return u(this,c).runStatusIsSuccess}get runStatusIsWaiting(){return u(this,c).runStatusIsWaiting}get runStatusIsFailure(){return u(this,c).runStatusIsFailure}clearGraph(){u(this,c).clear()}connect(t,s=0){return{to:(i,o=0)=>{const d=u(this,c).generateEdgeId(),g=t.output(s),l=i.input(o);i.onBeforeConnectInput(t,s),this.newEdge({id:d,source:[t.id,g.id],target:[i.id,l.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(T("edgeId"));const s=u(this,c).getEdgeById(t);if(s instanceof K){const[i,o]=s.target;this.getNodeById(i).getInputById(o).disconnect(),u(this,c).deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(T("nodeId"));const s=this.getNodeById(t);if(s instanceof n){for(const i of u(this,c).edges){const{source:[o],target:[d]}=i;(o===s.id||d===s.id)&&this.deleteEdge(i.id)}u(this,c).deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,s]){for(const i of this.edges){const[o,d]=i.source,[g,l]=i.target;(o===t&&d===s||g===t&&l===s)&&this.deleteEdge(i.id)}}executeFunction(t,s){const i=u(this,c).nodeConnections,o=$.childrenOfNodeId(t,i),d=[];for(const f of o){const y=this.getNodeById(f);y.kind==="return"&&d.push(y.id)}const g=d.reduce((f,y,x,F)=>{const Ht=$.ancestorsOfNodeId(y,i),vt=f.concat(Ht);return x===F.length?Array.from(new Set(vt)):vt},[]),l=$.sort([...d,...g],i);for(const f of l){const y=this.getNodeById(f);try{switch(y.kind){case"argument":{const x=0;y.output(0).data=s[x];break}case"return":return y.input(1).data;default:y.meta.isConstant||y.run()}}catch(x){console.error(x)}}}getEdgeById(t){return u(this,c).getEdgeById(t)}getNodeById(t){return u(this,c).getNodeById(t)}newNode(t){var f;const s=(f=u(this,z)[t.kind])!=null?f:Bt,i=a.isDflowId(t.id)?t.id:u(this,c).generateNodeId(),o={isAsync:s.isAsync,isConstant:s.isConstant,label:s.label},d=Array.isArray(t.inputs)?t.inputs:n.generateInputIds(s.inputs),g=Array.isArray(t.outputs)?t.outputs:n.generateOutputIds(s.outputs),l=new s(b(h({},t),{id:i,inputs:d,outputs:g}),this,o);return u(this,c).addNode(l),l}newEdge(t){const s=a.isDflowId(t.id)?t.id:u(this,c).generateEdgeId(),i=new K(b(h({},t),{id:s}));u(this,c).addEdge(i);const[o,d]=i.source,[g,l]=i.target,f=u(this,c).getNodeById(o),y=u(this,c).getNodeById(g),x=f.getOutputById(d);return y.getInputById(l).connectTo(x),i}newInput(t,s){return u(this,c).getNodeById(t).newInput(s)}newOutput(t,s){return u(this,c).getNodeById(t).newOutput(s)}toJSON(){return u(this,c).toJSON()}toObject(){return u(this,c).toObject()}async run(){await u(this,c).run()}}c=new WeakMap,z=new WeakMap;export{a as DflowData};export{P as DflowItem};export{S as DflowPin};export{Ot as DflowInput};export{At as DflowOutput};export{n as DflowNode};export{p as DflowNodeUnary};export{Bt as DflowUnknownNode};export{K as DflowEdge};export{$ as DflowGraph};export{Zt as DflowHost};class W extends p{task(){return this.input(0).data.filter((...t)=>this.host.executeFunction(this.input(1).data,t))}}e(W,"kind","arrayFilter"),e(W,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),e(W,"outputs",n.out(["array"]));class H extends p{task(){return this.input(0).data.length}}e(H,"kind","arrayLength"),e(H,"inputs",n.in(["array"])),e(H,"outputs",n.out(["number"]));const Rt={[W.kind]:W,[H.kind]:H};class M extends p{task(){return this.input(0).data?this.input(1).data:this.input(2).data}}e(M,"kind","if"),e(M,"inputs",[...n.in(["boolean"],{name:"condition"}),...n.in([],{name:"then"}),...n.in([],{name:"else"})]),e(M,"outputs",n.out());const Vt={[M.kind]:M};class Ct extends n{run(){console.log(this.input(0).data)}}e(Ct,"kind","consoleLog"),e(Ct,"inputs",[...n.in([])]);const qt={[Ct.kind]:Ct};class Q extends n{}e(Q,"kind","data"),e(Q,"outputs",n.out()),e(Q,"isConstant",!0);class X extends n{}e(X,"kind","array"),e(X,"outputs",n.out(["array"])),e(X,"isConstant",!0);class Y extends n{}e(Y,"kind","boolean"),e(Y,"outputs",n.out(["boolean"])),e(Y,"isConstant",!0);class Z extends n{}e(Z,"kind","number"),e(Z,"outputs",n.out(["number"])),e(Z,"isConstant",!0);class R extends n{}e(R,"kind","object"),e(R,"outputs",n.out(["object"])),e(R,"isConstant",!0);class V extends n{}e(V,"kind","string"),e(V,"outputs",n.out(["string"])),e(V,"isConstant",!0);const Lt={[Q.kind]:Q,[X.kind]:X,[Y.kind]:Y,[Z.kind]:Z,[R.kind]:R,[V.kind]:V};class j extends n{run(){const t=this.output(0);t.data=this.host.nodeKinds}}e(j,"kind","dflow"),e(j,"outputs",n.out(["array"],{name:"nodeKinds"}));class q extends n{}e(q,"kind","comment"),e(q,"isConstant",!0),e(q,"outputs",n.out(["string"]));class L extends n{}e(L,"kind","typeNumber"),e(L,"isConstant",!0),e(L,"outputs",n.out(["DflowType"],{name:"number",data:"number"}));class J extends n{onBeforeConnectInput(t,s){const i=t.output(s).data;this.output(0).addType(i)}}e(J,"kind","argument"),e(J,"isConstant",!0),e(J,"inputs",[...n.in(["DflowType"],{name:"type"})]),e(J,"outputs",n.out());class _ extends n{onCreate(){this.output(0).data=this.id}}e(_,"kind","function"),e(_,"isConstant",!0),e(_,"outputs",j.out(["DflowId"],{name:"id"}));class D extends n{}e(D,"kind","return"),e(D,"isConstant",!0),e(D,"inputs",[...j.in(["DflowId"],{name:"functionId"}),...j.in([],{name:"value"})]);const _t={[j.kind]:j,[J.kind]:J,[q.kind]:q,[_.kind]:_,[D.kind]:D,[L.kind]:L};class tt extends p{task(){return this.input(0).data&&this.input(1).data}}e(tt,"kind","and"),e(tt,"inputs",n.ins(2,["boolean"])),e(tt,"outputs",n.out(["boolean"]));class st extends p{task(){return!this.input(0).data}}e(st,"kind","not"),e(st,"inputs",n.in(["boolean"])),e(st,"outputs",n.out(["boolean"]));class et extends p{task(){return this.input(0).data||this.input(1).data}}e(et,"kind","or"),e(et,"inputs",n.ins(2,["boolean"])),e(et,"outputs",n.out(["boolean"]));const Dt={[tt.kind]:tt,[st.kind]:st,[et.kind]:et};class nt extends p{task(){return Math.cos(this.input(0).data)}}e(nt,"kind","mathCos"),e(nt,"inputs",n.in(["number"])),e(nt,"outputs",n.out(["number"]));class it extends p{task(){return Math.cosh(this.input(0).data)}}e(it,"kind","mathCosh"),e(it,"inputs",n.in(["number"])),e(it,"outputs",n.out(["number"]));class rt extends n{}e(rt,"kind","mathPI"),e(rt,"isConstant",!0),e(rt,"outputs",n.out(["number"],{data:Math.PI}));class ut extends p{task(){return Math.sin(this.input(0).data)}}e(ut,"kind","mathSin"),e(ut,"inputs",n.in(["number"])),e(ut,"outputs",n.out(["number"]));class ot extends p{task(){return Math.sinh(this.input(0).data)}}e(ot,"kind","mathSinh"),e(ot,"inputs",n.in(["number"])),e(ot,"outputs",n.out(["number"]));const ts={[nt.kind]:nt,[it.kind]:it,[rt.kind]:rt,[ut.kind]:ut,[ot.kind]:ot};class at extends p{task(){return Number.isFinite(this.input(0).data)}}e(at,"kind","isFinite"),e(at,"inputs",n.in(["number"])),e(at,"outputs",n.out(["boolean"]));class dt extends p{task(){return Number.isInteger(this.input(0).data)}}e(dt,"kind","isInteger"),e(dt,"inputs",n.in([])),e(dt,"outputs",n.out(["boolean"]));class ct extends p{task(){return Number.isNaN(this.input(0).data)}}e(ct,"kind","isNaN"),e(ct,"inputs",n.in([])),e(ct,"outputs",n.out(["boolean"]));class pt extends p{task(){return parseFloat(this.input(0).data)}}e(pt,"kind","parseFloat"),e(pt,"inputs",n.in(["string"])),e(pt,"outputs",n.out(["number"]));class ht extends p{task(){return parseInt(this.input(0).data)}}e(ht,"kind","parseInt"),e(ht,"inputs",n.in(["number","string"])),e(ht,"outputs",n.out(["number"]));const ss={[at.kind]:at,[dt.kind]:dt,[ct.kind]:ct,[pt.kind]:pt,[ht.kind]:ht};class lt extends p{task(){return Object.keys(this.input(0).data)}}e(lt,"kind","objectKeys"),e(lt,"inputs",n.in(["object"])),e(lt,"outputs",n.out(["array"]));class gt extends p{task(){return Object.values(this.input(0).data)}}e(gt,"kind","objectValues"),e(gt,"inputs",n.in(["object"])),e(gt,"outputs",n.out(["array"]));const es={[lt.kind]:lt,[gt.kind]:gt};class yt extends p{task(){return this.input(0).data+this.input(1).data}}e(yt,"kind","addition"),e(yt,"inputs",n.ins(2,["number"])),e(yt,"outputs",n.out(["number"]));class ft extends p{task(){return this.input(0).data==this.input(1).data}}e(ft,"kind","equality"),e(ft,"inputs",n.ins(2)),e(ft,"outputs",n.out(["boolean"]));class kt extends p{task(){return this.input(0).data<this.input(1).data}}e(kt,"kind","lessThan"),e(kt,"inputs",n.ins(2,["number"])),e(kt,"outputs",n.out(["boolean"]));class It extends p{task(){return this.input(0).data<=this.input(1).data}}e(It,"kind","lessThanOrEqual"),e(It,"inputs",n.ins(2,["number"])),e(It,"outputs",n.out(["boolean"]));class mt extends p{task(){return this.input(0).data>this.input(1).data}}e(mt,"kind","greaterThan"),e(mt,"inputs",n.ins(2,["number"])),e(mt,"outputs",n.out(["boolean"]));class bt extends p{task(){return this.input(0).data>=this.input(1).data}}e(bt,"kind","greaterThanOrEqual"),e(bt,"inputs",n.ins(2,["number"])),e(bt,"outputs",n.out(["boolean"]));class Nt extends p{task(){return this.input(0).data!=this.input(1).data}}e(Nt,"kind","inequality"),e(Nt,"inputs",n.ins(2)),e(Nt,"outputs",n.out(["boolean"]));class xt extends p{task(){return this.input(0).data-this.input(1).data}}e(xt,"kind","subtraction"),e(xt,"inputs",n.ins(2,["number"])),e(xt,"outputs",n.out(["number"]));const ns={[yt.kind]:yt,[ft.kind]:ft,[mt.kind]:mt,[bt.kind]:bt,[kt.kind]:kt,[It.kind]:It,[Nt.kind]:Nt,[xt.kind]:xt};class Tt extends p{task(){return this.input(0).data.length}}e(Tt,"kind","stringLength"),e(Tt,"inputs",n.in(["string"])),e(Tt,"outputs",n.out(["number"]));const is={[Tt.kind]:Tt},rs=h(h(h(h(h(h(h(h(h(h(h({},Rt),Vt),qt),Lt),_t),Dt),ts),ss),es),ns),is);export{rs as catalog};
