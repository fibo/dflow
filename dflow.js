var es=Object.defineProperty,ns=Object.defineProperties;var is=Object.getOwnPropertyDescriptors;var Ut=Object.getOwnPropertySymbols;var Xt=Object.prototype.hasOwnProperty,Yt=Object.prototype.propertyIsEnumerable;var Jt=(u,t,s)=>t in u?es(u,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):u[t]=s,l=(u,t)=>{for(var s in t||(t={}))Xt.call(t,s)&&Jt(u,s,t[s]);if(Ut)for(var s of Ut(t))Yt.call(t,s)&&Jt(u,s,t[s]);return u},b=(u,t)=>ns(u,is(t));var T=(u,t)=>{var s={};for(var i in u)Xt.call(u,i)&&t.indexOf(i)<0&&(s[i]=u[i]);if(u!=null&&Ut)for(var i of Ut(u))t.indexOf(i)<0&&Yt.call(u,i)&&(s[i]=u[i]);return s};var e=(u,t,s)=>(Jt(u,typeof t!="symbol"?t+"":t,s),s),Zt=(u,t,s)=>{if(!t.has(u))throw TypeError("Cannot "+s)};var a=(u,t,s)=>(Zt(u,t,"read from private field"),s?s.call(u):t.get(u)),m=(u,t,s)=>{if(t.has(u))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(u):t.set(u,s)},x=(u,t,s,i)=>(Zt(u,t,"write to private field"),i?i.call(u,s):t.set(u,s),s);var S,St,E,w,B,G,U,Gt,f,I,p,z;const N=u=>`${u} must be a string`,Mt=u=>`${u} must be a number`,qt=(u,t)=>`${t} pin not found nodeId=${u}`,Lt=(u,t,s)=>`${qt(u,t)} position=${s}`,_t=(u,t,s)=>`${qt(u,t)} pinId=${s}`,Dt=({id:u,kind:t,outputs:s})=>({id:u,kind:t,outputs:s==null?void 0:s.map(({id:i,data:r,name:o})=>({id:i,data:r,name:o}))});class d{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowGraph(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&Array.isArray(t.nodes)&&Array.isArray(t.edges)&&$.isDflowGraph(t)}static isDflowId(t){return d.isStringNotEmpty(t)}static isDflowType(t){return typeof t=="string"&&P.types.includes(t)}static isObject(t){return!d.isUndefined(t)&&!d.isNull(t)&&!d.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return d.isString(t)&&t.length>0}static isUndefined(t){return typeof t=="undefined"}static validate(t,s){return s.length===0?!0:s.some(i=>{switch(i){case"array":return d.isArray(t);case"boolean":return d.isBoolean(t);case"null":return d.isNull(t);case"number":return d.isNumber(t);case"object":return d.isObject(t);case"string":return d.isString(t);case"DflowGraph":return d.isDflowGraph(t);case"DflowId":return d.isDflowId(t);case"DflowType":return d.isDflowType(t);default:return!1}},!0)}}class C{constructor({id:t,name:s}){e(this,"id");e(this,"name");this.id=t,this.name=s}static isDflowItem({id:t,name:s}){return d.isDflowId(t)&&(d.isUndefined(s)||d.isStringNotEmpty(s))}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const Kt=class extends C{constructor(t,r){var o=r,{types:s=[]}=o,i=T(o,["types"]);super(i);e(this,"kind");e(this,"types");this.kind=t,this.types=s}static isDflowPin(i){var r=i,{types:t=[]}=r,s=T(r,["types"]);return C.isDflowItem(s)&&t.every(o=>Kt.isDflowPinType(o))}static isDflowPinType(t){Kt.types.includes(t)}get hasTypeAny(){return this.types.length===0}get hasTypeDflowId(){return this.hasTypeAny||this.types.includes("DflowId")}get hasTypeDflowGraph(){return this.hasTypeAny||this.types.includes("DflowGraph")}get hasTypeDflowType(){return this.hasTypeAny||this.types.includes("DflowType")}get hasTypeString(){return this.hasTypeAny||this.types.includes("string")}get hasTypeNumber(){return this.hasTypeAny||this.types.includes("number")}get hasTypeBoolean(){return this.hasTypeAny||this.types.includes("boolean")}get hasTypeNull(){return this.hasTypeAny||this.types.includes("null")}get hasTypeObject(){return this.hasTypeAny||this.types.includes("object")}get hasTypeArray(){return this.hasTypeAny||this.types.includes("array")}addType(t){this.types.push(t)}removeType(t){this.types.splice(this.types.indexOf(t),1)}};let P=Kt;e(P,"types",["string","number","boolean","null","object","array","DflowId","DflowGraph","DflowType"]);class Rt extends P{constructor(i){var r=i,{optional:t}=r,s=T(r,["optional"]);super("input",s);m(this,S,void 0);m(this,St,void 0);x(this,St,t)}static isDflowInput({id:t,types:s}){return P.isDflowPin({id:t,types:s})}get data(){var t;return(t=a(this,S))==null?void 0:t.data}get isConnected(){return typeof a(this,S)=="undefined"}get isOptional(){return a(this,St)}connectTo(t){const{hasTypeAny:s,types:i}=this,{types:r}=t;if(s||i.some(o=>r.includes(o)))x(this,S,t);else throw new Error(`mismatching pinTypes, source has types [${r.join()}] and target has types [${i.join()}]`)}disconnect(){x(this,S,void 0)}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}S=new WeakMap,St=new WeakMap;class zt extends P{constructor(i){var r=i,{data:t}=r,s=T(r,["data"]);super("output",s);m(this,E,void 0);x(this,E,t)}static isDflowOutput({id:t,data:s,types:i=[]}){return P.isDflowPin({id:t,types:i})&&d.validate(s,i)}clear(){x(this,E,void 0)}get data(){return a(this,E)}set data(t){switch(!0){case d.isUndefined(t):this.clear();break;case this.hasTypeAny:case(d.isDflowGraph(t)&&this.hasTypeDflowGraph):case(d.isDflowId(t)&&this.hasTypeDflowId):case(d.isString(t)&&this.hasTypeString):case(d.isNumber(t)&&this.hasTypeNumber):case(d.isBoolean(t)&&this.hasTypeBoolean):case(d.isNull(t)&&this.hasTypeNull):case(d.isObject(t)&&this.hasTypeObject):case(d.isArray(t)&&this.hasTypeArray):{x(this,E,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=l({},super.toObject());return d.isUndefined(a(this,E))||(t.data=a(this,E)),this.types.length>0&&(t.types=this.types),t}}E=new WeakMap;const Wt=class extends C{constructor(g,o,{isAsync:c=!1,isConstant:h=!1,label:y}={}){var O=g,{kind:t,inputs:s=[],outputs:i=[]}=O,r=T(O,["kind","inputs","outputs"]);super(r);m(this,w,new Map);m(this,B,new Map);m(this,G,[]);m(this,U,[]);m(this,Gt,void 0);e(this,"kind");e(this,"meta");e(this,"host");x(this,Gt,y),this.host=o,this.kind=t,this.meta={isAsync:c,isConstant:h};for(const j of s)this.newInput(j);for(const j of i)this.newOutput(j);this.onCreate()}static generateInputIds(t=[]){return t.map((s,i)=>b(l({},s),{id:`i${i}`}))}static generateOutputIds(t=[]){return t.map((s,i)=>b(l({},s),{id:`o${i}`}))}static in(t=[],s){return[l({types:t},s)]}static ins(t,s=[]){return Array(t).fill(Wt.in(s)).flat()}static out(t=[],s){return[l({types:t},s)]}static outs(t,s=[]){return Array(t).fill(Wt.out(s)).flat()}static outputNumber(t){return b(l({},t),{types:["number"]})}static isDflowNode(o){var c=o,{kind:t,inputs:s=[],outputs:i=[]}=c,r=T(c,["kind","inputs","outputs"]);return C.isDflowItem(r)&&d.isStringNotEmpty(t)&&s.every(h=>Rt.isDflowInput(h))&&i.every(h=>zt.isDflowOutput(h))}get label(){return a(this,Gt)||this.kind}get inputs(){return a(this,w).values()}get outputs(){return a(this,B).values()}get numInputs(){return a(this,w).size}get numOutputs(){return a(this,B).size}generateInputId(t=this.numInputs){const s=`i${t}`;return a(this,w).has(s)?this.generateInputId(t+1):s}generateOutputId(t=this.numOutputs){const s=`o${t}`;return a(this,B).has(s)?this.generateOutputId(t+1):s}getInputById(t){if(typeof t!="string")throw new TypeError(N("inputId"));const s=a(this,w).get(t);if(s instanceof Rt)return s;throw new Error(_t(this.id,"input",t))}input(t){if(typeof t!="number")throw new TypeError(Mt("position"));const s=a(this,G)[t];if(d.isUndefined(s))throw new Error(Lt(this.id,"input",t));return this.getInputById(s)}getOutputById(t){if(typeof t!="string")throw new TypeError(N("outputId"));const s=a(this,B).get(t);if(s instanceof zt)return s;throw new Error(_t(this.id,"output",t))}output(t){if(typeof t!="number")throw new TypeError(Mt("position"));const s=a(this,U)[t];if(d.isUndefined(s))throw new Error(Lt(this.id,"output",t));return this.getOutputById(s)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),a(this,w).delete(t),a(this,G).splice(a(this,G).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),a(this,B).delete(t),a(this,U).splice(a(this,U).indexOf(t),1)}onBeforeConnectInput(t,s){}onCreate(){}newInput(t){const s=d.isDflowId(t.id)?t.id:this.generateInputId(),i=new Rt(b(l({},t),{id:s}));return a(this,w).set(s,i),a(this,G).push(s),i}newOutput(t){const s=d.isDflowId(t.id)?t.id:this.generateOutputId(),i=new zt(b(l({},t),{id:s}));return a(this,B).set(s,i),a(this,U).push(s),i}run(){throw new Error(`${this.constructor.name} does not implement a run() method`)}toObject(){const t=b(l({},super.toObject()),{kind:this.kind}),s=[],i=[];for(const r of this.inputs)s.push(r.toObject());s.length>0&&(t.inputs=s);for(const r of this.outputs)i.push(r.toObject());return i.length>0&&(t.outputs=i),t}};let n=Wt;w=new WeakMap,B=new WeakMap,G=new WeakMap,U=new WeakMap,Gt=new WeakMap,e(n,"kind"),e(n,"isAsync"),e(n,"isConstant"),e(n,"label"),e(n,"inputs"),e(n,"outputs");const Qt=class extends n{constructor(t,s){super(b(l({},t),{kind:Qt.kind}),s)}run(){}};let Ft=Qt;e(Ft,"kind","Unknown");class K extends C{constructor(r){var o=r,{source:t,target:s}=o,i=T(o,["source","target"]);super(i);e(this,"source");e(this,"target");const[c,h]=t,[y,g]=s;if(typeof c!="string")throw new TypeError(N("sourceNodeId"));if(typeof h!="string")throw new TypeError(N("sourcePinId"));if(typeof y!="string")throw new TypeError(N("targetNodeId"));if(typeof g!="string")throw new TypeError(N("targetPinId"));this.source=t,this.target=s}static isDflowEdge(o,r){var c=o,{source:t,target:s}=c,i=T(c,["source","target"]);return C.isDflowItem(i)&&Array.isArray(t)&&t.length===2&&r.nodes.find(({id:h,outputs:y=[]})=>h===t[0]&&y.find(({id:g})=>g===t[1]))&&Array.isArray(s)&&s.length===2&&r.nodes.find(({id:h,inputs:y=[]})=>h===s[0]&&y.find(({id:g})=>g===s[1]))}toObject(){return b(l({},super.toObject()),{source:this.source,target:this.target})}}const v=class extends C{constructor(){super(...arguments);m(this,f,new Map);m(this,I,new Map);e(this,"runOptions",{verbose:!1});e(this,"runStatus",null);e(this,"executionReport",null)}static isDflowGraph(t){return t.nodes.every(s=>n.isDflowNode(s))&&t.edges.every(s=>K.isDflowEdge(s,t))}static childrenOfNodeId(t,s){return s.filter(({sourceId:i})=>t===i).map(({targetId:i})=>i)}static parentsOfNodeId(t,s){return s.filter(({targetId:i})=>t===i).map(({sourceId:i})=>i)}static levelOfNodeId(t,s){const i=v.parentsOfNodeId(t,s);if(i.length===0)return 0;let r=0;for(const o of i){const c=v.levelOfNodeId(o,s);r=Math.max(c,r)}return r+1}static ancestorsOfNodeId(t,s){const i=v.parentsOfNodeId(t,s);return i.length===0?[]:i.reduce((r,o,c,h)=>{const y=v.ancestorsOfNodeId(o,s),g=r.concat(y);return c===h.length-1?Array.from(new Set(h.concat(g))):g},[])}static sort(t,s){const i={};for(const r of t)i[r]=v.levelOfNodeId(r,s);return t.slice().sort((r,o)=>i[r]<=i[o]?-1:1)}get edges(){return a(this,I).values()}get nodes(){return a(this,f).values()}get nodeConnections(){return[...a(this,I).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...a(this,I).keys()]}get nodeIds(){return[...a(this,f).keys()]}get numEdges(){return a(this,I).size}get numNodes(){return a(this,f).size}addEdge(t){if(a(this,I).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);a(this,I).set(t.id,t)}addNode(t){if(a(this,f).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);a(this,f).set(t.id,t)}clear(){a(this,f).clear(),a(this,I).clear()}deleteEdge(t){a(this,I).delete(t)}deleteNode(t){a(this,f).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(N("nodeId"));const s=a(this,f).get(t);if(s instanceof n)return s;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(N("edgeId"));const s=a(this,I).get(t);if(s instanceof K)return s;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const s=`e${t}`;return a(this,I).has(s)?this.generateEdgeId(t+1):s}generateNodeId(t=this.numNodes){const s=`n${t}`;return a(this,f).has(s)?this.generateNodeId(t+1):s}nodeIdsInsideFunctions(){const t=[];for(const s of this.nodes)s.kind==="return"&&t.push(v.ancestorsOfNodeId(s.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){var r;const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const s=this.nodeIdsInsideFunctions(),i=v.sort(this.nodeIds.filter(o=>!s.includes(o)),this.nodeConnections);for(const o of i){const c=a(this,f).get(o);try{if(!c.meta.isConstant){let h=!1;for(const{data:y,types:g,isOptional:O}of c.inputs)if(!(O&&typeof y=="undefined")&&!d.validate(y,g)){h=!0;break}if(h){for(const y of c.outputs)y.clear();break}c.meta.isAsync?await c.run():c.run()}t&&((r=this.executionReport.steps)==null||r.push(Dt(c.toObject())))}catch(h){console.error(h),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=b(l({},super.toObject()),{nodes:[],edges:[]});for(const s of this.nodes)t.nodes.push(s.toObject());for(const s of this.edges)t.edges.push(s.toObject());return t}};let $=v;f=new WeakMap,I=new WeakMap;class us{constructor(t={}){m(this,p,void 0);m(this,z,void 0);e(this,"context");x(this,z,t),x(this,p,new $({id:"g1"})),this.context={}}get executionReport(){return a(this,p).executionReport}get edges(){return a(this,p).edges}get nodes(){return a(this,p).nodes}get numEdges(){return a(this,p).numEdges}get numNodes(){return a(this,p).numNodes}get nodeKinds(){return Object.keys(a(this,z))}get runStatusIsSuccess(){return a(this,p).runStatus==="success"}get runStatusIsWaiting(){return a(this,p).runStatus==="waiting"}get runStatusIsFailure(){return a(this,p).runStatus==="failure"}set verbose(t){a(this,p).runOptions.verbose=t}clearGraph(){a(this,p).clear()}connect(t,s=0){return{to:(i,r=0)=>{const o=a(this,p).generateEdgeId(),c=t.output(s),h=i.input(r);i.onBeforeConnectInput(t,s),this.newEdge({id:o,source:[t.id,c.id],target:[i.id,h.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(N("edgeId"));const s=a(this,p).getEdgeById(t);if(s instanceof K){const[i,r]=s.target;this.getNodeById(i).getInputById(r).disconnect(),a(this,p).deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(N("nodeId"));const s=this.getNodeById(t);if(s instanceof n){for(const i of a(this,p).edges){const{source:[r],target:[o]}=i;(r===s.id||o===s.id)&&this.deleteEdge(i.id)}a(this,p).deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,s]){for(const i of this.edges){const[r,o]=i.source,[c,h]=i.target;(r===t&&o===s||c===t&&h===s)&&this.deleteEdge(i.id)}}executeFunction(t,s){var g,O,j;const{verbose:i}=a(this,p).runOptions,r=a(this,p).nodeConnections,o=$.childrenOfNodeId(t,r),c=[];for(const F of o){const k=this.getNodeById(F);k.kind==="return"&&c.push(k.id)}const h=c.reduce((F,k,H,ts)=>{const ss=$.ancestorsOfNodeId(k,r),Vt=F.concat(ss);return H===ts.length?Array.from(new Set(Vt)):Vt},[]),y=$.sort([...c,...h],r);for(const F of y){const k=this.getNodeById(F);try{switch(k.kind){case"argument":{const H=Math.max((g=k.input(1).data)!=null?g:0,0);k.output(0).data=s[H];break}case"return":return k.input(1).data;default:k.meta.isConstant||k.run(),i&&((j=(O=this.executionReport)==null?void 0:O.steps)==null||j.push(Dt(k.toObject())))}}catch(H){console.error(H)}}}getEdgeById(t){return a(this,p).getEdgeById(t)}getNodeById(t){return a(this,p).getNodeById(t)}newNode(t){var y;const s=(y=a(this,z)[t.kind])!=null?y:Ft,i=d.isDflowId(t.id)?t.id:a(this,p).generateNodeId(),r={isAsync:s.isAsync,isConstant:s.isConstant,label:s.label},o=Array.isArray(t.inputs)?t.inputs:n.generateInputIds(s.inputs),c=Array.isArray(t.outputs)?t.outputs:n.generateOutputIds(s.outputs),h=new s(b(l({},t),{id:i,inputs:o,outputs:c}),this,r);return a(this,p).addNode(h),h}newEdge(t){const s=d.isDflowId(t.id)?t.id:a(this,p).generateEdgeId(),i=new K(b(l({},t),{id:s}));a(this,p).addEdge(i);const[r,o]=i.source,[c,h]=i.target,y=a(this,p).getNodeById(r),g=a(this,p).getNodeById(c),O=y.getOutputById(o);return g.getInputById(h).connectTo(O),i}newInput(t,s){return a(this,p).getNodeById(t).newInput(s)}newOutput(t,s){return a(this,p).getNodeById(t).newOutput(s)}toObject(){return a(this,p).toObject()}async run(){await a(this,p).run()}}p=new WeakMap,z=new WeakMap;export{d as DflowData};export{C as DflowItem};export{P as DflowPin};export{Rt as DflowInput};export{zt as DflowOutput};export{n as DflowNode};export{Ft as DflowUnknownNode};export{K as DflowEdge};export{$ as DflowGraph};export{us as DflowHost};class W extends n{run(){this.output(0).data=this.input(0).data.filter((...t)=>this.host.executeFunction(this.input(1).data,t))}}e(W,"kind","arrayFilter"),e(W,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),e(W,"outputs",n.out(["array"]));class J extends n{run(){const t=this.input(0).data,s=this.input(1).data;Array.isArray(t)&&(this.output(0).data=t.includes(s))}}e(J,"kind","arrayIncludes"),e(J,"inputs",[...n.in(["array"],{name:"array"}),...n.in(["string"],{name:"element"})]),e(J,"outputs",n.out(["boolean"]));class Q extends n{run(){var i;const t=this.input(0).data,s=(i=this.input(1).data)!=null?i:",";Array.isArray(t)&&(this.output(0).data=t.join(s))}}e(Q,"kind","arrayJoin"),e(Q,"inputs",[...n.in(["array"],{name:"array"}),...n.in(["string"],{name:"separator",optional:!0})]),e(Q,"outputs",n.out(["string"]));class V extends n{run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t.length:this.output(0).clear}}e(V,"kind","arrayLength"),e(V,"inputs",n.in(["array"])),e(V,"outputs",n.out(["number"]));class X extends n{run(){this.output(0).data=this.input(0).data.map((...t)=>this.host.executeFunction(this.input(1).data,t))}}e(X,"kind","arrayMap"),e(X,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),e(X,"outputs",n.out(["array"]));class Y extends n{run(){const t=this.input(0).data.slice(),s=t.pop();this.output(0).data=s,this.output(1).data=t}}e(Y,"kind","arrayPop"),e(Y,"inputs",n.in(["array"])),e(Y,"outputs",[...n.out([],{name:"element"}),...n.out(["array"],{name:"rest"})]);class Z extends n{run(){const t=this.input(0).data.slice();this.output(0).data=t.reverse()}}e(Z,"kind","arrayReverse"),e(Z,"inputs",n.in(["array"])),e(Z,"outputs",n.in(["array"]));class M extends n{run(){const t=this.input(0).data.slice(),s=t.shift();this.output(0).data=s,this.output(1).data=t}}e(M,"kind","arrayShift"),e(M,"inputs",n.in(["array"])),e(M,"outputs",[...n.out([],{name:"element"}),...n.out(["array"],{name:"rest"})]);class q extends n{run(){const t=this.input(0).data,s=this.input(1).data,i=this.input(2).data;typeof i=="number"?this.output(0).data=t.slice(s,i):this.output(0).data=t.slice(s)}}e(q,"kind","arraySlice"),e(q,"inputs",[...n.in(["array"]),...n.in(["number"],{name:"start"}),...n.in(["number"],{name:"end",optional:!0})]),e(q,"outputs",n.out(["array"]));const as={[W.kind]:W,[J.kind]:J,[Q.kind]:Q,[V.kind]:V,[X.kind]:X,[Y.kind]:Y,[Z.kind]:Z,[M.kind]:M,[q.kind]:q};class L extends n{run(){this.output(0).data=this.input(0).data?this.input(1).data:this.input(2).data}}e(L,"kind","if"),e(L,"inputs",[...n.in(["boolean"],{name:"condition"}),...n.in([],{name:"then"}),...n.in([],{name:"else"})]),e(L,"outputs",n.out());const rs={[L.kind]:L};class Ht extends n{run(){console.log(this.input(0).data)}}e(Ht,"kind","consoleLog"),e(Ht,"inputs",[...n.in([])]);const os={[Ht.kind]:Ht};class _ extends n{}e(_,"kind","data"),e(_,"outputs",n.out()),e(_,"isConstant",!0);class D extends n{}e(D,"kind","array"),e(D,"outputs",n.out(["array"])),e(D,"isConstant",!0);class tt extends n{}e(tt,"kind","boolean"),e(tt,"outputs",n.out(["boolean"])),e(tt,"isConstant",!0);class st extends n{}e(st,"kind","number"),e(st,"outputs",n.out(["number"])),e(st,"isConstant",!0);class et extends n{}e(et,"kind","object"),e(et,"outputs",n.out(["object"])),e(et,"isConstant",!0);class nt extends n{}e(nt,"kind","string"),e(nt,"outputs",n.out(["string"])),e(nt,"isConstant",!0);const ds={[_.kind]:_,[D.kind]:D,[tt.kind]:tt,[st.kind]:st,[et.kind]:et,[nt.kind]:nt};class A extends n{run(){const t=this.output(0);t.data=this.host.nodeKinds}}e(A,"kind","dflow"),e(A,"outputs",n.out(["array"],{name:"nodeKinds"}));class it extends n{}e(it,"kind","comment"),e(it,"isConstant",!0),e(it,"outputs",n.out(["string"]));class ut extends n{}e(ut,"kind","typeNumber"),e(ut,"isConstant",!0),e(ut,"outputs",n.out(["DflowType"],{name:"number",data:"number"}));class R extends n{onBeforeConnectInput(t,s){const i=t.output(s).data;this.output(0).addType(i)}}e(R,"kind","argument"),e(R,"isConstant",!0),e(R,"inputs",[...n.in(["DflowType"],{name:"type"}),...n.in(["number"],{name:"argumentPosition"})]),e(R,"outputs",n.out());class at extends n{onCreate(){this.output(0).data=this.id}}e(at,"kind","function"),e(at,"isConstant",!0),e(at,"outputs",A.out(["DflowId"],{name:"id"}));class rt extends n{}e(rt,"kind","return"),e(rt,"isConstant",!0),e(rt,"inputs",[...A.in(["DflowId"],{name:"functionId"}),...A.in([],{name:"value"})]);const cs={[A.kind]:A,[R.kind]:R,[it.kind]:it,[at.kind]:at,[rt.kind]:rt,[ut.kind]:ut};class ot extends n{run(){this.output(0).data=this.input(0).data&&this.input(1).data}}e(ot,"kind","and"),e(ot,"inputs",n.ins(2,["boolean"])),e(ot,"outputs",n.out(["boolean"]));class dt extends n{run(){this.output(0).data=!this.input(0).data}}e(dt,"kind","not"),e(dt,"inputs",n.in(["boolean"])),e(dt,"outputs",n.out(["boolean"]));class ct extends n{run(){this.output(0).data=this.input(0).data||this.input(1).data}}e(ct,"kind","or"),e(ct,"inputs",n.ins(2,["boolean"])),e(ct,"outputs",n.out(["boolean"]));const ps={[ot.kind]:ot,[dt.kind]:dt,[ct.kind]:ct};class pt extends n{run(){this.output(0).data=Math.cos(this.input(0).data)}}e(pt,"kind","mathCos"),e(pt,"inputs",n.in(["number"])),e(pt,"outputs",n.out(["number"]));class ht extends n{run(){this.output(0).data=Math.cosh(this.input(0).data)}}e(ht,"kind","mathCosh"),e(ht,"inputs",n.in(["number"])),e(ht,"outputs",n.out(["number"]));class lt extends n{}e(lt,"kind","mathPI"),e(lt,"isConstant",!0),e(lt,"outputs",n.out(["number"],{name:"\u03C0",data:Math.PI}));class yt extends n{run(){this.output(0).data=Math.sin(this.input(0).data)}}e(yt,"kind","mathSin"),e(yt,"inputs",n.in(["number"])),e(yt,"outputs",n.out(["number"]));class gt extends n{run(){this.output(0).data=Math.sinh(this.input(0).data)}}e(gt,"kind","mathSinh"),e(gt,"inputs",n.in(["number"])),e(gt,"outputs",n.out(["number"]));const hs={[pt.kind]:pt,[ht.kind]:ht,[lt.kind]:lt,[yt.kind]:yt,[gt.kind]:gt};class mt extends n{run(){this.output(0).data=Number.isFinite(this.input(0).data)}}e(mt,"kind","isFinite"),e(mt,"inputs",n.in(["number"])),e(mt,"outputs",n.out(["boolean"]));class ft extends n{run(){this.output(0).data=Number.isInteger(this.input(0).data)}}e(ft,"kind","isInteger"),e(ft,"inputs",n.in([])),e(ft,"outputs",n.out(["boolean"]));class It extends n{run(){this.output(0).data=Number.isNaN(this.input(0).data)}}e(It,"kind","isNaN"),e(It,"inputs",n.in([])),e(It,"outputs",n.out(["boolean"]));class kt extends n{run(){this.output(0).data=parseFloat(this.input(0).data)}}e(kt,"kind","parseFloat"),e(kt,"inputs",n.in(["string"])),e(kt,"outputs",n.out(["number"]));class bt extends n{run(){this.output(0).data=parseInt(this.input(0).data)}}e(bt,"kind","parseInt"),e(bt,"inputs",n.in(["number","string"])),e(bt,"outputs",n.out(["number"]));const ls={[mt.kind]:mt,[ft.kind]:ft,[It.kind]:It,[kt.kind]:kt,[bt.kind]:bt};class xt extends n{run(){this.output(0).data=Object.keys(this.input(0).data)}}e(xt,"kind","objectKeys"),e(xt,"inputs",n.in(["object"])),e(xt,"outputs",n.out(["array"]));class Nt extends n{run(){this.output(0).data=Object.values(this.input(0).data)}}e(Nt,"kind","objectValues"),e(Nt,"inputs",n.in(["object"])),e(Nt,"outputs",n.out(["array"]));const ys={[xt.kind]:xt,[Nt.kind]:Nt};class Ot extends n{run(){this.output(0).data=this.input(0).data+this.input(1).data}}e(Ot,"kind","addition"),e(Ot,"inputs",n.ins(2,["number"])),e(Ot,"outputs",n.out(["number"]));class Tt extends n{run(){this.input(1).data?this.output(0).data=this.input(0).data/this.input(1).data:this.output(0).clear()}}e(Tt,"kind","division"),e(Tt,"inputs",n.ins(2,["number"])),e(Tt,"outputs",n.out(["number"]));class Et extends n{run(){this.output(0).data=this.input(0).data==this.input(1).data}}e(Et,"kind","equality"),e(Et,"inputs",n.ins(2)),e(Et,"outputs",n.out(["boolean"]));class wt extends n{run(){this.output(0).data=this.input(0).data<this.input(1).data}}e(wt,"kind","lessThan"),e(wt,"inputs",n.ins(2,["number"])),e(wt,"outputs",n.out(["boolean"]));class Bt extends n{run(){this.output(0).data=this.input(0).data<=this.input(1).data}}e(Bt,"kind","lessThanOrEqual"),e(Bt,"inputs",n.ins(2,["number"])),e(Bt,"outputs",n.out(["boolean"]));class vt extends n{run(){this.output(0).data=this.input(0).data>this.input(1).data}}e(vt,"kind","greaterThan"),e(vt,"inputs",n.ins(2,["number"])),e(vt,"outputs",n.out(["boolean"]));class Ct extends n{run(){this.output(0).data=this.input(0).data>=this.input(1).data}}e(Ct,"kind","greaterThanOrEqual"),e(Ct,"inputs",n.ins(2,["number"])),e(Ct,"outputs",n.out(["boolean"]));class Pt extends n{run(){this.output(0).data=this.input(0).data!=this.input(1).data}}e(Pt,"kind","inequality"),e(Pt,"inputs",n.ins(2)),e(Pt,"outputs",n.out(["boolean"]));class jt extends n{run(){this.output(0).data=this.input(0).data*this.input(1).data}}e(jt,"kind","multiplication"),e(jt,"inputs",n.ins(2,["number"])),e(jt,"outputs",n.out(["number"]));class $t extends n{run(){this.output(0).data=this.input(0).data-this.input(1).data}}e($t,"kind","subtraction"),e($t,"inputs",n.ins(2,["number"])),e($t,"outputs",n.out(["number"]));const gs={[Ot.kind]:Ot,[Tt.kind]:Tt,[Et.kind]:Et,[vt.kind]:vt,[Ct.kind]:Ct,[wt.kind]:wt,[Bt.kind]:Bt,[Pt.kind]:Pt,[jt.kind]:jt,[$t.kind]:$t};class At extends n{run(){this.output(0).data=this.input(0).data.length}}e(At,"kind","stringLength"),e(At,"inputs",n.in(["string"])),e(At,"outputs",n.out(["number"]));const ms={[At.kind]:At},fs=l(l(l(l(l(l(l(l(l(l(l({},as),rs),os),ds),cs),ps),hs),ls),ys),gs),ms);export{fs as catalog};
