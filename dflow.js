var Kt=Object.defineProperty,Mt=Object.defineProperties;var Qt=Object.getOwnPropertyDescriptors;var Et=Object.getOwnPropertySymbols;var vt=Object.prototype.hasOwnProperty,Gt=Object.prototype.propertyIsEnumerable;var St=(r,t,s)=>t in r?Kt(r,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):r[t]=s,l=(r,t)=>{for(var s in t||(t={}))vt.call(t,s)&&St(r,s,t[s]);if(Et)for(var s of Et(t))Gt.call(t,s)&&St(r,s,t[s]);return r},k=(r,t)=>Mt(r,Qt(t));var B=(r,t)=>{var s={};for(var i in r)vt.call(r,i)&&t.indexOf(i)<0&&(s[i]=r[i]);if(r!=null&&Et)for(var i of Et(r))t.indexOf(i)<0&&Gt.call(r,i)&&(s[i]=r[i]);return s};var e=(r,t,s)=>(St(r,typeof t!="symbol"?t+"":t,s),s),Ut=(r,t,s)=>{if(!t.has(r))throw TypeError("Cannot "+s)};var u=(r,t,s)=>(Ut(r,t,"read from private field"),s?s.call(r):t.get(r)),f=(r,t,s)=>{if(t.has(r))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(r):t.set(r,s)},b=(r,t,s,i)=>(Ut(r,t,"write to private field"),i?i.call(r,s):t.set(r,s),s);var j,T,E,O,v,G,Tt,w,I,m,c,J;const x=r=>`${r} must be a string`,Ft=r=>`${r} must be a number`,Jt=(r,t)=>`${t} pin not found nodeId=${r}`,zt=(r,t,s)=>`${Jt(r,t)} position=${s}`,Wt=(r,t,s)=>`${Jt(r,t)} pinId=${s}`;class d{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowGraph(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&Array.isArray(t.nodes)&&Array.isArray(t.edges)&&S.isDflowGraph(t)}static isDflowId(t){return d.isStringNotEmpty(t)}static isDflowType(t){return typeof t=="string"&&P.types.includes(t)}static isObject(t){return!d.isUndefined(t)&&!d.isNull(t)&&!d.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return d.isString(t)&&t.length>0}static isUndefined(t){return typeof t=="undefined"}static validate(t,s){return s.length===0?!0:s.some(i=>{switch(i){case"array":return d.isArray(t);case"boolean":return d.isBoolean(t);case"null":return d.isNull(t);case"number":return d.isNumber(t);case"object":return d.isObject(t);case"string":return d.isString(t);case"DflowGraph":return d.isDflowGraph(t);case"DflowId":return d.isDflowId(t);case"DflowType":return d.isDflowType(t);default:return!1}},!0)}}class C{constructor({id:t,name:s}){e(this,"id");e(this,"name");this.id=t,this.name=s}static isDflowItem({id:t,name:s}){return d.isDflowId(t)&&(d.isUndefined(s)||d.isStringNotEmpty(s))}toJSON(){return JSON.stringify(this.toObject())}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const Ct=class extends C{constructor(t,o){var a=o,{types:s=[]}=a,i=B(a,["types"]);super(i);e(this,"kind");e(this,"types");this.kind=t,this.types=s}static isDflowPin(i){var o=i,{types:t=[]}=o,s=B(o,["types"]);return C.isDflowItem(s)&&t.every(a=>Ct.isDflowPinType(a))}static isDflowPinType(t){Ct.types.includes(t)}get hasTypeAny(){return this.types.length===0}get hasTypeDflowId(){return this.hasTypeAny||this.types.includes("DflowId")}get hasTypeDflowGraph(){return this.hasTypeAny||this.types.includes("DflowGraph")}get hasTypeDflowType(){return this.hasTypeAny||this.types.includes("DflowType")}get hasTypeString(){return this.hasTypeAny||this.types.includes("string")}get hasTypeNumber(){return this.hasTypeAny||this.types.includes("number")}get hasTypeBoolean(){return this.hasTypeAny||this.types.includes("boolean")}get hasTypeNull(){return this.hasTypeAny||this.types.includes("null")}get hasTypeObject(){return this.hasTypeAny||this.types.includes("object")}get hasTypeArray(){return this.hasTypeAny||this.types.includes("array")}addType(t){this.types.push(t)}removeType(t){this.types.splice(this.types.indexOf(t),1)}};let P=Ct;e(P,"types",["string","number","boolean","null","object","array","DflowId","DflowGraph","DflowType"]);class Ot extends P{constructor(t){super("input",t);f(this,j,void 0)}static isDflowInput({id:t,types:s}){return P.isDflowPin({id:t,types:s})}get data(){var t;return(t=u(this,j))==null?void 0:t.data}get isConnected(){return typeof u(this,j)=="undefined"}connectTo(t){const{hasTypeAny:s,types:i}=this,{types:o}=t;if(s||i.some(a=>o.includes(a)))b(this,j,t);else throw new Error(`mismatching pinTypes, source has types [${o.join()}] and target has types [${i.join()}]`)}disconnect(){b(this,j,void 0)}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}j=new WeakMap;class wt extends P{constructor(i){var o=i,{data:t}=o,s=B(o,["data"]);super("output",s);f(this,T,void 0);b(this,T,t)}static isDflowOutput({id:t,data:s,types:i=[]}){return P.isDflowPin({id:t,types:i})&&d.validate(s,i)}clear(){b(this,T,void 0)}get data(){return u(this,T)}set data(t){switch(!0){case d.isUndefined(t):this.clear();break;case this.hasTypeAny:case(d.isDflowGraph(t)&&this.hasTypeDflowGraph):case(d.isDflowId(t)&&this.hasTypeDflowId):case(d.isString(t)&&this.hasTypeString):case(d.isNumber(t)&&this.hasTypeNumber):case(d.isBoolean(t)&&this.hasTypeBoolean):case(d.isNull(t)&&this.hasTypeNull):case(d.isObject(t)&&this.hasTypeObject):case(d.isArray(t)&&this.hasTypeArray):{b(this,T,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=l({},super.toObject());return d.isUndefined(u(this,T))||(t.data=u(this,T)),this.types.length>0&&(t.types=this.types),t}}T=new WeakMap;const Pt=class extends C{constructor(g,a,{isAsync:p=!1,isConstant:h=!1,label:y}={}){var N=g,{kind:t,inputs:s=[],outputs:i=[]}=N,o=B(N,["kind","inputs","outputs"]);super(o);f(this,E,new Map);f(this,O,new Map);f(this,v,[]);f(this,G,[]);f(this,Tt,void 0);e(this,"kind");e(this,"meta");e(this,"host");b(this,Tt,y),this.host=a,this.kind=t,this.meta={isAsync:p,isConstant:h};for(const U of s)this.newInput(U);for(const U of i)this.newOutput(U);this.onCreate()}static generateInputIds(t=[]){return t.map((s,i)=>k(l({},s),{id:`i${i}`}))}static generateOutputIds(t=[]){return t.map((s,i)=>k(l({},s),{id:`o${i}`}))}static in(t=[],s){return[l({types:t},s)]}static ins(t,s=[]){return Array(t).fill(Pt.in(s)).flat()}static out(t=[],s){return[l({types:t},s)]}static outs(t,s=[]){return Array(t).fill(Pt.out(s)).flat()}static outputNumber(t){return k(l({},t),{types:["number"]})}static isDflowNode(a){var p=a,{kind:t,inputs:s=[],outputs:i=[]}=p,o=B(p,["kind","inputs","outputs"]);return C.isDflowItem(o)&&d.isStringNotEmpty(t)&&s.every(h=>Ot.isDflowInput(h))&&i.every(h=>wt.isDflowOutput(h))}get label(){return u(this,Tt)||this.kind}get inputs(){return u(this,E).values()}get outputs(){return u(this,O).values()}get numInputs(){return u(this,E).size}get numOutputs(){return u(this,O).size}generateInputId(t=this.numInputs){const s=`i${t}`;return u(this,E).has(s)?this.generateInputId(t+1):s}generateOutputId(t=this.numOutputs){const s=`o${t}`;return u(this,O).has(s)?this.generateOutputId(t+1):s}getInputById(t){if(typeof t!="string")throw new TypeError(x("inputId"));const s=u(this,E).get(t);if(s instanceof Ot)return s;throw new Error(Wt(this.id,"input",t))}input(t){if(typeof t!="number")throw new TypeError(Ft("position"));const s=u(this,v)[t];if(d.isUndefined(s))throw new Error(zt(this.id,"input",t));return this.getInputById(s)}getOutputById(t){if(typeof t!="string")throw new TypeError(x("outputId"));const s=u(this,O).get(t);if(s instanceof wt)return s;throw new Error(Wt(this.id,"output",t))}output(t){if(typeof t!="number")throw new TypeError(Ft("position"));const s=u(this,G)[t];if(d.isUndefined(s))throw new Error(zt(this.id,"output",t));return this.getOutputById(s)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),u(this,E).delete(t),u(this,v).splice(u(this,v).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),u(this,O).delete(t),u(this,G).splice(u(this,G).indexOf(t),1)}onBeforeConnectInput(t,s){}onCreate(){}newInput(t){const s=d.isDflowId(t.id)?t.id:this.generateInputId(),i=new Ot(k(l({},t),{id:s}));return u(this,E).set(s,i),u(this,v).push(s),i}newOutput(t){const s=d.isDflowId(t.id)?t.id:this.generateOutputId(),i=new wt(k(l({},t),{id:s}));return u(this,O).set(s,i),u(this,G).push(s),i}run(){throw new Error(`${this.constructor.name} does not implement a run() method`)}toObject(){const t=k(l({},super.toObject()),{kind:this.kind}),s=[],i=[];for(const o of this.inputs)s.push(o.toObject());s.length>0&&(t.inputs=s);for(const o of this.outputs)i.push(o.toObject());return i.length>0&&(t.outputs=i),t}};let n=Pt;E=new WeakMap,O=new WeakMap,v=new WeakMap,G=new WeakMap,Tt=new WeakMap,e(n,"kind"),e(n,"isAsync"),e(n,"isConstant"),e(n,"label"),e(n,"inputs"),e(n,"outputs");const $t=class extends n{constructor(t,s){super(k(l({},t),{kind:$t.kind}),s)}run(){}};let At=$t;e(At,"kind","Unknown");class z extends C{constructor(o){var a=o,{source:t,target:s}=a,i=B(a,["source","target"]);super(i);e(this,"source");e(this,"target");const[p,h]=t,[y,g]=s;if(typeof p!="string")throw new TypeError(x("sourceNodeId"));if(typeof h!="string")throw new TypeError(x("sourcePinId"));if(typeof y!="string")throw new TypeError(x("targetNodeId"));if(typeof g!="string")throw new TypeError(x("targetPinId"));this.source=t,this.target=s}static isDflowEdge(a,o){var p=a,{source:t,target:s}=p,i=B(p,["source","target"]);return C.isDflowItem(i)&&Array.isArray(t)&&t.length===2&&o.nodes.find(({id:h,outputs:y=[]})=>h===t[0]&&y.find(({id:g})=>g===t[1]))&&Array.isArray(s)&&s.length===2&&o.nodes.find(({id:h,inputs:y=[]})=>h===s[0]&&y.find(({id:g})=>g===s[1]))}toObject(){return k(l({},super.toObject()),{source:this.source,target:this.target})}}const A=class extends C{constructor(){super(...arguments);f(this,w,"success");f(this,I,new Map);f(this,m,new Map)}static isDflowGraph(t){return t.nodes.every(s=>n.isDflowNode(s))&&t.edges.every(s=>z.isDflowEdge(s,t))}static childrenOfNodeId(t,s){return s.filter(({sourceId:i})=>t===i).map(({targetId:i})=>i)}static parentsOfNodeId(t,s){return s.filter(({targetId:i})=>t===i).map(({sourceId:i})=>i)}static levelOfNodeId(t,s){const i=A.parentsOfNodeId(t,s);if(i.length===0)return 0;let o=0;for(const a of i){const p=A.levelOfNodeId(a,s);o=Math.max(p,o)}return o+1}static ancestorsOfNodeId(t,s){const i=A.parentsOfNodeId(t,s);return i.length===0?[]:i.reduce((o,a,p,h)=>{const y=A.ancestorsOfNodeId(a,s),g=o.concat(y);return p===h.length-1?Array.from(new Set(h.concat(g))):g},[])}static sort(t,s){const i={};for(const o of t)i[o]=A.levelOfNodeId(o,s);return t.slice().sort((o,a)=>i[o]<=i[a]?-1:1)}get edges(){return u(this,m).values()}get nodes(){return u(this,I).values()}get nodeConnections(){return[...u(this,m).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...u(this,m).keys()]}get nodeIds(){return[...u(this,I).keys()]}get numEdges(){return u(this,m).size}get numNodes(){return u(this,I).size}get runStatusIsSuccess(){return u(this,w)==="success"}get runStatusIsWaiting(){return u(this,w)==="waiting"}get runStatusIsFailure(){return u(this,w)==="failure"}addEdge(t){if(u(this,m).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);u(this,m).set(t.id,t)}addNode(t){if(u(this,I).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);u(this,I).set(t.id,t)}clear(){u(this,I).clear(),u(this,m).clear()}deleteEdge(t){u(this,m).delete(t)}deleteNode(t){u(this,I).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(x("nodeId"));const s=u(this,I).get(t);if(s instanceof n)return s;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(x("edgeId"));const s=u(this,m).get(t);if(s instanceof z)return s;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const s=`e${t}`;return u(this,m).has(s)?this.generateEdgeId(t+1):s}generateNodeId(t=this.numNodes){const s=`n${t}`;return u(this,I).has(s)?this.generateNodeId(t+1):s}nodeIdsInsideFunctions(){const t=[];for(const s of this.nodes)s.kind==="return"&&t.push(A.ancestorsOfNodeId(s.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){this.runStatusIsSuccess&&b(this,w,"waiting");const t=this.nodeIdsInsideFunctions(),s=A.sort(this.nodeIds.filter(i=>!t.includes(i)),this.nodeConnections);for(const i of s){const o=u(this,I).get(i);try{if(o.meta.isConstant===!1){let a=!1;for(const{data:p,types:h}of o.inputs)if(!d.validate(p,h)){a=!0;break}if(a){for(const p of o.outputs)p.clear();break}o.meta.isAsync?await o.run():o.run()}}catch(a){console.error(a),b(this,w,"failure")}}this.runStatusIsWaiting&&b(this,w,"success")}toObject(){const t=k(l({},super.toObject()),{nodes:[],edges:[]});for(const s of this.nodes)t.nodes.push(s.toObject());for(const s of this.edges)t.edges.push(s.toObject());return t}};let S=A;w=new WeakMap,I=new WeakMap,m=new WeakMap;class Vt{constructor(t={}){f(this,c,void 0);f(this,J,void 0);b(this,J,t),b(this,c,new S({id:"g1"}))}get edges(){return u(this,c).edges}get nodes(){return u(this,c).nodes}get numEdges(){return u(this,c).numEdges}get numNodes(){return u(this,c).numNodes}get nodeKinds(){return Object.keys(u(this,J))}get runStatusIsSuccess(){return u(this,c).runStatusIsSuccess}get runStatusIsWaiting(){return u(this,c).runStatusIsWaiting}get runStatusIsFailure(){return u(this,c).runStatusIsFailure}clearGraph(){u(this,c).clear()}connect(t,s=0){return{to:(i,o=0)=>{const a=u(this,c).generateEdgeId(),p=t.output(s),h=i.input(o);i.onBeforeConnectInput(t,s),this.newEdge({id:a,source:[t.id,p.id],target:[i.id,h.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(x("edgeId"));const s=u(this,c).getEdgeById(t);if(s instanceof z){const[i,o]=s.target;this.getNodeById(i).getInputById(o).disconnect(),u(this,c).deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(x("nodeId"));const s=this.getNodeById(t);if(s instanceof n){for(const i of u(this,c).edges){const{source:[o],target:[a]}=i;(o===s.id||a===s.id)&&this.deleteEdge(i.id)}u(this,c).deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,s]){for(const i of this.edges){const[o,a]=i.source,[p,h]=i.target;(o===t&&a===s||p===t&&h===s)&&this.deleteEdge(i.id)}}executeFunction(t,s){const i=u(this,c).nodeConnections,o=S.childrenOfNodeId(t,i),a=[];for(const y of o){const g=this.getNodeById(y);g.kind==="return"&&a.push(g.id)}const p=a.reduce((y,g,N,U)=>{const Ht=S.ancestorsOfNodeId(g,i),jt=y.concat(Ht);return N===U.length?Array.from(new Set(jt)):jt},[]),h=S.sort([...a,...p],i);for(const y of h){const g=this.getNodeById(y);try{switch(g.kind){case"argument":{const N=0;g.output(0).data=s[N];break}case"return":return g.input(1).data;default:g.meta.isConstant||g.run()}}catch(N){console.error(N)}}}getEdgeById(t){return u(this,c).getEdgeById(t)}getNodeById(t){return u(this,c).getNodeById(t)}newNode(t){var y;const s=(y=u(this,J)[t.kind])!=null?y:At,i=d.isDflowId(t.id)?t.id:u(this,c).generateNodeId(),o={isAsync:s.isAsync,isConstant:s.isConstant,label:s.label},a=Array.isArray(t.inputs)?t.inputs:n.generateInputIds(s.inputs),p=Array.isArray(t.outputs)?t.outputs:n.generateOutputIds(s.outputs),h=new s(k(l({},t),{id:i,inputs:a,outputs:p}),this,o);return u(this,c).addNode(h),h}newEdge(t){const s=d.isDflowId(t.id)?t.id:u(this,c).generateEdgeId(),i=new z(k(l({},t),{id:s}));u(this,c).addEdge(i);const[o,a]=i.source,[p,h]=i.target,y=u(this,c).getNodeById(o),g=u(this,c).getNodeById(p),N=y.getOutputById(a);return g.getInputById(h).connectTo(N),i}newInput(t,s){return u(this,c).getNodeById(t).newInput(s)}newOutput(t,s){return u(this,c).getNodeById(t).newOutput(s)}toJSON(){return u(this,c).toJSON()}toObject(){return u(this,c).toObject()}async run(){await u(this,c).run()}}c=new WeakMap,J=new WeakMap;export{d as DflowData};export{C as DflowItem};export{P as DflowPin};export{Ot as DflowInput};export{wt as DflowOutput};export{n as DflowNode};export{At as DflowUnknownNode};export{z as DflowEdge};export{S as DflowGraph};export{Vt as DflowHost};class W extends n{run(){this.output(0).data=this.input(0).data.filter((...t)=>this.host.executeFunction(this.input(1).data,t))}}e(W,"kind","arrayFilter"),e(W,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),e(W,"outputs",n.out(["array"]));class H extends n{run(){this.output(0).data=this.input(0).data.length}}e(H,"kind","arrayLength"),e(H,"inputs",n.in(["array"])),e(H,"outputs",n.out(["number"]));const Xt={[W.kind]:W,[H.kind]:H};class K extends n{run(){this.output(0).data=this.input(0).data?this.input(1).data:this.input(2).data}}e(K,"kind","if"),e(K,"inputs",[...n.in(["boolean"],{name:"condition"}),...n.in([],{name:"then"}),...n.in([],{name:"else"})]),e(K,"outputs",n.out());const Yt={[K.kind]:K};class Bt extends n{run(){console.log(this.input(0).data)}}e(Bt,"kind","consoleLog"),e(Bt,"inputs",[...n.in([])]);const Zt={[Bt.kind]:Bt};class M extends n{}e(M,"kind","data"),e(M,"outputs",n.out()),e(M,"isConstant",!0);class Q extends n{}e(Q,"kind","array"),e(Q,"outputs",n.out(["array"])),e(Q,"isConstant",!0);class V extends n{}e(V,"kind","boolean"),e(V,"outputs",n.out(["boolean"])),e(V,"isConstant",!0);class X extends n{}e(X,"kind","number"),e(X,"outputs",n.out(["number"])),e(X,"isConstant",!0);class Y extends n{}e(Y,"kind","object"),e(Y,"outputs",n.out(["object"])),e(Y,"isConstant",!0);class Z extends n{}e(Z,"kind","string"),e(Z,"outputs",n.out(["string"])),e(Z,"isConstant",!0);const Rt={[M.kind]:M,[Q.kind]:Q,[V.kind]:V,[X.kind]:X,[Y.kind]:Y,[Z.kind]:Z};class $ extends n{run(){const t=this.output(0);t.data=this.host.nodeKinds}}e($,"kind","dflow"),e($,"outputs",n.out(["array"],{name:"nodeKinds"}));class R extends n{}e(R,"kind","comment"),e(R,"isConstant",!0),e(R,"outputs",n.out(["string"]));class q extends n{}e(q,"kind","typeNumber"),e(q,"isConstant",!0),e(q,"outputs",n.out(["DflowType"],{name:"number",data:"number"}));class F extends n{onBeforeConnectInput(t,s){const i=t.output(s).data;this.output(0).addType(i)}}e(F,"kind","argument"),e(F,"isConstant",!0),e(F,"inputs",[...n.in(["DflowType"],{name:"type"})]),e(F,"outputs",n.out());class L extends n{onCreate(){this.output(0).data=this.id}}e(L,"kind","function"),e(L,"isConstant",!0),e(L,"outputs",$.out(["DflowId"],{name:"id"}));class _ extends n{}e(_,"kind","return"),e(_,"isConstant",!0),e(_,"inputs",[...$.in(["DflowId"],{name:"functionId"}),...$.in([],{name:"value"})]);const qt={[$.kind]:$,[F.kind]:F,[R.kind]:R,[L.kind]:L,[_.kind]:_,[q.kind]:q};class D extends n{run(){this.output(0).data=this.input(0).data&&this.input(1).data}}e(D,"kind","and"),e(D,"inputs",n.ins(2,["boolean"])),e(D,"outputs",n.out(["boolean"]));class tt extends n{run(){this.output(0).data=!this.input(0).data}}e(tt,"kind","not"),e(tt,"inputs",n.in(["boolean"])),e(tt,"outputs",n.out(["boolean"]));class st extends n{run(){this.output(0).data=this.input(0).data||this.input(1).data}}e(st,"kind","or"),e(st,"inputs",n.ins(2,["boolean"])),e(st,"outputs",n.out(["boolean"]));const Lt={[D.kind]:D,[tt.kind]:tt,[st.kind]:st};class et extends n{run(){this.output(0).data=Math.cos(this.input(0).data)}}e(et,"kind","mathCos"),e(et,"inputs",n.in(["number"])),e(et,"outputs",n.out(["number"]));class nt extends n{run(){this.output(0).data=Math.cosh(this.input(0).data)}}e(nt,"kind","mathCosh"),e(nt,"inputs",n.in(["number"])),e(nt,"outputs",n.out(["number"]));class it extends n{}e(it,"kind","mathPI"),e(it,"isConstant",!0),e(it,"outputs",n.out(["number"],{data:Math.PI}));class rt extends n{run(){this.output(0).data=Math.sin(this.input(0).data)}}e(rt,"kind","mathSin"),e(rt,"inputs",n.in(["number"])),e(rt,"outputs",n.out(["number"]));class ut extends n{run(){this.output(0).data=Math.sinh(this.input(0).data)}}e(ut,"kind","mathSinh"),e(ut,"inputs",n.in(["number"])),e(ut,"outputs",n.out(["number"]));const _t={[et.kind]:et,[nt.kind]:nt,[it.kind]:it,[rt.kind]:rt,[ut.kind]:ut};class ot extends n{run(){this.output(0).data=Number.isFinite(this.input(0).data)}}e(ot,"kind","isFinite"),e(ot,"inputs",n.in(["number"])),e(ot,"outputs",n.out(["boolean"]));class at extends n{run(){this.output(0).data=Number.isInteger(this.input(0).data)}}e(at,"kind","isInteger"),e(at,"inputs",n.in([])),e(at,"outputs",n.out(["boolean"]));class dt extends n{run(){this.output(0).data=Number.isNaN(this.input(0).data)}}e(dt,"kind","isNaN"),e(dt,"inputs",n.in([])),e(dt,"outputs",n.out(["boolean"]));class ct extends n{run(){this.output(0).data=parseFloat(this.input(0).data)}}e(ct,"kind","parseFloat"),e(ct,"inputs",n.in(["string"])),e(ct,"outputs",n.out(["number"]));class pt extends n{run(){this.output(0).data=parseInt(this.input(0).data)}}e(pt,"kind","parseInt"),e(pt,"inputs",n.in(["number","string"])),e(pt,"outputs",n.out(["number"]));const Dt={[ot.kind]:ot,[at.kind]:at,[dt.kind]:dt,[ct.kind]:ct,[pt.kind]:pt};class ht extends n{run(){this.output(0).data=Object.keys(this.input(0).data)}}e(ht,"kind","objectKeys"),e(ht,"inputs",n.in(["object"])),e(ht,"outputs",n.out(["array"]));class lt extends n{run(){this.output(0).data=Object.values(this.input(0).data)}}e(lt,"kind","objectValues"),e(lt,"inputs",n.in(["object"])),e(lt,"outputs",n.out(["array"]));const ts={[ht.kind]:ht,[lt.kind]:lt};class gt extends n{run(){this.output(0).data=this.input(0).data+this.input(1).data}}e(gt,"kind","addition"),e(gt,"inputs",n.ins(2,["number"])),e(gt,"outputs",n.out(["number"]));class yt extends n{run(){this.output(0).data=this.input(0).data==this.input(1).data}}e(yt,"kind","equality"),e(yt,"inputs",n.ins(2)),e(yt,"outputs",n.out(["boolean"]));class ft extends n{run(){this.output(0).data=this.input(0).data<this.input(1).data}}e(ft,"kind","lessThan"),e(ft,"inputs",n.ins(2,["number"])),e(ft,"outputs",n.out(["boolean"]));class It extends n{run(){this.output(0).data=this.input(0).data<=this.input(1).data}}e(It,"kind","lessThanOrEqual"),e(It,"inputs",n.ins(2,["number"])),e(It,"outputs",n.out(["boolean"]));class mt extends n{run(){this.output(0).data=this.input(0).data>this.input(1).data}}e(mt,"kind","greaterThan"),e(mt,"inputs",n.ins(2,["number"])),e(mt,"outputs",n.out(["boolean"]));class kt extends n{run(){this.output(0).data=this.input(0).data>=this.input(1).data}}e(kt,"kind","greaterThanOrEqual"),e(kt,"inputs",n.ins(2,["number"])),e(kt,"outputs",n.out(["boolean"]));class bt extends n{run(){this.output(0).data=this.input(0).data!=this.input(1).data}}e(bt,"kind","inequality"),e(bt,"inputs",n.ins(2)),e(bt,"outputs",n.out(["boolean"]));class Nt extends n{run(){this.output(0).data=this.input(0).data-this.input(1).data}}e(Nt,"kind","subtraction"),e(Nt,"inputs",n.ins(2,["number"])),e(Nt,"outputs",n.out(["number"]));const ss={[gt.kind]:gt,[yt.kind]:yt,[mt.kind]:mt,[kt.kind]:kt,[ft.kind]:ft,[It.kind]:It,[bt.kind]:bt,[Nt.kind]:Nt};class xt extends n{run(){this.output(0).data=this.input(0).data.length}}e(xt,"kind","stringLength"),e(xt,"inputs",n.in(["string"])),e(xt,"outputs",n.out(["number"]));const es={[xt.kind]:xt},ns=l(l(l(l(l(l(l(l(l(l(l({},Xt),Yt),Zt),Rt),qt),Lt),_t),Dt),ts),ss),es);export{ns as catalog};
