var os=Object.defineProperty,ds=Object.defineProperties;var cs=Object.getOwnPropertyDescriptors;var Wt=Object.getOwnPropertySymbols;var Dt=Object.prototype.hasOwnProperty,ts=Object.prototype.propertyIsEnumerable;var qt=(i,t,s)=>t in i?os(i,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):i[t]=s,l=(i,t)=>{for(var s in t||(t={}))Dt.call(t,s)&&qt(i,s,t[s]);if(Wt)for(var s of Wt(t))ts.call(t,s)&&qt(i,s,t[s]);return i},b=(i,t)=>ds(i,cs(t));var E=(i,t)=>{var s={};for(var a in i)Dt.call(i,a)&&t.indexOf(a)<0&&(s[a]=i[a]);if(i!=null&&Wt)for(var a of Wt(i))t.indexOf(a)<0&&ts.call(i,a)&&(s[a]=i[a]);return s};var e=(i,t,s)=>(qt(i,typeof t!="symbol"?t+"":t,s),s),ss=(i,t,s)=>{if(!t.has(i))throw TypeError("Cannot "+s)};var u=(i,t,s)=>(ss(i,t,"read from private field"),s?s.call(i):t.get(i)),f=(i,t,s)=>{if(t.has(i))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(i):t.set(i,s)},x=(i,t,s,a)=>(ss(i,t,"write to private field"),a?a.call(i,s):t.set(i,s),s);var S,Ht,B,j,v,G,R,Kt,k,I,p,z;const N=i=>`${i} must be a string`,es=i=>`${i} must be a number`,ns=(i,t)=>`${t} pin not found nodeId=${i}`,is=(i,t,s)=>`${ns(i,t)} position=${s}`,as=(i,t,s)=>`${ns(i,t)} pinId=${s}`,Mt=({id:i,kind:t,outputs:s})=>({id:i,kind:t,outputs:s==null?void 0:s.map(({id:a,data:r,name:d})=>({id:a,data:r,name:d}))});class o{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowGraph(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&Array.isArray(t.nodes)&&Array.isArray(t.edges)&&$.isDflowGraph(t)}static isDflowId(t){return o.isStringNotEmpty(t)}static isDflowType(t){return typeof t=="string"&&P.types.includes(t)}static isObject(t){return!o.isUndefined(t)&&!o.isNull(t)&&!o.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return o.isString(t)&&t.length>0}static isUndefined(t){return typeof t=="undefined"}static validate(t,s){return s.length===0?!0:s.some(a=>{switch(a){case"array":return o.isArray(t);case"boolean":return o.isBoolean(t);case"null":return o.isNull(t);case"number":return o.isNumber(t);case"object":return o.isObject(t);case"string":return o.isString(t);case"DflowGraph":return o.isDflowGraph(t);case"DflowId":return o.isDflowId(t);case"DflowType":return o.isDflowType(t);default:return!1}},!0)}}class A{constructor({id:t,name:s}){e(this,"id");e(this,"name");this.id=t,this.name=s}static isDflowItem({id:t,name:s}){return o.isDflowId(t)&&(o.isUndefined(s)||o.isStringNotEmpty(s))}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const Yt=class extends A{constructor(t,r){var d=r,{types:s=[]}=d,a=E(d,["types"]);super(a);e(this,"kind");e(this,"types");this.kind=t,this.types=s}static isDflowPin(a){var r=a,{types:t=[]}=r,s=E(r,["types"]);return A.isDflowItem(s)&&t.every(d=>Yt.isDflowPinType(d))}static isDflowPinType(t){Yt.types.includes(t)}get hasTypeAny(){return this.types.length===0}get hasTypeDflowId(){return this.hasTypeAny||this.types.includes("DflowId")}get hasTypeDflowGraph(){return this.hasTypeAny||this.types.includes("DflowGraph")}get hasTypeDflowType(){return this.hasTypeAny||this.types.includes("DflowType")}get hasTypeString(){return this.hasTypeAny||this.types.includes("string")}get hasTypeNumber(){return this.hasTypeAny||this.types.includes("number")}get hasTypeBoolean(){return this.hasTypeAny||this.types.includes("boolean")}get hasTypeNull(){return this.hasTypeAny||this.types.includes("null")}get hasTypeObject(){return this.hasTypeAny||this.types.includes("object")}get hasTypeArray(){return this.hasTypeAny||this.types.includes("array")}addType(t){this.types.push(t)}removeType(t){this.types.splice(this.types.indexOf(t),1)}};let P=Yt;e(P,"types",["string","number","boolean","null","object","array","DflowId","DflowGraph","DflowType"]);class Jt extends P{constructor(a){var r=a,{optional:t}=r,s=E(r,["optional"]);super("input",s);f(this,S,void 0);f(this,Ht,void 0);x(this,Ht,t)}static isDflowInput({id:t,types:s}){return P.isDflowPin({id:t,types:s})}get data(){var t;return(t=u(this,S))==null?void 0:t.data}get isConnected(){return typeof u(this,S)=="undefined"}get isOptional(){return u(this,Ht)}connectTo(t){const{hasTypeAny:s,types:a}=this,{types:r}=t;if(s||a.some(d=>r.includes(d)))x(this,S,t);else throw new Error(`mismatching pinTypes, source has types [${r.join()}] and target has types [${a.join()}]`)}disconnect(){x(this,S,void 0)}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}S=new WeakMap,Ht=new WeakMap;class Qt extends P{constructor(a){var r=a,{data:t}=r,s=E(r,["data"]);super("output",s);f(this,B,void 0);x(this,B,t)}static isDflowOutput({id:t,data:s,types:a=[]}){return P.isDflowPin({id:t,types:a})&&o.validate(s,a)}clear(){x(this,B,void 0)}get data(){return u(this,B)}set data(t){switch(!0){case o.isUndefined(t):this.clear();break;case this.hasTypeAny:case(o.isDflowGraph(t)&&this.hasTypeDflowGraph):case(o.isDflowId(t)&&this.hasTypeDflowId):case(o.isString(t)&&this.hasTypeString):case(o.isNumber(t)&&this.hasTypeNumber):case(o.isBoolean(t)&&this.hasTypeBoolean):case(o.isNull(t)&&this.hasTypeNull):case(o.isObject(t)&&this.hasTypeObject):case(o.isArray(t)&&this.hasTypeArray):{x(this,B,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=l({},super.toObject());return o.isUndefined(u(this,B))||(t.data=u(this,B)),this.types.length>0&&(t.types=this.types),t}}B=new WeakMap;const Zt=class extends A{constructor(g,d,{isAsync:h=!1,isConstant:c=!1,label:y}={}){var O=g,{kind:t,inputs:s=[],outputs:a=[]}=O,r=E(O,["kind","inputs","outputs"]);super(r);f(this,j,new Map);f(this,v,new Map);f(this,G,[]);f(this,R,[]);f(this,Kt,void 0);e(this,"kind");e(this,"meta");e(this,"host");x(this,Kt,y),this.host=d,this.kind=t,this.meta={isAsync:h,isConstant:c};for(const T of s)this.newInput(T);for(const T of a)this.newOutput(T);this.onCreate()}static generateInputIds(t=[]){return t.map((s,a)=>b(l({},s),{id:`i${a}`}))}static generateOutputIds(t=[]){return t.map((s,a)=>b(l({},s),{id:`o${a}`}))}static in(t=[],s){return[l({types:t},s)]}static ins(t,s=[]){return Array(t).fill(Zt.in(s)).flat()}static out(t=[],s){return[l({types:t},s)]}static outs(t,s=[]){return Array(t).fill(Zt.out(s)).flat()}static outputNumber(t){return b(l({},t),{types:["number"]})}static isDflowNode(d){var h=d,{kind:t,inputs:s=[],outputs:a=[]}=h,r=E(h,["kind","inputs","outputs"]);return A.isDflowItem(r)&&o.isStringNotEmpty(t)&&s.every(c=>Jt.isDflowInput(c))&&a.every(c=>Qt.isDflowOutput(c))}get label(){return u(this,Kt)||this.kind}get inputs(){return u(this,j).values()}get outputs(){return u(this,v).values()}get numInputs(){return u(this,j).size}get numOutputs(){return u(this,v).size}generateInputId(t=this.numInputs){const s=`i${t}`;return u(this,j).has(s)?this.generateInputId(t+1):s}generateOutputId(t=this.numOutputs){const s=`o${t}`;return u(this,v).has(s)?this.generateOutputId(t+1):s}getInputById(t){if(typeof t!="string")throw new TypeError(N("inputId"));const s=u(this,j).get(t);if(s instanceof Jt)return s;throw new Error(as(this.id,"input",t))}input(t){if(typeof t!="number")throw new TypeError(es("position"));const s=u(this,G)[t];if(o.isUndefined(s))throw new Error(is(this.id,"input",t));return this.getInputById(s)}getOutputById(t){if(typeof t!="string")throw new TypeError(N("outputId"));const s=u(this,v).get(t);if(s instanceof Qt)return s;throw new Error(as(this.id,"output",t))}output(t){if(typeof t!="number")throw new TypeError(es("position"));const s=u(this,R)[t];if(o.isUndefined(s))throw new Error(is(this.id,"output",t));return this.getOutputById(s)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),u(this,j).delete(t),u(this,G).splice(u(this,G).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),u(this,v).delete(t),u(this,R).splice(u(this,R).indexOf(t),1)}onBeforeConnectInput(t,s){}onCreate(){}newInput(t){const s=o.isDflowId(t.id)?t.id:this.generateInputId(),a=new Jt(b(l({},t),{id:s}));return u(this,j).set(s,a),u(this,G).push(s),a}newOutput(t){const s=o.isDflowId(t.id)?t.id:this.generateOutputId(),a=new Qt(b(l({},t),{id:s}));return u(this,v).set(s,a),u(this,R).push(s),a}run(){}toObject(){const t=b(l({},super.toObject()),{kind:this.kind}),s=[],a=[];for(const r of this.inputs)s.push(r.toObject());s.length>0&&(t.inputs=s);for(const r of this.outputs)a.push(r.toObject());return a.length>0&&(t.outputs=a),t}};let n=Zt;j=new WeakMap,v=new WeakMap,G=new WeakMap,R=new WeakMap,Kt=new WeakMap,e(n,"kind"),e(n,"isAsync"),e(n,"isConstant"),e(n,"label"),e(n,"inputs"),e(n,"outputs");const Lt=class extends n{constructor(t,s){super(b(l({},t),{kind:Lt.kind}),s)}run(){}};let Vt=Lt;e(Vt,"kind","Unknown");class K extends A{constructor(r){var d=r,{source:t,target:s}=d,a=E(d,["source","target"]);super(a);e(this,"source");e(this,"target");const[h,c]=t,[y,g]=s;if(typeof h!="string")throw new TypeError(N("sourceNodeId"));if(typeof c!="string")throw new TypeError(N("sourcePinId"));if(typeof y!="string")throw new TypeError(N("targetNodeId"));if(typeof g!="string")throw new TypeError(N("targetPinId"));this.source=t,this.target=s}static isDflowEdge(d,r){var h=d,{source:t,target:s}=h,a=E(h,["source","target"]);return A.isDflowItem(a)&&Array.isArray(t)&&t.length===2&&r.nodes.find(({id:c,outputs:y=[]})=>c===t[0]&&y.find(({id:g})=>g===t[1]))&&Array.isArray(s)&&s.length===2&&r.nodes.find(({id:c,inputs:y=[]})=>c===s[0]&&y.find(({id:g})=>g===s[1]))}toObject(){return b(l({},super.toObject()),{source:this.source,target:this.target})}}const w=class extends A{constructor(){super(...arguments);f(this,k,new Map);f(this,I,new Map);e(this,"runOptions",{verbose:!1});e(this,"runStatus",null);e(this,"executionReport",null)}static isDflowGraph(t){return t.nodes.every(s=>n.isDflowNode(s))&&t.edges.every(s=>K.isDflowEdge(s,t))}static childrenOfNodeId(t,s){return s.filter(({sourceId:a})=>t===a).map(({targetId:a})=>a)}static parentsOfNodeId(t,s){return s.filter(({targetId:a})=>t===a).map(({sourceId:a})=>a)}static levelOfNodeId(t,s){const a=w.parentsOfNodeId(t,s);if(a.length===0)return 0;let r=0;for(const d of a){const h=w.levelOfNodeId(d,s);r=Math.max(h,r)}return r+1}static ancestorsOfNodeId(t,s){const a=w.parentsOfNodeId(t,s);return a.length===0?[]:a.reduce((r,d,h,c)=>{const y=w.ancestorsOfNodeId(d,s),g=r.concat(y);return h===c.length-1?Array.from(new Set(c.concat(g))):g},[])}static sort(t,s){const a={};for(const r of t)a[r]=w.levelOfNodeId(r,s);return t.slice().sort((r,d)=>a[r]<=a[d]?-1:1)}get edges(){return u(this,I).values()}get nodes(){return u(this,k).values()}get nodeConnections(){return[...u(this,I).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...u(this,I).keys()]}get nodeIds(){return[...u(this,k).keys()]}get numEdges(){return u(this,I).size}get numNodes(){return u(this,k).size}addEdge(t){if(u(this,I).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);u(this,I).set(t.id,t)}addNode(t){if(u(this,k).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);u(this,k).set(t.id,t)}clear(){u(this,k).clear(),u(this,I).clear()}deleteEdge(t){u(this,I).delete(t)}deleteNode(t){u(this,k).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(N("nodeId"));const s=u(this,k).get(t);if(s instanceof n)return s;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(N("edgeId"));const s=u(this,I).get(t);if(s instanceof K)return s;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const s=`e${t}`;return u(this,I).has(s)?this.generateEdgeId(t+1):s}generateNodeId(t=this.numNodes){const s=`n${t}`;return u(this,k).has(s)?this.generateNodeId(t+1):s}nodeIdsInsideFunctions(){const t=[];for(const s of this.nodes)s.kind==="return"&&t.push(w.ancestorsOfNodeId(s.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){var r,d;const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const s=this.nodeIdsInsideFunctions(),a=w.sort(this.nodeIds.filter(h=>!s.includes(h)),this.nodeConnections);s:for(const h of a){const c=u(this,k).get(h);try{if(!c.meta.isConstant){let y=!1;t:for(const{data:g,types:O,isOptional:T}of c.inputs){if(T&&typeof g=="undefined")continue t;if(!o.validate(g,O)){y=!0;break t}}if(y){for(const g of c.outputs)g.clear();t&&((r=this.executionReport.steps)==null||r.push(Mt(c.toObject())));continue s}c.meta.isAsync?await c.run():c.run()}t&&((d=this.executionReport.steps)==null||d.push(Mt(c.toObject())))}catch(y){console.error(y),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=b(l({},super.toObject()),{nodes:[],edges:[]});for(const s of this.nodes)t.nodes.push(s.toObject());for(const s of this.edges)t.edges.push(s.toObject());return t}};let $=w;k=new WeakMap,I=new WeakMap;class ps{constructor(t={}){f(this,p,void 0);f(this,z,void 0);e(this,"context");x(this,z,t),x(this,p,new $({id:"g1"})),this.context={}}get executionReport(){return u(this,p).executionReport}get edges(){return u(this,p).edges}get nodes(){return u(this,p).nodes}get numEdges(){return u(this,p).numEdges}get numNodes(){return u(this,p).numNodes}get nodeKinds(){return Object.keys(u(this,z))}get runStatusIsSuccess(){return u(this,p).runStatus==="success"}get runStatusIsWaiting(){return u(this,p).runStatus==="waiting"}get runStatusIsFailure(){return u(this,p).runStatus==="failure"}set verbose(t){u(this,p).runOptions.verbose=t}clearGraph(){u(this,p).clear()}connect(t,s=0){return{to:(a,r=0)=>{const d=u(this,p).generateEdgeId(),h=t.output(s),c=a.input(r);a.onBeforeConnectInput(t,s),this.newEdge({id:d,source:[t.id,h.id],target:[a.id,c.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(N("edgeId"));const s=u(this,p).getEdgeById(t);if(s instanceof K){const[a,r]=s.target;this.getNodeById(a).getInputById(r).disconnect(),u(this,p).deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(N("nodeId"));const s=this.getNodeById(t);if(s instanceof n){for(const a of u(this,p).edges){const{source:[r],target:[d]}=a;(r===s.id||d===s.id)&&this.deleteEdge(a.id)}u(this,p).deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,s]){for(const a of this.edges){const[r,d]=a.source,[h,c]=a.target;(r===t&&d===s||h===t&&c===s)&&this.deleteEdge(a.id)}}executeFunction(t,s){var g,O,T;const{verbose:a}=u(this,p).runOptions,r=u(this,p).nodeConnections,d=$.childrenOfNodeId(t,r),h=[];for(const F of d){const m=this.getNodeById(F);m.kind==="return"&&h.push(m.id)}const c=h.reduce((F,m,H,us)=>{const rs=$.ancestorsOfNodeId(m,r),_t=F.concat(rs);return H===us.length?Array.from(new Set(_t)):_t},[]),y=$.sort([...h,...c],r);for(const F of y){const m=this.getNodeById(F);try{switch(m.kind){case"argument":{const H=Math.max((g=m.input(1).data)!=null?g:0,0);m.output(0).data=s[H];break}case"return":return m.input(1).data;default:!m.meta.isConstant&&!m.meta.isAsync&&m.run(),a&&((T=(O=this.executionReport)==null?void 0:O.steps)==null||T.push(Mt(m.toObject())))}}catch(H){console.error(H)}}}getEdgeById(t){return u(this,p).getEdgeById(t)}getNodeById(t){return u(this,p).getNodeById(t)}newNode(t){var y;const s=(y=u(this,z)[t.kind])!=null?y:Vt,a=o.isDflowId(t.id)?t.id:u(this,p).generateNodeId(),r={isAsync:s.isAsync,isConstant:s.isConstant,label:s.label},d=Array.isArray(t.inputs)?t.inputs:n.generateInputIds(s.inputs),h=Array.isArray(t.outputs)?t.outputs:n.generateOutputIds(s.outputs),c=new s(b(l({},t),{id:a,inputs:d,outputs:h}),this,r);return u(this,p).addNode(c),c}newEdge(t){const s=o.isDflowId(t.id)?t.id:u(this,p).generateEdgeId(),a=new K(b(l({},t),{id:s}));u(this,p).addEdge(a);const[r,d]=a.source,[h,c]=a.target,y=u(this,p).getNodeById(r),g=u(this,p).getNodeById(h),O=y.getOutputById(d);return g.getInputById(c).connectTo(O),a}newInput(t,s){return u(this,p).getNodeById(t).newInput(s)}newOutput(t,s){return u(this,p).getNodeById(t).newOutput(s)}toObject(){return u(this,p).toObject()}async run(){await u(this,p).run()}}p=new WeakMap,z=new WeakMap;export{o as DflowData};export{A as DflowItem};export{P as DflowPin};export{Jt as DflowInput};export{Qt as DflowOutput};export{n as DflowNode};export{Vt as DflowUnknownNode};export{K as DflowEdge};export{$ as DflowGraph};export{ps as DflowHost};class W extends n{run(){this.output(0).data=this.input(0).data.filter((...t)=>this.host.executeFunction(this.input(1).data,t))}}e(W,"kind","arrayFilter"),e(W,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),e(W,"outputs",n.out(["array"]));class J extends n{run(){const t=this.input(0).data,s=this.input(1).data;Array.isArray(t)&&(this.output(0).data=t.includes(s))}}e(J,"kind","arrayIncludes"),e(J,"inputs",[...n.in(["array"],{name:"array"}),...n.in(["string"],{name:"element"})]),e(J,"outputs",n.out(["boolean"]));class Q extends n{run(){var a;const t=this.input(0).data,s=(a=this.input(1).data)!=null?a:",";Array.isArray(t)&&(this.output(0).data=t.join(s))}}e(Q,"kind","arrayJoin"),e(Q,"inputs",[...n.in(["array"],{name:"array"}),...n.in(["string"],{name:"separator",optional:!0})]),e(Q,"outputs",n.out(["string"]));class V extends n{run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t.length:this.output(0).clear}}e(V,"kind","arrayLength"),e(V,"inputs",n.in(["array"])),e(V,"outputs",n.out(["number"]));class X extends n{run(){this.output(0).data=this.input(0).data.map((...t)=>this.host.executeFunction(this.input(1).data,t))}}e(X,"kind","arrayMap"),e(X,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),e(X,"outputs",n.out(["array"]));class Y extends n{run(){const t=this.input(0).data.slice(),s=t.pop();this.output(0).data=s,this.output(1).data=t}}e(Y,"kind","arrayPop"),e(Y,"inputs",n.in(["array"])),e(Y,"outputs",[...n.out([],{name:"element"}),...n.out(["array"],{name:"rest"})]);class Z extends n{run(){const t=this.input(0).data.slice(),s=this.input(1).data;s&&t.push(s),this.output(0).data=t}}e(Z,"kind","arrayPush"),e(Z,"inputs",[...n.in(["array"]),...n.in([],{name:"element"})]),e(Z,"outputs",n.out(["array"]));class q extends n{run(){const t=this.input(0).data.slice();this.output(0).data=t.reverse()}}e(q,"kind","arrayReverse"),e(q,"inputs",n.in(["array"])),e(q,"outputs",n.in(["array"]));class M extends n{run(){const t=this.input(0).data.slice(),s=t.shift();this.output(0).data=s,this.output(1).data=t}}e(M,"kind","arrayShift"),e(M,"inputs",n.in(["array"])),e(M,"outputs",[...n.out([],{name:"element"}),...n.out(["array"],{name:"rest"})]);class L extends n{run(){const t=this.input(0).data,s=this.input(1).data,a=this.input(2).data;typeof a=="number"?this.output(0).data=t.slice(s,a):this.output(0).data=t.slice(s)}}e(L,"kind","arraySlice"),e(L,"inputs",[...n.in(["array"]),...n.in(["number"],{name:"start"}),...n.in(["number"],{name:"end",optional:!0})]),e(L,"outputs",n.out(["array"]));const hs={[W.kind]:W,[J.kind]:J,[Q.kind]:Q,[V.kind]:V,[X.kind]:X,[Y.kind]:Y,[Z.kind]:Z,[q.kind]:q,[M.kind]:M,[L.kind]:L};class _ extends n{run(){this.output(0).data=this.input(0).data?this.input(1).data:this.input(2).data}}e(_,"kind","if"),e(_,"inputs",[...n.in(["boolean"],{name:"condition"}),...n.in([],{name:"then"}),...n.in([],{name:"else"})]),e(_,"outputs",n.out());const ls={[_.kind]:_};class Xt extends n{run(){console.log(this.input(0).data)}}e(Xt,"kind","consoleLog"),e(Xt,"inputs",[...n.in([])]);const ys={[Xt.kind]:Xt};class D extends n{}e(D,"kind","data"),e(D,"isConstant",!0),e(D,"outputs",n.out());class tt extends n{run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t:this.output(0).clear()}}e(tt,"kind","array"),e(tt,"inputs",n.in()),e(tt,"outputs",n.out(["array"]));class st extends n{run(){const t=this.input(0).data;typeof t=="boolean"?this.output(0).data=t:this.output(0).clear()}}e(st,"kind","boolean"),e(st,"inputs",n.in()),e(st,"outputs",n.out(["boolean"]));class et extends n{run(){const t=this.input(0).data;typeof t=="number"?this.output(0).data=t:this.output(0).clear()}}e(et,"kind","number"),e(et,"inputs",n.in()),e(et,"outputs",n.out(["number"]));class nt extends n{run(){const t=this.input(0).data;typeof t=="object"&&t!==null?this.output(0).data=t:this.output(0).clear()}}e(nt,"kind","object"),e(nt,"inputs",n.in()),e(nt,"outputs",n.out(["object"]));class it extends n{run(){const t=this.input(0).data;typeof t=="string"?this.output(0).data=t:this.output(0).clear()}}e(it,"kind","string"),e(it,"inputs",n.in()),e(it,"outputs",n.out(["string"]));class at extends n{run(){const t=this.input(0).data;this.output(0).data=Array.isArray(t)}}e(at,"kind","isArray"),e(at,"inputs",n.out()),e(at,"outputs",n.out(["boolean"]));class ut extends n{run(){const t=this.input(0).data;console.log(t),this.output(0).data=typeof t!="undefined"}}e(ut,"kind","isDefined"),e(ut,"inputs",n.in()),e(ut,"outputs",n.out(["boolean"]));class rt extends n{run(){const t=this.input(0).data;console.log(t),this.output(0).data=typeof t=="undefined"}}e(rt,"kind","isUndefined"),e(rt,"inputs",n.in()),e(rt,"outputs",n.out(["boolean"]));const gs={[D.kind]:D,[ut.kind]:ut,[rt.kind]:rt,[tt.kind]:tt,[st.kind]:st,[et.kind]:et,[nt.kind]:nt,[it.kind]:it,[at.kind]:at};class C extends n{run(){const t=this.output(0);t.data=this.host.nodeKinds}}e(C,"kind","dflow"),e(C,"outputs",n.out(["array"],{name:"nodeKinds"}));class ot extends n{}e(ot,"kind","comment"),e(ot,"isConstant",!0),e(ot,"outputs",n.out(["string"]));class dt extends n{}e(dt,"kind","typeNumber"),e(dt,"isConstant",!0),e(dt,"outputs",n.out(["DflowType"],{name:"number",data:"number"}));class U extends n{onBeforeConnectInput(t,s){const a=t.output(s).data;this.output(0).addType(a)}}e(U,"kind","argument"),e(U,"isConstant",!0),e(U,"inputs",[...n.in(["DflowType"],{name:"type"}),...n.in(["number"],{name:"argumentPosition"})]),e(U,"outputs",n.out());class ct extends n{onCreate(){this.output(0).data=this.id}}e(ct,"kind","function"),e(ct,"isConstant",!0),e(ct,"outputs",C.out(["DflowId"],{name:"id"}));class pt extends n{}e(pt,"kind","return"),e(pt,"isConstant",!0),e(pt,"inputs",[...C.in(["DflowId"],{name:"functionId"}),...C.in([],{name:"value"})]);const ms={[C.kind]:C,[U.kind]:U,[ot.kind]:ot,[ct.kind]:ct,[pt.kind]:pt,[dt.kind]:dt};class ht extends n{run(){this.output(0).data=this.input(0).data&&this.input(1).data}}e(ht,"kind","and"),e(ht,"inputs",n.ins(2,["boolean"])),e(ht,"outputs",n.out(["boolean"]));class lt extends n{run(){this.output(0).data=!this.input(0).data}}e(lt,"kind","not"),e(lt,"inputs",n.in(["boolean"])),e(lt,"outputs",n.out(["boolean"]));class yt extends n{run(){this.output(0).data=this.input(0).data||this.input(1).data}}e(yt,"kind","or"),e(yt,"inputs",n.ins(2,["boolean"])),e(yt,"outputs",n.out(["boolean"]));const fs={[ht.kind]:ht,[lt.kind]:lt,[yt.kind]:yt};class gt extends n{run(){this.output(0).data=Math.cos(this.input(0).data)}}e(gt,"kind","mathCos"),e(gt,"inputs",n.in(["number"])),e(gt,"outputs",n.out(["number"]));class mt extends n{run(){this.output(0).data=Math.cosh(this.input(0).data)}}e(mt,"kind","mathCosh"),e(mt,"inputs",n.in(["number"])),e(mt,"outputs",n.out(["number"]));class ft extends n{run(){const t=this.input(0).data,s=Math.max(...t);isNaN(s)?this.output(0).clear():this.output(0).data=s}}e(ft,"kind","mathMax"),e(ft,"inputs",n.in(["array"])),e(ft,"outputs",n.out(["number"]));class kt extends n{run(){const t=this.input(0).data,s=Math.min(...t);isNaN(s)?this.output(0).clear():this.output(0).data=s}}e(kt,"kind","mathMin"),e(kt,"inputs",n.in(["array"])),e(kt,"outputs",n.out(["number"]));class It extends n{}e(It,"kind","mathPI"),e(It,"isConstant",!0),e(It,"outputs",n.out(["number"],{name:"\u03C0",data:Math.PI}));class bt extends n{run(){this.output(0).data=Math.sin(this.input(0).data)}}e(bt,"kind","mathSin"),e(bt,"inputs",n.in(["number"])),e(bt,"outputs",n.out(["number"]));class xt extends n{run(){this.output(0).data=Math.sinh(this.input(0).data)}}e(xt,"kind","mathSinh"),e(xt,"inputs",n.in(["number"])),e(xt,"outputs",n.out(["number"]));const ks={[gt.kind]:gt,[mt.kind]:mt,[ft.kind]:ft,[kt.kind]:kt,[It.kind]:It,[bt.kind]:bt,[xt.kind]:xt};class Nt extends n{run(){this.output(0).data=Number.isFinite(this.input(0).data)}}e(Nt,"kind","isFinite"),e(Nt,"inputs",n.in(["number"])),e(Nt,"outputs",n.out(["boolean"]));class Ot extends n{run(){this.output(0).data=Number.isInteger(this.input(0).data)}}e(Ot,"kind","isInteger"),e(Ot,"inputs",n.in([])),e(Ot,"outputs",n.out(["boolean"]));class Tt extends n{run(){this.output(0).data=Number.isNaN(this.input(0).data)}}e(Tt,"kind","isNaN"),e(Tt,"inputs",n.in([])),e(Tt,"outputs",n.out(["boolean"]));class Et extends n{run(){this.output(0).data=parseFloat(this.input(0).data)}}e(Et,"kind","parseFloat"),e(Et,"inputs",n.in(["string"])),e(Et,"outputs",n.out(["number"]));class Bt extends n{run(){this.output(0).data=parseInt(this.input(0).data)}}e(Bt,"kind","parseInt"),e(Bt,"inputs",n.in(["number","string"])),e(Bt,"outputs",n.out(["number"]));const Is={[Nt.kind]:Nt,[Ot.kind]:Ot,[Tt.kind]:Tt,[Et.kind]:Et,[Bt.kind]:Bt};class jt extends n{run(){this.output(0).data=Object.keys(this.input(0).data)}}e(jt,"kind","objectKeys"),e(jt,"inputs",n.in(["object"])),e(jt,"outputs",n.out(["array"]));class vt extends n{run(){this.output(0).data=Object.values(this.input(0).data)}}e(vt,"kind","objectValues"),e(vt,"inputs",n.in(["object"])),e(vt,"outputs",n.out(["array"]));const bs={[jt.kind]:jt,[vt.kind]:vt};class wt extends n{run(){this.output(0).data=this.input(0).data+this.input(1).data}}e(wt,"kind","addition"),e(wt,"inputs",n.ins(2,["number"])),e(wt,"outputs",n.out(["number"]));class At extends n{run(){this.input(1).data?this.output(0).data=this.input(0).data/this.input(1).data:this.output(0).clear()}}e(At,"kind","division"),e(At,"inputs",n.ins(2,["number"])),e(At,"outputs",n.out(["number"]));class Pt extends n{run(){this.output(0).data=this.input(0).data==this.input(1).data}}e(Pt,"kind","equality"),e(Pt,"inputs",n.ins(2)),e(Pt,"outputs",n.out(["boolean"]));class $t extends n{run(){this.output(0).data=this.input(0).data<this.input(1).data}}e($t,"kind","lessThan"),e($t,"inputs",n.ins(2,["number"])),e($t,"outputs",n.out(["boolean"]));class Ct extends n{run(){this.output(0).data=this.input(0).data<=this.input(1).data}}e(Ct,"kind","lessThanOrEqual"),e(Ct,"inputs",n.ins(2,["number"])),e(Ct,"outputs",n.out(["boolean"]));class St extends n{run(){this.output(0).data=this.input(0).data>this.input(1).data}}e(St,"kind","greaterThan"),e(St,"inputs",n.ins(2,["number"])),e(St,"outputs",n.out(["boolean"]));class Gt extends n{run(){this.output(0).data=this.input(0).data>=this.input(1).data}}e(Gt,"kind","greaterThanOrEqual"),e(Gt,"inputs",n.ins(2,["number"])),e(Gt,"outputs",n.out(["boolean"]));class Rt extends n{run(){this.output(0).data=this.input(0).data!=this.input(1).data}}e(Rt,"kind","inequality"),e(Rt,"inputs",n.ins(2)),e(Rt,"outputs",n.out(["boolean"]));class Ut extends n{run(){this.output(0).data=this.input(0).data*this.input(1).data}}e(Ut,"kind","multiplication"),e(Ut,"inputs",n.ins(2,["number"])),e(Ut,"outputs",n.out(["number"]));class zt extends n{run(){this.output(0).data=this.input(0).data-this.input(1).data}}e(zt,"kind","subtraction"),e(zt,"inputs",n.ins(2,["number"])),e(zt,"outputs",n.out(["number"]));const xs={[wt.kind]:wt,[At.kind]:At,[Pt.kind]:Pt,[St.kind]:St,[Gt.kind]:Gt,[$t.kind]:$t,[Ct.kind]:Ct,[Rt.kind]:Rt,[Ut.kind]:Ut,[zt.kind]:zt};class Ft extends n{run(){this.output(0).data=this.input(0).data.length}}e(Ft,"kind","stringLength"),e(Ft,"inputs",n.in(["string"])),e(Ft,"outputs",n.out(["number"]));const Ns={[Ft.kind]:Ft},Os=l(l(l(l(l(l(l(l(l(l(l({},hs),ls),ys),gs),ms),fs),ks),Is),bs),xs),Ns);export{Os as catalog};
