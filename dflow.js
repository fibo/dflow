var Kt=Object.defineProperty,Jt=Object.defineProperties;var Wt=Object.getOwnPropertyDescriptors;var Tt=Object.getOwnPropertySymbols;var vt=Object.prototype.hasOwnProperty,St=Object.prototype.propertyIsEnumerable;var Pt=(u,t,s)=>t in u?Kt(u,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):u[t]=s,l=(u,t)=>{for(var s in t||(t={}))vt.call(t,s)&&Pt(u,s,t[s]);if(Tt)for(var s of Tt(t))St.call(t,s)&&Pt(u,s,t[s]);return u},m=(u,t)=>Jt(u,Wt(t));var A=(u,t)=>{var s={};for(var i in u)vt.call(u,i)&&t.indexOf(i)<0&&(s[i]=u[i]);if(u!=null&&Tt)for(var i of Tt(u))t.indexOf(i)<0&&St.call(u,i)&&(s[i]=u[i]);return s};var e=(u,t,s)=>(Pt(u,typeof t!="symbol"?t+"":t,s),s),Gt=(u,t,s)=>{if(!t.has(u))throw TypeError("Cannot "+s)};var r=(u,t,s)=>(Gt(u,t,"read from private field"),s?s.call(u):t.get(u)),k=(u,t,s)=>{if(t.has(u))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(u):t.set(u,s)},N=(u,t,s,i)=>(Gt(u,t,"write to private field"),i?i.call(u,s):t.set(u,s),s);var j,T,w,E,v,S,Nt,f,I,p,R;const x=u=>`${u} must be a string`,Ut=u=>`${u} must be a number`,Rt=(u,t)=>`${t} pin not found nodeId=${u}`,zt=(u,t,s)=>`${Rt(u,t)} position=${s}`,Ft=(u,t,s)=>`${Rt(u,t)} pinId=${s}`;class d{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowGraph(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&Array.isArray(t.nodes)&&Array.isArray(t.edges)&&P.isDflowGraph(t)}static isDflowId(t){return d.isStringNotEmpty(t)}static isDflowType(t){return typeof t=="string"&&C.types.includes(t)}static isObject(t){return!d.isUndefined(t)&&!d.isNull(t)&&!d.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return d.isString(t)&&t.length>0}static isUndefined(t){return typeof t=="undefined"}static validate(t,s){return s.length===0?!0:s.some(i=>{switch(i){case"array":return d.isArray(t);case"boolean":return d.isBoolean(t);case"null":return d.isNull(t);case"number":return d.isNumber(t);case"object":return d.isObject(t);case"string":return d.isString(t);case"DflowGraph":return d.isDflowGraph(t);case"DflowId":return d.isDflowId(t);case"DflowType":return d.isDflowType(t);default:return!1}},!0)}}class B{constructor({id:t,name:s}){e(this,"id");e(this,"name");this.id=t,this.name=s}static isDflowItem({id:t,name:s}){return d.isDflowId(t)&&(d.isUndefined(s)||d.isStringNotEmpty(s))}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const Bt=class extends B{constructor(t,o){var a=o,{types:s=[]}=a,i=A(a,["types"]);super(i);e(this,"kind");e(this,"types");this.kind=t,this.types=s}static isDflowPin(i){var o=i,{types:t=[]}=o,s=A(o,["types"]);return B.isDflowItem(s)&&t.every(a=>Bt.isDflowPinType(a))}static isDflowPinType(t){Bt.types.includes(t)}get hasTypeAny(){return this.types.length===0}get hasTypeDflowId(){return this.hasTypeAny||this.types.includes("DflowId")}get hasTypeDflowGraph(){return this.hasTypeAny||this.types.includes("DflowGraph")}get hasTypeDflowType(){return this.hasTypeAny||this.types.includes("DflowType")}get hasTypeString(){return this.hasTypeAny||this.types.includes("string")}get hasTypeNumber(){return this.hasTypeAny||this.types.includes("number")}get hasTypeBoolean(){return this.hasTypeAny||this.types.includes("boolean")}get hasTypeNull(){return this.hasTypeAny||this.types.includes("null")}get hasTypeObject(){return this.hasTypeAny||this.types.includes("object")}get hasTypeArray(){return this.hasTypeAny||this.types.includes("array")}addType(t){this.types.push(t)}removeType(t){this.types.splice(this.types.indexOf(t),1)}};let C=Bt;e(C,"types",["string","number","boolean","null","object","array","DflowId","DflowGraph","DflowType"]);class wt extends C{constructor(t){super("input",t);k(this,j,void 0)}static isDflowInput({id:t,types:s}){return C.isDflowPin({id:t,types:s})}get data(){var t;return(t=r(this,j))==null?void 0:t.data}get isConnected(){return typeof r(this,j)=="undefined"}connectTo(t){const{hasTypeAny:s,types:i}=this,{types:o}=t;if(s||i.some(a=>o.includes(a)))N(this,j,t);else throw new Error(`mismatching pinTypes, source has types [${o.join()}] and target has types [${i.join()}]`)}disconnect(){N(this,j,void 0)}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}j=new WeakMap;class Et extends C{constructor(i){var o=i,{data:t}=o,s=A(o,["data"]);super("output",s);k(this,T,void 0);N(this,T,t)}static isDflowOutput({id:t,data:s,types:i=[]}){return C.isDflowPin({id:t,types:i})&&d.validate(s,i)}clear(){N(this,T,void 0)}get data(){return r(this,T)}set data(t){switch(!0){case d.isUndefined(t):this.clear();break;case this.hasTypeAny:case(d.isDflowGraph(t)&&this.hasTypeDflowGraph):case(d.isDflowId(t)&&this.hasTypeDflowId):case(d.isString(t)&&this.hasTypeString):case(d.isNumber(t)&&this.hasTypeNumber):case(d.isBoolean(t)&&this.hasTypeBoolean):case(d.isNull(t)&&this.hasTypeNull):case(d.isObject(t)&&this.hasTypeObject):case(d.isArray(t)&&this.hasTypeArray):{N(this,T,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=l({},super.toObject());return d.isUndefined(r(this,T))||(t.data=r(this,T)),this.types.length>0&&(t.types=this.types),t}}T=new WeakMap;const Ct=class extends B{constructor(y,a,{isAsync:c=!1,isConstant:h=!1,label:g}={}){var b=y,{kind:t,inputs:s=[],outputs:i=[]}=b,o=A(b,["kind","inputs","outputs"]);super(o);k(this,w,new Map);k(this,E,new Map);k(this,v,[]);k(this,S,[]);k(this,Nt,void 0);e(this,"kind");e(this,"meta");e(this,"host");N(this,Nt,g),this.host=a,this.kind=t,this.meta={isAsync:c,isConstant:h};for(const G of s)this.newInput(G);for(const G of i)this.newOutput(G);this.onCreate()}static generateInputIds(t=[]){return t.map((s,i)=>m(l({},s),{id:`i${i}`}))}static generateOutputIds(t=[]){return t.map((s,i)=>m(l({},s),{id:`o${i}`}))}static in(t=[],s){return[l({types:t},s)]}static ins(t,s=[]){return Array(t).fill(Ct.in(s)).flat()}static out(t=[],s){return[l({types:t},s)]}static outs(t,s=[]){return Array(t).fill(Ct.out(s)).flat()}static outputNumber(t){return m(l({},t),{types:["number"]})}static isDflowNode(a){var c=a,{kind:t,inputs:s=[],outputs:i=[]}=c,o=A(c,["kind","inputs","outputs"]);return B.isDflowItem(o)&&d.isStringNotEmpty(t)&&s.every(h=>wt.isDflowInput(h))&&i.every(h=>Et.isDflowOutput(h))}get label(){return r(this,Nt)||this.kind}get inputs(){return r(this,w).values()}get outputs(){return r(this,E).values()}get numInputs(){return r(this,w).size}get numOutputs(){return r(this,E).size}generateInputId(t=this.numInputs){const s=`i${t}`;return r(this,w).has(s)?this.generateInputId(t+1):s}generateOutputId(t=this.numOutputs){const s=`o${t}`;return r(this,E).has(s)?this.generateOutputId(t+1):s}getInputById(t){if(typeof t!="string")throw new TypeError(x("inputId"));const s=r(this,w).get(t);if(s instanceof wt)return s;throw new Error(Ft(this.id,"input",t))}input(t){if(typeof t!="number")throw new TypeError(Ut("position"));const s=r(this,v)[t];if(d.isUndefined(s))throw new Error(zt(this.id,"input",t));return this.getInputById(s)}getOutputById(t){if(typeof t!="string")throw new TypeError(x("outputId"));const s=r(this,E).get(t);if(s instanceof Et)return s;throw new Error(Ft(this.id,"output",t))}output(t){if(typeof t!="number")throw new TypeError(Ut("position"));const s=r(this,S)[t];if(d.isUndefined(s))throw new Error(zt(this.id,"output",t));return this.getOutputById(s)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),r(this,w).delete(t),r(this,v).splice(r(this,v).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),r(this,E).delete(t),r(this,S).splice(r(this,S).indexOf(t),1)}onBeforeConnectInput(t,s){}onCreate(){}newInput(t){const s=d.isDflowId(t.id)?t.id:this.generateInputId(),i=new wt(m(l({},t),{id:s}));return r(this,w).set(s,i),r(this,v).push(s),i}newOutput(t){const s=d.isDflowId(t.id)?t.id:this.generateOutputId(),i=new Et(m(l({},t),{id:s}));return r(this,E).set(s,i),r(this,S).push(s),i}run(){throw new Error(`${this.constructor.name} does not implement a run() method`)}toObject(){const t=m(l({},super.toObject()),{kind:this.kind}),s=[],i=[];for(const o of this.inputs)s.push(o.toObject());s.length>0&&(t.inputs=s);for(const o of this.outputs)i.push(o.toObject());return i.length>0&&(t.outputs=i),t}};let n=Ct;w=new WeakMap,E=new WeakMap,v=new WeakMap,S=new WeakMap,Nt=new WeakMap,e(n,"kind"),e(n,"isAsync"),e(n,"isConstant"),e(n,"label"),e(n,"inputs"),e(n,"outputs");const $t=class extends n{constructor(t,s){super(m(l({},t),{kind:$t.kind}),s)}run(){}};let Ot=$t;e(Ot,"kind","Unknown");class z extends B{constructor(o){var a=o,{source:t,target:s}=a,i=A(a,["source","target"]);super(i);e(this,"source");e(this,"target");const[c,h]=t,[g,y]=s;if(typeof c!="string")throw new TypeError(x("sourceNodeId"));if(typeof h!="string")throw new TypeError(x("sourcePinId"));if(typeof g!="string")throw new TypeError(x("targetNodeId"));if(typeof y!="string")throw new TypeError(x("targetPinId"));this.source=t,this.target=s}static isDflowEdge(a,o){var c=a,{source:t,target:s}=c,i=A(c,["source","target"]);return B.isDflowItem(i)&&Array.isArray(t)&&t.length===2&&o.nodes.find(({id:h,outputs:g=[]})=>h===t[0]&&g.find(({id:y})=>y===t[1]))&&Array.isArray(s)&&s.length===2&&o.nodes.find(({id:h,inputs:g=[]})=>h===s[0]&&g.find(({id:y})=>y===s[1]))}toObject(){return m(l({},super.toObject()),{source:this.source,target:this.target})}}const O=class extends B{constructor(){super(...arguments);e(this,"runStatus","success");e(this,"executionReport",null);k(this,f,new Map);k(this,I,new Map)}static isDflowGraph(t){return t.nodes.every(s=>n.isDflowNode(s))&&t.edges.every(s=>z.isDflowEdge(s,t))}static childrenOfNodeId(t,s){return s.filter(({sourceId:i})=>t===i).map(({targetId:i})=>i)}static parentsOfNodeId(t,s){return s.filter(({targetId:i})=>t===i).map(({sourceId:i})=>i)}static levelOfNodeId(t,s){const i=O.parentsOfNodeId(t,s);if(i.length===0)return 0;let o=0;for(const a of i){const c=O.levelOfNodeId(a,s);o=Math.max(c,o)}return o+1}static ancestorsOfNodeId(t,s){const i=O.parentsOfNodeId(t,s);return i.length===0?[]:i.reduce((o,a,c,h)=>{const g=O.ancestorsOfNodeId(a,s),y=o.concat(g);return c===h.length-1?Array.from(new Set(h.concat(y))):y},[])}static sort(t,s){const i={};for(const o of t)i[o]=O.levelOfNodeId(o,s);return t.slice().sort((o,a)=>i[o]<=i[a]?-1:1)}get edges(){return r(this,I).values()}get nodes(){return r(this,f).values()}get nodeConnections(){return[...r(this,I).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...r(this,I).keys()]}get nodeIds(){return[...r(this,f).keys()]}get numEdges(){return r(this,I).size}get numNodes(){return r(this,f).size}addEdge(t){if(r(this,I).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);r(this,I).set(t.id,t)}addNode(t){if(r(this,f).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);r(this,f).set(t.id,t)}clear(){r(this,f).clear(),r(this,I).clear()}deleteEdge(t){r(this,I).delete(t)}deleteNode(t){r(this,f).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(x("nodeId"));const s=r(this,f).get(t);if(s instanceof n)return s;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(x("edgeId"));const s=r(this,I).get(t);if(s instanceof z)return s;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const s=`e${t}`;return r(this,I).has(s)?this.generateEdgeId(t+1):s}generateNodeId(t=this.numNodes){const s=`n${t}`;return r(this,f).has(s)?this.generateNodeId(t+1):s}nodeIdsInsideFunctions(){const t=[];for(const s of this.nodes)s.kind==="return"&&t.push(O.ancestorsOfNodeId(s.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run({verbose:t=!1}){var o;this.runStatus==="success"&&(this.runStatus="waiting"),this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const s=this.nodeIdsInsideFunctions(),i=O.sort(this.nodeIds.filter(a=>!s.includes(a)),this.nodeConnections);for(const a of i){const c=r(this,f).get(a);try{if(c.meta.isConstant===!1){let h=!1;for(const{data:g,types:y}of c.inputs)if(!d.validate(g,y)){h=!0;break}if(h){for(const g of c.outputs)g.clear();break}c.meta.isAsync?await c.run():c.run()}t&&((o=this.executionReport.steps)==null||o.push({id:a,kind:c.kind}))}catch(h){console.error(h),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=m(l({},super.toObject()),{nodes:[],edges:[]});for(const s of this.nodes)t.nodes.push(s.toObject());for(const s of this.edges)t.edges.push(s.toObject());return t}};let P=O;f=new WeakMap,I=new WeakMap;class Mt{constructor(t={}){k(this,p,void 0);k(this,R,void 0);e(this,"context");N(this,R,t),N(this,p,new P({id:"g1"})),this.context={}}get executionReport(){return r(this,p).executionReport}get edges(){return r(this,p).edges}get nodes(){return r(this,p).nodes}get numEdges(){return r(this,p).numEdges}get numNodes(){return r(this,p).numNodes}get nodeKinds(){return Object.keys(r(this,R))}get runStatusIsSuccess(){return r(this,p).runStatus==="success"}get runStatusIsWaiting(){return r(this,p).runStatus==="waiting"}get runStatusIsFailure(){return r(this,p).runStatus==="failure"}clearGraph(){r(this,p).clear()}connect(t,s=0){return{to:(i,o=0)=>{const a=r(this,p).generateEdgeId(),c=t.output(s),h=i.input(o);i.onBeforeConnectInput(t,s),this.newEdge({id:a,source:[t.id,c.id],target:[i.id,h.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(x("edgeId"));const s=r(this,p).getEdgeById(t);if(s instanceof z){const[i,o]=s.target;this.getNodeById(i).getInputById(o).disconnect(),r(this,p).deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(x("nodeId"));const s=this.getNodeById(t);if(s instanceof n){for(const i of r(this,p).edges){const{source:[o],target:[a]}=i;(o===s.id||a===s.id)&&this.deleteEdge(i.id)}r(this,p).deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,s]){for(const i of this.edges){const[o,a]=i.source,[c,h]=i.target;(o===t&&a===s||c===t&&h===s)&&this.deleteEdge(i.id)}}executeFunction(t,s){const i=r(this,p).nodeConnections,o=P.childrenOfNodeId(t,i),a=[];for(const g of o){const y=this.getNodeById(g);y.kind==="return"&&a.push(y.id)}const c=a.reduce((g,y,b,G)=>{const Ht=P.ancestorsOfNodeId(y,i),jt=g.concat(Ht);return b===G.length?Array.from(new Set(jt)):jt},[]),h=P.sort([...a,...c],i);for(const g of h){const y=this.getNodeById(g);try{switch(y.kind){case"argument":{const b=0;y.output(0).data=s[b];break}case"return":return y.input(1).data;default:y.meta.isConstant||y.run()}}catch(b){console.error(b)}}}getEdgeById(t){return r(this,p).getEdgeById(t)}getNodeById(t){return r(this,p).getNodeById(t)}newNode(t){var g;const s=(g=r(this,R)[t.kind])!=null?g:Ot,i=d.isDflowId(t.id)?t.id:r(this,p).generateNodeId(),o={isAsync:s.isAsync,isConstant:s.isConstant,label:s.label},a=Array.isArray(t.inputs)?t.inputs:n.generateInputIds(s.inputs),c=Array.isArray(t.outputs)?t.outputs:n.generateOutputIds(s.outputs),h=new s(m(l({},t),{id:i,inputs:a,outputs:c}),this,o);return r(this,p).addNode(h),h}newEdge(t){const s=d.isDflowId(t.id)?t.id:r(this,p).generateEdgeId(),i=new z(m(l({},t),{id:s}));r(this,p).addEdge(i);const[o,a]=i.source,[c,h]=i.target,g=r(this,p).getNodeById(o),y=r(this,p).getNodeById(c),b=g.getOutputById(a);return y.getInputById(h).connectTo(b),i}newInput(t,s){return r(this,p).getNodeById(t).newInput(s)}newOutput(t,s){return r(this,p).getNodeById(t).newOutput(s)}toObject(){return r(this,p).toObject()}async run(t={}){await r(this,p).run(t)}}p=new WeakMap,R=new WeakMap;export{d as DflowData};export{B as DflowItem};export{C as DflowPin};export{wt as DflowInput};export{Et as DflowOutput};export{n as DflowNode};export{Ot as DflowUnknownNode};export{z as DflowEdge};export{P as DflowGraph};export{Mt as DflowHost};class F extends n{run(){this.output(0).data=this.input(0).data.filter((...t)=>this.host.executeFunction(this.input(1).data,t))}}e(F,"kind","arrayFilter"),e(F,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),e(F,"outputs",n.out(["array"]));class H extends n{run(){this.output(0).data=this.input(0).data.length}}e(H,"kind","arrayLength"),e(H,"inputs",n.in(["array"])),e(H,"outputs",n.out(["number"]));const Qt={[F.kind]:F,[H.kind]:H};class K extends n{run(){this.output(0).data=this.input(0).data?this.input(1).data:this.input(2).data}}e(K,"kind","if"),e(K,"inputs",[...n.in(["boolean"],{name:"condition"}),...n.in([],{name:"then"}),...n.in([],{name:"else"})]),e(K,"outputs",n.out());const Vt={[K.kind]:K};class At extends n{run(){console.log(this.input(0).data)}}e(At,"kind","consoleLog"),e(At,"inputs",[...n.in([])]);const Xt={[At.kind]:At};class J extends n{}e(J,"kind","data"),e(J,"outputs",n.out()),e(J,"isConstant",!0);class W extends n{}e(W,"kind","array"),e(W,"outputs",n.out(["array"])),e(W,"isConstant",!0);class M extends n{}e(M,"kind","boolean"),e(M,"outputs",n.out(["boolean"])),e(M,"isConstant",!0);class Q extends n{}e(Q,"kind","number"),e(Q,"outputs",n.out(["number"])),e(Q,"isConstant",!0);class V extends n{}e(V,"kind","object"),e(V,"outputs",n.out(["object"])),e(V,"isConstant",!0);class X extends n{}e(X,"kind","string"),e(X,"outputs",n.out(["string"])),e(X,"isConstant",!0);const Yt={[J.kind]:J,[W.kind]:W,[M.kind]:M,[Q.kind]:Q,[V.kind]:V,[X.kind]:X};class $ extends n{run(){const t=this.output(0);t.data=this.host.nodeKinds}}e($,"kind","dflow"),e($,"outputs",n.out(["array"],{name:"nodeKinds"}));class Y extends n{}e(Y,"kind","comment"),e(Y,"isConstant",!0),e(Y,"outputs",n.out(["string"]));class Z extends n{}e(Z,"kind","typeNumber"),e(Z,"isConstant",!0),e(Z,"outputs",n.out(["DflowType"],{name:"number",data:"number"}));class U extends n{onBeforeConnectInput(t,s){const i=t.output(s).data;this.output(0).addType(i)}}e(U,"kind","argument"),e(U,"isConstant",!0),e(U,"inputs",[...n.in(["DflowType"],{name:"type"})]),e(U,"outputs",n.out());class q extends n{onCreate(){this.output(0).data=this.id}}e(q,"kind","function"),e(q,"isConstant",!0),e(q,"outputs",$.out(["DflowId"],{name:"id"}));class L extends n{}e(L,"kind","return"),e(L,"isConstant",!0),e(L,"inputs",[...$.in(["DflowId"],{name:"functionId"}),...$.in([],{name:"value"})]);const Zt={[$.kind]:$,[U.kind]:U,[Y.kind]:Y,[q.kind]:q,[L.kind]:L,[Z.kind]:Z};class _ extends n{run(){this.output(0).data=this.input(0).data&&this.input(1).data}}e(_,"kind","and"),e(_,"inputs",n.ins(2,["boolean"])),e(_,"outputs",n.out(["boolean"]));class D extends n{run(){this.output(0).data=!this.input(0).data}}e(D,"kind","not"),e(D,"inputs",n.in(["boolean"])),e(D,"outputs",n.out(["boolean"]));class tt extends n{run(){this.output(0).data=this.input(0).data||this.input(1).data}}e(tt,"kind","or"),e(tt,"inputs",n.ins(2,["boolean"])),e(tt,"outputs",n.out(["boolean"]));const qt={[_.kind]:_,[D.kind]:D,[tt.kind]:tt};class st extends n{run(){this.output(0).data=Math.cos(this.input(0).data)}}e(st,"kind","mathCos"),e(st,"inputs",n.in(["number"])),e(st,"outputs",n.out(["number"]));class et extends n{run(){this.output(0).data=Math.cosh(this.input(0).data)}}e(et,"kind","mathCosh"),e(et,"inputs",n.in(["number"])),e(et,"outputs",n.out(["number"]));class nt extends n{}e(nt,"kind","mathPI"),e(nt,"isConstant",!0),e(nt,"outputs",n.out(["number"],{data:Math.PI}));class it extends n{run(){this.output(0).data=Math.sin(this.input(0).data)}}e(it,"kind","mathSin"),e(it,"inputs",n.in(["number"])),e(it,"outputs",n.out(["number"]));class ut extends n{run(){this.output(0).data=Math.sinh(this.input(0).data)}}e(ut,"kind","mathSinh"),e(ut,"inputs",n.in(["number"])),e(ut,"outputs",n.out(["number"]));const Lt={[st.kind]:st,[et.kind]:et,[nt.kind]:nt,[it.kind]:it,[ut.kind]:ut};class rt extends n{run(){this.output(0).data=Number.isFinite(this.input(0).data)}}e(rt,"kind","isFinite"),e(rt,"inputs",n.in(["number"])),e(rt,"outputs",n.out(["boolean"]));class ot extends n{run(){this.output(0).data=Number.isInteger(this.input(0).data)}}e(ot,"kind","isInteger"),e(ot,"inputs",n.in([])),e(ot,"outputs",n.out(["boolean"]));class at extends n{run(){this.output(0).data=Number.isNaN(this.input(0).data)}}e(at,"kind","isNaN"),e(at,"inputs",n.in([])),e(at,"outputs",n.out(["boolean"]));class dt extends n{run(){this.output(0).data=parseFloat(this.input(0).data)}}e(dt,"kind","parseFloat"),e(dt,"inputs",n.in(["string"])),e(dt,"outputs",n.out(["number"]));class ct extends n{run(){this.output(0).data=parseInt(this.input(0).data)}}e(ct,"kind","parseInt"),e(ct,"inputs",n.in(["number","string"])),e(ct,"outputs",n.out(["number"]));const _t={[rt.kind]:rt,[ot.kind]:ot,[at.kind]:at,[dt.kind]:dt,[ct.kind]:ct};class pt extends n{run(){this.output(0).data=Object.keys(this.input(0).data)}}e(pt,"kind","objectKeys"),e(pt,"inputs",n.in(["object"])),e(pt,"outputs",n.out(["array"]));class ht extends n{run(){this.output(0).data=Object.values(this.input(0).data)}}e(ht,"kind","objectValues"),e(ht,"inputs",n.in(["object"])),e(ht,"outputs",n.out(["array"]));const Dt={[pt.kind]:pt,[ht.kind]:ht};class lt extends n{run(){this.output(0).data=this.input(0).data+this.input(1).data}}e(lt,"kind","addition"),e(lt,"inputs",n.ins(2,["number"])),e(lt,"outputs",n.out(["number"]));class gt extends n{run(){this.output(0).data=this.input(0).data==this.input(1).data}}e(gt,"kind","equality"),e(gt,"inputs",n.ins(2)),e(gt,"outputs",n.out(["boolean"]));class yt extends n{run(){this.output(0).data=this.input(0).data<this.input(1).data}}e(yt,"kind","lessThan"),e(yt,"inputs",n.ins(2,["number"])),e(yt,"outputs",n.out(["boolean"]));class ft extends n{run(){this.output(0).data=this.input(0).data<=this.input(1).data}}e(ft,"kind","lessThanOrEqual"),e(ft,"inputs",n.ins(2,["number"])),e(ft,"outputs",n.out(["boolean"]));class It extends n{run(){this.output(0).data=this.input(0).data>this.input(1).data}}e(It,"kind","greaterThan"),e(It,"inputs",n.ins(2,["number"])),e(It,"outputs",n.out(["boolean"]));class mt extends n{run(){this.output(0).data=this.input(0).data>=this.input(1).data}}e(mt,"kind","greaterThanOrEqual"),e(mt,"inputs",n.ins(2,["number"])),e(mt,"outputs",n.out(["boolean"]));class kt extends n{run(){this.output(0).data=this.input(0).data!=this.input(1).data}}e(kt,"kind","inequality"),e(kt,"inputs",n.ins(2)),e(kt,"outputs",n.out(["boolean"]));class bt extends n{run(){this.output(0).data=this.input(0).data-this.input(1).data}}e(bt,"kind","subtraction"),e(bt,"inputs",n.ins(2,["number"])),e(bt,"outputs",n.out(["number"]));const ts={[lt.kind]:lt,[gt.kind]:gt,[It.kind]:It,[mt.kind]:mt,[yt.kind]:yt,[ft.kind]:ft,[kt.kind]:kt,[bt.kind]:bt};class xt extends n{run(){this.output(0).data=this.input(0).data.length}}e(xt,"kind","stringLength"),e(xt,"inputs",n.in(["string"])),e(xt,"outputs",n.out(["number"]));const ss={[xt.kind]:xt},es=l(l(l(l(l(l(l(l(l(l(l({},Qt),Vt),Xt),Yt),Zt),qt),Lt),_t),Dt),ts),ss);export{es as catalog};
