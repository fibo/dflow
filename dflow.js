var Tt=Object.defineProperty,kt=Object.defineProperties;var Pt=Object.getOwnPropertyDescriptors;var H=Object.getOwnPropertySymbols;var ft=Object.prototype.hasOwnProperty,gt=Object.prototype.propertyIsEnumerable;var ot=(i,t,e)=>t in i?Tt(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e,g=(i,t)=>{for(var e in t||(t={}))ft.call(t,e)&&ot(i,e,t[e]);if(H)for(var e of H(t))gt.call(t,e)&&ot(i,e,t[e]);return i},N=(i,t)=>kt(i,Pt(t));var x=(i,t)=>{var e={};for(var s in i)ft.call(i,s)&&t.indexOf(s)<0&&(e[s]=i[s]);if(i!=null&&H)for(var s of H(i))t.indexOf(s)<0&&gt.call(i,s)&&(e[s]=i[s]);return e};var o=(i,t,e)=>(ot(i,typeof t!="symbol"?t+"":t,e),e),ut=(i,t,e)=>{if(!t.has(i))throw TypeError("Cannot "+e)};var n=(i,t,e)=>(ut(i,t,"read from private field"),e?e.call(i):t.get(i)),y=(i,t,e)=>{if(t.has(i))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(i):t.set(i,e)},S=(i,t,e,s)=>(ut(i,t,"write to private field"),s?s.call(i,e):t.set(i,e),e);var j=(i,t,e)=>(ut(i,t,"access private method"),e);var R,X,k,P,A,U,M,Y,Ot,Z,Et,m,O,h,st,vt,nt,St;const b=i=>`${i} must be a string`,yt=i=>`${i} must be a number`,It=(i,t)=>`${t} pin not found nodeId=${i}`,wt=(i,t,e)=>`${It(i,t)} position=${e}`,mt=(i,t,e)=>`${It(i,t)} pinId=${e}`,dt=({id:i,kind:t,outputs:e})=>({id:i,kind:t,outputs:e==null?void 0:e.map(({id:s,data:r,name:d})=>({id:s,data:r,name:d}))});class u{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowGraph(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&Array.isArray(t.nodes)&&Array.isArray(t.edges)&&C.isDflowGraph(t)}static isDflowId(t){return u.isStringNotEmpty(t)}static isDflowType(t){return typeof t=="string"&&E.types.includes(t)}static isObject(t){return!u.isUndefined(t)&&!u.isNull(t)&&!u.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"&&!isNaN(t)}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return u.isString(t)&&t.length>0}static isUndefined(t){return typeof t>"u"}static validate(t,e){return e.length===0?!0:e.some(s=>{switch(s){case"array":return u.isArray(t);case"boolean":return u.isBoolean(t);case"null":return u.isNull(t);case"number":return u.isNumber(t);case"object":return u.isObject(t);case"string":return u.isString(t);case"DflowGraph":return u.isDflowGraph(t);case"DflowId":return u.isDflowId(t);case"DflowType":return u.isDflowType(t);default:return!1}},!0)}}class B{constructor({id:t,name:e}){o(this,"id");o(this,"name");this.id=t,this.name=e}static isDflowItem({id:t,name:e}){return u.isDflowId(t)&&(u.isUndefined(e)||u.isStringNotEmpty(e))}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const Q=class extends B{constructor(t,r){var d=r,{types:e=[]}=d,s=x(d,["types"]);super(s);o(this,"kind");o(this,"types");this.kind=t,this.types=e}static isDflowPin(s){var r=s,{types:t=[]}=r,e=x(r,["types"]);return B.isDflowItem(e)&&Q.isDflowPinTypes(t)}static isDflowPinType(t){return typeof t!="string"?!1:Q.types.includes(t)}static isDflowPinTypes(t){return Array.isArray(t)?t.every(e=>Q.isDflowPinType(e)):!1}get hasTypeAny(){return this.types.length===0}hasType(t){return this.hasTypeAny||this.types.includes(t)}};let E=Q;o(E,"types",["string","number","boolean","null","object","array","DflowId","DflowGraph","DflowType"]);class ct extends E{constructor(s){var r=s,{optional:t}=r,e=x(r,["optional"]);super("input",e);y(this,R,void 0);y(this,X,void 0);S(this,X,t)}static isDflowInput({id:t,types:e}){return E.isDflowPin({id:t,types:e})}get data(){var t;return(t=n(this,R))==null?void 0:t.data}get isConnected(){return typeof n(this,R)>"u"}get isOptional(){return n(this,X)}connectTo(t){const{hasTypeAny:e,types:s}=this,{types:r}=t;if(e||s.some(d=>r.includes(d)))S(this,R,t);else throw new Error(`mismatching pinTypes, source has types [${r.join()}] and target has types [${s.join()}]`)}disconnect(){S(this,R,void 0)}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}R=new WeakMap,X=new WeakMap;class at extends E{constructor(s){var r=s,{data:t}=r,e=x(r,["data"]);super("output",e);y(this,k,void 0);S(this,k,t)}static isDflowOutput({id:t,data:e,types:s=[]}){return E.isDflowPin({id:t,types:s})&&u.validate(e,s)}clear(){S(this,k,void 0)}get data(){return n(this,k)}set data(t){switch(!0){case u.isUndefined(t):this.clear();break;case this.hasTypeAny:case(u.isDflowGraph(t)&&this.hasType("DflowGraph")):case(u.isDflowId(t)&&this.hasType("DflowId")):case(u.isString(t)&&this.hasType("string")):case(u.isNumber(t)&&this.hasType("number")):case(u.isBoolean(t)&&this.hasType("boolean")):case(u.isNull(t)&&this.hasType("null")):case(u.isObject(t)&&this.hasType("object")):case(u.isArray(t)&&this.hasType("array")):{S(this,k,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=g({},super.toObject());return u.isUndefined(n(this,k))||(t.data=n(this,k)),this.types.length>0&&(t.types=this.types),t}}k=new WeakMap;class c extends B{constructor(f,d,{isAsync:p=!1,isConstant:a=!1}={}){var l=f,{kind:t,inputs:e=[],outputs:s=[]}=l,r=x(l,["kind","inputs","outputs"]);super(r);y(this,Y);y(this,Z);y(this,P,new Map);y(this,A,new Map);y(this,U,[]);y(this,M,[]);o(this,"kind");o(this,"meta");o(this,"host");this.host=d,this.kind=t,this.meta={isAsync:p,isConstant:a};for(const I of e)this.newInput(I);for(const I of s)this.newOutput(I)}static input(t=[],e){if(E.isDflowPinType(t))return g({types:[t]},e);if(E.isDflowPinTypes(t))return g({types:t},e);throw new TypeError("invalid input definition")}static output(t=[],e){if(E.isDflowPinType(t))return g({types:[t]},e);if(E.isDflowPinTypes(t))return g({types:t},e);throw new TypeError("invalid output definition")}static in(t=[],e){return[g({types:t},e)]}static out(t=[],e){return[g({types:t},e)]}static isDflowNode(d){var p=d,{kind:t,inputs:e=[],outputs:s=[]}=p,r=x(p,["kind","inputs","outputs"]);return B.isDflowItem(r)&&u.isStringNotEmpty(t)&&e.every(a=>ct.isDflowInput(a))&&s.every(a=>at.isDflowOutput(a))}get inputs(){return n(this,P).values()}get outputs(){return n(this,A).values()}get numInputs(){return n(this,P).size}get numOutputs(){return n(this,A).size}clearOutputs(){for(const t of this.outputs)t.clear()}getInputById(t){if(typeof t!="string")throw new TypeError(b("inputId"));const e=n(this,P).get(t);if(e)return e;throw new Error(mt(this.id,"input",t))}input(t){if(typeof t!="number")throw new TypeError(yt("position"));const e=n(this,U)[t];if(u.isUndefined(e))throw new Error(wt(this.id,"input",t));return this.getInputById(e)}getOutputById(t){if(typeof t!="string")throw new TypeError(b("outputId"));const e=n(this,A).get(t);if(e)return e;throw new Error(mt(this.id,"output",t))}output(t){if(typeof t!="number")throw new TypeError(yt("position"));const e=n(this,M)[t];if(u.isUndefined(e))throw new Error(wt(this.id,"output",t));return this.getOutputById(e)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),n(this,P).delete(t),n(this,U).splice(n(this,U).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),n(this,A).delete(t),n(this,M).splice(n(this,M).indexOf(t),1)}newInput(t){const e=u.isDflowId(t.id)?t.id:j(this,Y,Ot).call(this),s=new ct(N(g({},t),{id:e}));return n(this,P).set(e,s),n(this,U).push(e),s}newOutput(t){const e=u.isDflowId(t.id)?t.id:j(this,Z,Et).call(this),s=new at(N(g({},t),{id:e}));return n(this,A).set(e,s),n(this,M).push(e),s}run(){}toObject(){const t=N(g({},super.toObject()),{kind:this.kind}),e=[],s=[];for(const r of this.inputs)e.push(r.toObject());e.length>0&&(t.inputs=e);for(const r of this.outputs)s.push(r.toObject());return s.length>0&&(t.outputs=s),t}}P=new WeakMap,A=new WeakMap,U=new WeakMap,M=new WeakMap,Y=new WeakSet,Ot=function(t=this.numInputs){const e=`i${t}`;return n(this,P).has(e)?j(this,Y,Ot).call(this,t+1):e},Z=new WeakSet,Et=function(t=this.numOutputs){const e=`o${t}`;return n(this,A).has(e)?j(this,Z,Et).call(this,t+1):e},o(c,"kind"),o(c,"isAsync"),o(c,"isConstant"),o(c,"inputs"),o(c,"outputs");const pt=class extends c{constructor(t,e){super(N(g({},t),{kind:pt.kind}),e)}run(){}};let _=pt;o(_,"kind","Unknown");class ht extends B{constructor(r){var d=r,{source:t,target:e}=d,s=x(d,["source","target"]);super(s);o(this,"source");o(this,"target");const[p,a]=t,[f,l]=e;if(typeof p!="string")throw new TypeError(b("sourceNodeId"));if(typeof a!="string")throw new TypeError(b("sourcePinId"));if(typeof f!="string")throw new TypeError(b("targetNodeId"));if(typeof l!="string")throw new TypeError(b("targetPinId"));this.source=t,this.target=e}static isDflowEdge(d,r){var p=d,{source:t,target:e}=p,s=x(p,["source","target"]);return B.isDflowItem(s)&&Array.isArray(t)&&t.length===2&&r.nodes.find(({id:a,outputs:f=[]})=>a===t[0]&&f.find(({id:l})=>l===t[1]))&&Array.isArray(e)&&e.length===2&&r.nodes.find(({id:a,inputs:f=[]})=>a===e[0]&&f.find(({id:l})=>l===e[1]))}toObject(){return N(g({},super.toObject()),{source:this.source,target:this.target})}}const T=class extends B{constructor(){super(...arguments);y(this,m,new Map);y(this,O,new Map);o(this,"runOptions",{verbose:!1});o(this,"runStatus",null);o(this,"executionReport",null)}static isDflowGraph(t){return t.nodes.every(e=>c.isDflowNode(e))&&t.edges.every(e=>ht.isDflowEdge(e,t))}static childrenOfNodeId(t,e){return e.filter(({sourceId:s})=>t===s).map(({targetId:s})=>s)}static parentsOfNodeId(t,e){return e.filter(({targetId:s})=>t===s).map(({sourceId:s})=>s)}static levelOfNodeId(t,e){const s=T.parentsOfNodeId(t,e);if(s.length===0)return 0;let r=0;for(const d of s){const p=T.levelOfNodeId(d,e);r=Math.max(p,r)}return r+1}static ancestorsOfNodeId(t,e){const s=T.parentsOfNodeId(t,e);return s.length===0?[]:s.reduce((r,d,p,a)=>{const f=T.ancestorsOfNodeId(d,e),l=r.concat(f);return p===a.length-1?Array.from(new Set(a.concat(l))):l},[])}static sort(t,e){const s={};for(const r of t)s[r]=T.levelOfNodeId(r,e);return t.slice().sort((r,d)=>s[r]<=s[d]?-1:1)}get edges(){return n(this,O).values()}get nodes(){return n(this,m).values()}get nodeConnections(){return[...n(this,O).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...n(this,O).keys()]}get nodeIds(){return[...n(this,m).keys()]}get numEdges(){return n(this,O).size}get numNodes(){return n(this,m).size}addEdge(t){if(n(this,O).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);n(this,O).set(t.id,t)}addNode(t){if(n(this,m).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);n(this,m).set(t.id,t)}clear(){n(this,m).clear(),n(this,O).clear()}deleteEdge(t){n(this,O).delete(t)}deleteNode(t){n(this,m).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(b("nodeId"));const e=n(this,m).get(t);if(e)return e;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(b("edgeId"));const e=n(this,O).get(t);if(e)return e;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const e=`e${t}`;return n(this,O).has(e)?this.generateEdgeId(t+1):e}generateNodeId(t=this.numNodes){const e=`n${t}`;return n(this,m).has(e)?this.generateNodeId(t+1):e}nodeIdsInsideFunctions(){const t=[];for(const e of this.nodes)e.kind==="return"&&t.push(T.ancestorsOfNodeId(e.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){var r,d;const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const e=this.nodeIdsInsideFunctions(),s=T.sort(this.nodeIds.filter(p=>!e.includes(p)),this.nodeConnections);e:for(const p of s){const a=n(this,m).get(p);try{if(!a.meta.isConstant){let f=!1;t:for(const{data:l,types:I,isOptional:v}of a.inputs){if(v&&typeof l>"u")continue t;if(!u.validate(l,I)){f=!0;break t}}if(f){for(const l of a.outputs)l.clear();t&&((r=this.executionReport.steps)==null||r.push(dt(a.toObject())));continue e}a.meta.isAsync?await a.run():a.run()}t&&((d=this.executionReport.steps)==null||d.push(dt(a.toObject())))}catch(f){console.error(f),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=N(g({},super.toObject()),{nodes:[],edges:[]});for(const e of this.nodes)t.nodes.push(e.toObject());for(const e of this.edges)t.edges.push(e.toObject());return t}};let C=T;m=new WeakMap,O=new WeakMap;const{input:Nt,output:bt}=c;class D extends c{}o(D,"kind","argument"),o(D,"isConstant",!0),o(D,"inputs",[Nt("number",{name:"position",optional:!0})]),o(D,"outputs",[bt()]);class z extends c{run(){const t=this.input(0).data;u.isArray(t)?this.output(0).data=t:this.output(0).clear()}}o(z,"kind","array"),o(z,"inputs",c.in()),o(z,"outputs",c.out(["array"]));class K extends c{run(){const t=this.input(0).data;u.isBoolean(t)?this.output(0).data=t:this.output(0).clear()}}o(K,"kind","boolean"),o(K,"inputs",[Nt()]),o(K,"outputs",[bt("boolean")]);class F extends c{}o(F,"kind","data"),o(F,"isConstant",!0),o(F,"outputs",c.out());class J extends c{constructor(...t){super(...t);this.output(0).data=this.id}}o(J,"kind","function"),o(J,"isConstant",!0),o(J,"outputs",c.out(["DflowId"],{name:"id"}));class tt extends c{run(){const t=this.output(0);t.data=this.host.nodeKinds}}o(tt,"kind","dflow"),o(tt,"outputs",c.out(["array"],{name:"nodeKinds"}));class L extends c{run(){this.output(0).data=u.isUndefined(this.input(0).data)}}o(L,"kind","isUndefined"),o(L,"inputs",c.in()),o(L,"outputs",c.out(["boolean"]));class V extends c{run(){const t=this.input(0).data;u.isNumber(t)?this.output(0).data=t:this.output(0).clear()}}o(V,"kind","number"),o(V,"inputs",c.in()),o(V,"outputs",c.out(["number"]));class W extends c{run(){const t=this.input(0).data;u.isObject(t)?this.output(0).data=t:this.output(0).clear()}}o(W,"kind","object"),o(W,"inputs",c.in()),o(W,"outputs",c.out(["object"]));class G extends c{}o(G,"kind","return"),o(G,"isConstant",!0),o(G,"inputs",[...c.in(["DflowId"],{name:"functionId"}),...c.in([],{name:"value"})]);class q extends c{run(){const t=this.input(0).data;u.isString(t)?this.output(0).data=t:this.output(0).clear()}}o(q,"kind","string"),o(q,"inputs",c.in()),o(q,"outputs",c.out(["string"]));const At={[D.kind]:D,[z.kind]:z,[K.kind]:K,[F.kind]:F,[tt.kind]:tt,[L.kind]:L,[V.kind]:V,[W.kind]:W,[J.kind]:J,[q.kind]:q,[G.kind]:G},it=class{constructor(t={}){y(this,h,void 0);o(this,"nodesCatalog");o(this,"context");this.nodesCatalog=g(g({},t),At),S(this,h,new C({id:"g1"})),this.context={}}get executionReport(){return n(this,h).executionReport}get edges(){return n(this,h).edges}get nodes(){return n(this,h).nodes}get numEdges(){return n(this,h).numEdges}get numNodes(){return n(this,h).numNodes}get nodeKinds(){return Object.keys(this.nodesCatalog)}get runStatusIsSuccess(){return n(this,h).runStatus==="success"}get runStatusIsWaiting(){return n(this,h).runStatus==="waiting"}get runStatusIsFailure(){return n(this,h).runStatus==="failure"}set verbose(t){n(this,h).runOptions.verbose=t}clearGraph(){n(this,h).clear()}connect(t,e=0){return{to:(s,r=0)=>{const d=n(this,h).generateEdgeId(),p=t.output(e),a=s.input(r);this.newEdge({id:d,source:[t.id,p.id],target:[s.id,a.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(b("edgeId"));const e=n(this,h).getEdgeById(t);if(e){const[s,r]=e.target;this.getNodeById(s).getInputById(r).disconnect(),n(this,h).deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(b("nodeId"));const e=this.getNodeById(t);if(e){for(const s of n(this,h).edges){const{source:[r],target:[d]}=s;(r===e.id||d===e.id)&&this.deleteEdge(s.id)}n(this,h).deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,e]){for(const s of this.edges){const[r,d]=s.source,[p,a]=s.target;(r===t&&d===e||p===t&&a===e)&&this.deleteEdge(s.id)}}executeFunction(t,e){var l,I;const{verbose:s}=n(this,h).runOptions,r=n(this,h).nodeConnections,d=C.childrenOfNodeId(t,r),p=[];for(const v of d){const w=this.getNodeById(v);w.kind===G.kind&&p.push(w.id)}const a=p.reduce((v,w,$,rt)=>{const xt=C.ancestorsOfNodeId(w,r),lt=v.concat(xt);return $===rt.length?Array.from(new Set(lt)):lt},[]),f=C.sort([...p,...a],r);for(const v of f){const w=this.getNodeById(v);try{switch(w.kind){case D.kind:{const $=w.input(0).data,rt=typeof $=="number"&&!isNaN($)?Math.max($,0):0;w.output(0).data=e[rt];break}case G.kind:return w.input(1).data;default:!w.meta.isConstant&&!w.meta.isAsync&&w.run(),s&&((I=(l=this.executionReport)==null?void 0:l.steps)==null||I.push(dt(w.toObject())))}}catch($){console.error($)}}}getEdgeById(t){return n(this,h).getEdgeById(t)}getNodeById(t){return n(this,h).getNodeById(t)}newNode(t){var f,l,I;const e=(f=this.nodesCatalog[t.kind])!=null?f:_,s=u.isDflowId(t.id)?t.id:n(this,h).generateNodeId(),r={isAsync:e.isAsync,isConstant:e.isConstant},d=Array.isArray(t.inputs)?t.inputs:j(l=it,st,vt).call(l,e.inputs),p=Array.isArray(t.outputs)?t.outputs:j(I=it,nt,St).call(I,e.outputs),a=new e(N(g({},t),{id:s,inputs:d,outputs:p}),this,r);return n(this,h).addNode(a),a}newEdge(t){const e=u.isDflowId(t.id)?t.id:n(this,h).generateEdgeId(),s=new ht(N(g({},t),{id:e}));n(this,h).addEdge(s);const[r,d]=s.source,[p,a]=s.target,f=n(this,h).getNodeById(r),l=n(this,h).getNodeById(p),I=f.getOutputById(d);return l.getInputById(a).connectTo(I),s}newInput(t,e){return n(this,h).getNodeById(t).newInput(e)}newOutput(t,e){return n(this,h).getNodeById(t).newOutput(e)}toObject(){return n(this,h).toObject()}async run(){await n(this,h).run()}};let et=it;h=new WeakMap,st=new WeakSet,vt=function(t=[]){return t.map((e,s)=>N(g({},e),{id:`i${s}`}))},nt=new WeakSet,St=function(t=[]){return t.map((e,s)=>N(g({},e),{id:`o${s}`}))},y(et,st),y(et,nt);export{u as DflowData};export{B as DflowItem};export{E as DflowPin};export{ct as DflowInput};export{at as DflowOutput};export{c as DflowNode};export{_ as DflowUnknownNode};export{ht as DflowEdge};export{C as DflowGraph};export{et as DflowHost};
