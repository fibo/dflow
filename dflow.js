var bt=Object.defineProperty,Et=Object.defineProperties;var Nt=Object.getOwnPropertyDescriptors;var it=Object.getOwnPropertySymbols;var pt=Object.prototype.hasOwnProperty,ft=Object.prototype.propertyIsEnumerable;var ot=(r,t,e)=>t in r?bt(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e,l=(r,t)=>{for(var e in t||(t={}))pt.call(t,e)&&ot(r,e,t[e]);if(it)for(var e of it(t))ft.call(t,e)&&ot(r,e,t[e]);return r},x=(r,t)=>Et(r,Nt(t));var P=(r,t)=>{var e={};for(var s in r)pt.call(r,s)&&t.indexOf(s)<0&&(e[s]=r[s]);if(r!=null&&it)for(var s of it(r))t.indexOf(s)<0&&ft.call(r,s)&&(e[s]=r[s]);return e};var o=(r,t,e)=>(ot(r,typeof t!="symbol"?t+"":t,e),e),ut=(r,t,e)=>{if(!t.has(r))throw TypeError("Cannot "+e)};var n=(r,t,e)=>(ut(r,t,"read from private field"),e?e.call(r):t.get(r)),w=(r,t,e)=>{if(t.has(r))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(r):t.set(r,e)},k=(r,t,e,s)=>(ut(r,t,"write to private field"),s?s.call(r,e):t.set(r,e),e);var W=(r,t,e)=>(ut(r,t,"access private method"),e);var S,et,F,$,B,C,D,G,J,m,O,h,st,wt,nt,mt;const T=r=>`${r} must be a string`,lt=(r,t)=>`${t} pin not found nodeId=${r}`,gt=(r,t,e)=>`${lt(r,t)} position=${e}`,yt=(r,t,e)=>`${lt(r,t)} pinId=${e}`,dt=({id:r,kind:t,outputs:e},s)=>{const i={id:r,kind:t,outputs:e==null?void 0:e.map(({id:u,data:d,name:a})=>({id:u,data:d,name:a}))};return s&&(i.error=s),i};class c{static isArray(t){return!!Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowId(t){return c.isStringNotEmpty(t)}static isObject(t){return!(typeof t!="object"||!t||Array.isArray(t))}static isNumber(t){return typeof t=="number"&&!isNaN(t)}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return c.isString(t)&&t!==""}static validate(t,e){return e.length===0?!0:e.some(s=>{switch(s){case"array":return c.isArray(t);case"boolean":return c.isBoolean(t);case"number":return c.isNumber(t);case"object":return c.isObject(t);case"string":return c.isString(t);case"DflowId":return c.isDflowId(t);default:return!1}},!0)}}class R{constructor({id:t,name:e}){o(this,"id");o(this,"name");this.id=t,this.name=e}static isDflowItem(t){if(typeof t!="object"||!t)return!1;const{id:e,name:s}=t;return c.isDflowId(e)&&(typeof s>"u"||c.isStringNotEmpty(s))}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const tt=class extends R{constructor(t,i){var u=i,{types:e=[]}=u,s=P(u,["types"]);super(s);o(this,"kind");o(this,"types");this.kind=t,this.types=e}static isDflowPin(t){if(typeof t!="object"||!t)return!1;const i=t,{types:e}=i,s=P(i,["types"]);return R.isDflowItem(s)&&tt.isDflowPinTypes(e)}static isDflowPinType(t){return typeof t!="string"?!1:tt.types.includes(t)}static isDflowPinTypes(t){return Array.isArray(t)?t.every(e=>tt.isDflowPinType(e)):!1}get hasTypeAny(){return this.types.length===0}hasType(t){return this.hasTypeAny||this.types.includes(t)}toObject(){const t=super.toObject();return this.types.length>0&&(t.types=this.types),t}};let E=tt;o(E,"types",["string","number","boolean","object","array","DflowId"]);class at extends E{constructor(i){var u=i,{multi:t,optional:e}=u,s=P(u,["multi","optional"]);super("input",s);w(this,S,void 0);w(this,et,void 0);w(this,F,void 0);w(this,$,void 0);k(this,S,t),k(this,et,e)}static isDflowInput(t){if(typeof t!="object"||!t)return!1;const{id:e,types:s,optional:i,multi:u}=t;return E.isDflowPin({id:e,types:s})&&(typeof u>"u"||typeof u=="boolean")&&(typeof i>"u"||typeof i=="boolean")}get data(){var t,e;if(n(this,S)){const s=Array.from((t=n(this,$))!=null?t:[]);return s.length?s.map(i=>i.data):void 0}else return(e=n(this,F))==null?void 0:e.data}get isConnected(){var t;return n(this,S)?Array.from((t=n(this,$))!=null?t:[]).length>0:typeof n(this,F)>"u"}get isMulti(){return n(this,S)}get isOptional(){return n(this,et)}connectTo(t){const{hasTypeAny:e,types:s}=this,{types:i}=t;if(e||s.some(d=>i.includes(d)))n(this,S)?(n(this,$)||k(this,$,new Set),n(this,$).add(t)):k(this,F,t);else throw new Error(`mismatching pinTypes, source has types [${i.join()}] and target has types [${s.join()}]`)}disconnect(){var t;n(this,S)?(t=n(this,$))==null||t.clear():k(this,F,void 0)}toObject(){return super.toObject()}}S=new WeakMap,et=new WeakMap,F=new WeakMap,$=new WeakMap;class ct extends E{constructor(s){var i=s,{data:t}=i,e=P(i,["data"]);super("output",e);w(this,B,void 0);k(this,B,t)}static isDflowOutput({id:t,data:e,types:s=[]}){return E.isDflowPin({id:t,types:s})&&c.validate(e,s)}clear(){k(this,B,void 0)}get data(){return n(this,B)}set data(t){switch(!0){case typeof t>"u":this.clear();break;case this.hasTypeAny:case(this.hasType("string")&&c.isString(t)):case(this.hasType("number")&&c.isNumber(t)):case(this.hasType("boolean")&&c.isBoolean(t)):case(this.hasType("object")&&c.isObject(t)):case(this.hasType("array")&&c.isArray(t)):case(this.hasType("DflowId")&&c.isDflowId(t)):{k(this,B,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=super.toObject();return typeof n(this,B)<"u"&&(t.data=n(this,B)),t}}B=new WeakMap;class g extends R{constructor(y,u,{isAsync:d=!1,isConstant:a=!1}={}){var p=y,{kind:t,inputs:e=[],outputs:s=[]}=p,i=P(p,["kind","inputs","outputs"]);super(i);w(this,C,new Map);w(this,D,new Map);w(this,G,[]);w(this,J,[]);o(this,"kind");o(this,"meta");o(this,"host");this.host=u,this.kind=t,this.meta={isAsync:d,isConstant:a};for(const I of e)this.newInput(I);for(const I of s)this.newOutput(I)}static input(t=[],e){if(E.isDflowPinType(t))return l({types:[t]},e);if(E.isDflowPinTypes(t))return l({types:t},e);throw new TypeError("invalid input definition")}static output(t=[],e){if(E.isDflowPinType(t))return l({types:[t]},e);if(E.isDflowPinTypes(t))return l({types:t},e);throw new TypeError("invalid output definition")}static in(t=[],e){return[l({types:t},e)]}static out(t=[],e){return[l({types:t},e)]}static isDflowNode(t){if(typeof t!="object"||!t)return!1;const d=t,{kind:e,inputs:s=[],outputs:i=[]}=d,u=P(d,["kind","inputs","outputs"]);return R.isDflowItem(u)&&c.isStringNotEmpty(e)&&s.every(a=>at.isDflowInput(a))&&i.every(a=>ct.isDflowOutput(a))}get inputs(){return n(this,C).values()}get outputs(){return n(this,D).values()}clearOutputs(){for(const t of this.outputs)t.clear()}getInputById(t){if(typeof t!="string")throw new TypeError(T("inputId"));const e=n(this,C).get(t);if(e)return e;throw new Error(yt(this.id,"input",t))}input(t){const e=n(this,G)[t];if(!e)throw new Error(gt(this.id,"input",t));return this.getInputById(e)}getOutputById(t){if(typeof t!="string")throw new TypeError(T("outputId"));const e=n(this,D).get(t);if(e)return e;throw new Error(yt(this.id,"output",t))}output(t){const e=n(this,J)[t];if(!e)throw new Error(gt(this.id,"output",t));return this.getOutputById(e)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),n(this,C).delete(t),n(this,G).splice(n(this,G).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),n(this,D).delete(t),n(this,J).splice(n(this,J).indexOf(t),1)}newInput(t){const e=n(this,C).size,s=(d=e)=>{const a=`i${d}`;return n(this,C).has(a)?s(d+1):a},i=c.isDflowId(t.id)?t.id:s(),u=new at(x(l({},t),{id:i}));return n(this,C).set(i,u),n(this,G).push(i),u}newOutput(t){const e=n(this,D).size,s=(d=e)=>{const a=`o${d}`;return n(this,D).has(a)?s(d+1):a},i=c.isDflowId(t.id)?t.id:s(),u=new ct(x(l({},t),{id:i}));return n(this,D).set(i,u),n(this,J).push(i),u}run(){}toObject(){const t=x(l({},super.toObject()),{kind:this.kind}),e=[],s=[];for(const i of this.inputs)e.push(i.toObject());e.length>0&&(t.inputs=e);for(const i of this.outputs)s.push(i.toObject());return s.length>0&&(t.outputs=s),t}}C=new WeakMap,D=new WeakMap,G=new WeakMap,J=new WeakMap,o(g,"kind"),o(g,"isAsync"),o(g,"isConstant"),o(g,"inputs"),o(g,"outputs");class It extends R{constructor(i){var u=i,{source:t,target:e}=u,s=P(u,["source","target"]);super(s);o(this,"source");o(this,"target");const[d,a]=t,[y,p]=e;if(typeof d!="string")throw new TypeError(T("sourceNodeId"));if(typeof a!="string")throw new TypeError(T("sourcePinId"));if(typeof y!="string")throw new TypeError(T("targetNodeId"));if(typeof p!="string")throw new TypeError(T("targetPinId"));this.source=t,this.target=e}static isDflowEdge(t){if(typeof t!="object"||!t)return!1;const u=t,{source:e,target:s}=u,i=P(u,["source","target"]);return!(R.isDflowItem(i)||!Array.isArray(e)||e.length!==2||c.isDflowId(e[0])||c.isDflowId(e[1])||!Array.isArray(s)||s.length!==2||c.isDflowId(s[0])||c.isDflowId(s[1]))}toObject(){return x(l({},super.toObject()),{source:this.source,target:this.target})}}const v=class extends R{constructor(){super(...arguments);w(this,m,new Map);w(this,O,new Map);o(this,"runOptions",{verbose:!1});o(this,"runStatus",null);o(this,"executionReport",null)}static childrenOfNodeId(t,e){return e.filter(({sourceId:s})=>t===s).map(({targetId:s})=>s)}static parentsOfNodeId(t,e){return e.filter(({targetId:s})=>t===s).map(({sourceId:s})=>s)}static levelOfNodeId(t,e){const s=v.parentsOfNodeId(t,e);if(s.length===0)return 0;let i=0;for(const u of s){const d=v.levelOfNodeId(u,e);i=Math.max(d,i)}return i+1}static ancestorsOfNodeId(t,e){const s=v.parentsOfNodeId(t,e);return s.length===0?[]:s.reduce((i,u,d,a)=>{const y=v.ancestorsOfNodeId(u,e),p=i.concat(y);return d===a.length-1?Array.from(new Set(a.concat(p))):p},[])}static sort(t,e){const s={};for(const i of t)s[i]=v.levelOfNodeId(i,e);return t.slice().sort((i,u)=>s[i]<=s[u]?-1:1)}get edges(){return n(this,O).values()}get nodes(){return n(this,m).values()}get nodeConnections(){return[...n(this,O).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...n(this,O).keys()]}get nodeIds(){return[...n(this,m).keys()]}get numEdges(){return n(this,O).size}get numNodes(){return n(this,m).size}addEdge(t){if(n(this,O).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);n(this,O).set(t.id,t)}addNode(t){if(n(this,m).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);n(this,m).set(t.id,t)}clear(){n(this,m).clear(),n(this,O).clear()}deleteEdge(t){n(this,O).delete(t)}deleteNode(t){n(this,m).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(T("nodeId"));const e=n(this,m).get(t);if(e)return e;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(T("edgeId"));const e=n(this,O).get(t);if(e)return e;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const e=`e${t}`;return n(this,O).has(e)?this.generateEdgeId(t+1):e}generateNodeId(t=this.numNodes){const e=`n${t}`;return n(this,m).has(e)?this.generateNodeId(t+1):e}nodeIdsInsideFunctions(){const t=[];for(const e of this.nodes)e.kind==="return"&&t.push(v.ancestorsOfNodeId(e.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){var i,u;const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const e=this.nodeIdsInsideFunctions(),s=v.sort(this.nodeIds.filter(d=>!e.includes(d)),this.nodeConnections);e:for(const d of s){const a=n(this,m).get(d);try{if(!a.meta.isConstant){let y=!1;t:for(const{id:p,data:I,types:b,isOptional:f}of a.inputs){if(f&&typeof I>"u")continue t;if(!c.validate(I,b)){y=!0,t&&((i=this.executionReport.steps)==null||i.push(dt(a.toObject(),`invalid input data nodeId=${d} inputId=${p} data=${I}`)));break t}}if(y){for(const p of a.outputs)p.clear();continue e}a.meta.isAsync?await a.run():a.run()}t&&((u=this.executionReport.steps)==null||u.push(dt(a.toObject())))}catch(y){console.error(y),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=x(l({},super.toObject()),{nodes:[],edges:[]});for(const e of this.nodes)t.nodes.push(e.toObject());for(const e of this.edges)t.edges.push(e.toObject());return t}};let L=v;m=new WeakMap,O=new WeakMap;const V=class{constructor(t={}){w(this,h,void 0);o(this,"nodesCatalog");o(this,"context");this.nodesCatalog=l(l({},t),kt),k(this,h,new L({id:"g1"})),this.context={}}get executionReport(){return n(this,h).executionReport}get edges(){return n(this,h).edges}get nodes(){return n(this,h).nodes}get numEdges(){return n(this,h).numEdges}get numNodes(){return n(this,h).numNodes}get nodeKinds(){return Object.keys(this.nodesCatalog)}get runStatusIsSuccess(){return n(this,h).runStatus==="success"}get runStatusIsWaiting(){return n(this,h).runStatus==="waiting"}get runStatusIsFailure(){return n(this,h).runStatus==="failure"}set verbose(t){n(this,h).runOptions.verbose=t}clearGraph(){n(this,h).clear()}connect(t,e=0){return{to:(s,i=0)=>{const u=n(this,h).generateEdgeId(),d=t.output(e),a=s.input(i);this.newEdge({id:u,source:[t.id,d.id],target:[s.id,a.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(T("edgeId"));const e=n(this,h).getEdgeById(t);if(e){const[s,i]=e.target;this.getNodeById(s).getInputById(i).disconnect(),n(this,h).deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(T("nodeId"));const e=this.getNodeById(t);if(e){for(const s of n(this,h).edges){const{source:[i],target:[u]}=s;(i===e.id||u===e.id)&&this.deleteEdge(s.id)}n(this,h).deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,e]){for(const s of this.edges){const[i,u]=s.source,[d,a]=s.target;(i===t&&u===e||d===t&&a===e)&&this.deleteEdge(s.id)}}executeFunction(t,e){var p,I;const{verbose:s}=n(this,h).runOptions,i=n(this,h).nodeConnections,u=L.childrenOfNodeId(t,i),d=[];for(const b of u){const f=this.getNodeById(b);f.kind===z.kind&&d.push(f.id)}const a=d.reduce((b,f,N,K)=>{const Ot=L.ancestorsOfNodeId(f,i),ht=b.concat(Ot);return N===K.length?Array.from(new Set(ht)):ht},[]),y=L.sort([...d,...a],i);for(const b of y){const f=this.getNodeById(b);try{switch(f.kind){case M.kind:{const N=f.input(0).data,K=typeof N=="number"&&!isNaN(N)?Math.max(N,0):0;f.output(0).data=e[K];break}case z.kind:return f.input(1).data;default:!f.meta.isConstant&&!f.meta.isAsync&&f.run(),s&&((I=(p=this.executionReport)==null?void 0:p.steps)==null||I.push(dt(f.toObject())))}}catch(N){console.error(N)}}}getEdgeById(t){return n(this,h).getEdgeById(t)}getNodeById(t){return n(this,h).getNodeById(t)}newNode(t){var y,p,I,b,f,N,K;const e=(y=this.nodesCatalog[t.kind])!=null?y:xt,s=c.isDflowId(t.id)?t.id:n(this,h).generateNodeId(),i={isAsync:e.isAsync,isConstant:e.isConstant},u=Array.isArray(t.inputs)?W(p=V,st,wt).call(p,t.inputs):W(b=V,st,wt).call(b,(I=e.inputs)!=null?I:[]),d=Array.isArray(t.outputs)?W(f=V,nt,mt).call(f,t.outputs):W(K=V,nt,mt).call(K,(N=e.outputs)!=null?N:[]),a=new e(x(l({},t),{id:s,inputs:u,outputs:d}),this,i);return n(this,h).addNode(a),a}newEdge(t){const e=c.isDflowId(t.id)?t.id:n(this,h).generateEdgeId(),s=new It(x(l({},t),{id:e}));n(this,h).addEdge(s);const[i,u]=s.source,[d,a]=s.target,y=n(this,h).getNodeById(i),p=n(this,h).getNodeById(d),I=y.getOutputById(u);return p.getInputById(a).connectTo(I),s}newInput(t,e){return n(this,h).getNodeById(t).newInput(e)}newOutput(t,e){return n(this,h).getNodeById(t).newOutput(e)}toObject(){return n(this,h).toObject()}async run(){await n(this,h).run()}};let rt=V;h=new WeakMap,st=new WeakSet,wt=function(t=[]){return t.map((e,s)=>x(l({},e),{id:c.isDflowId(e.id)?e.id:`i${s}`}))},nt=new WeakSet,mt=function(t=[]){return t.map((e,s)=>x(l({},e),{id:c.isDflowId(e.id)?e.id:`o${s}`}))},w(rt,st),w(rt,nt);const{input:j,output:A}=g;class M extends g{}o(M,"kind","argument"),o(M,"isConstant",!0),o(M,"inputs",[j("number",{name:"position",optional:!0})]),o(M,"outputs",[A()]);class q extends g{run(){const t=this.input(0).data;c.isArray(t)?this.output(0).data=t:this.output(0).clear()}}o(q,"kind","array"),o(q,"inputs",[j()]),o(q,"outputs",[A("array")]);class H extends g{run(){const t=this.input(0).data;c.isBoolean(t)?this.output(0).data=t:this.output(0).clear()}}o(H,"kind","boolean"),o(H,"inputs",[j()]),o(H,"outputs",[A("boolean")]);class Q extends g{}o(Q,"kind","data"),o(Q,"isConstant",!0),o(Q,"outputs",[A()]);class U extends g{constructor(...t){super(...t);this.output(0).data=this.id}}o(U,"kind","function"),o(U,"isConstant",!0),o(U,"outputs",[A("DflowId",{name:"id"})]);class X extends g{run(){this.output(0).data=typeof this.input(0).data>"u"}}o(X,"kind","isUndefined"),o(X,"inputs",[j()]),o(X,"outputs",[A("boolean")]);class Y extends g{run(){const t=this.input(0).data;c.isNumber(t)?this.output(0).data=t:this.output(0).clear()}}o(Y,"kind","number"),o(Y,"inputs",[j()]),o(Y,"outputs",[A("number")]);class Z extends g{run(){const t=this.input(0).data;c.isObject(t)?this.output(0).data=t:this.output(0).clear()}}o(Z,"kind","object"),o(Z,"inputs",[j()]),o(Z,"outputs",[A("object")]);class z extends g{}o(z,"kind","return"),o(z,"isConstant",!0),o(z,"inputs",[j("DflowId",{name:"functionId"}),j([],{name:"value"})]);class _ extends g{run(){const t=this.input(0).data;c.isString(t)?this.output(0).data=t:this.output(0).clear()}}o(_,"kind","string"),o(_,"inputs",[j()]),o(_,"outputs",[A("string")]);class xt extends g{}const kt={[M.kind]:M,[q.kind]:q,[H.kind]:H,[Q.kind]:Q,[X.kind]:X,[Y.kind]:Y,[Z.kind]:Z,[U.kind]:U,[_.kind]:_,[z.kind]:z};export{c as DflowData};export{R as DflowItem};export{E as DflowPin};export{at as DflowInput};export{ct as DflowOutput};export{g as DflowNode};export{It as DflowEdge};export{L as DflowGraph};export{rt as DflowHost};
