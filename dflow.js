const d=u=>`${u} must be a string`;class a{id;kind;#t;#e;constructor(t,{id:e,data:s}){this.kind=t,this.id=e,this.setData(s)}connectTo(t){this.kind==="input"&&(this.#e=t)}disconnect(){this.kind==="input"&&(this.#e=void 0)}getData(){if(this.kind==="output")return this.#t;{const t=this.#e;if(typeof t!="undefined")return t.getData()}}setData(t){typeof t!="undefined"&&(this.#t=t)}toJSON(){return JSON.stringify(this.toObject())}toObject(){const t={id:this.id};return typeof this.#t!="undefined"&&(t.data=this.#t),t}}class h{id;kind;isAsync;inputs=new Map;outputs=new Map;#t=[];#e=[];constructor({id:t,kind:e,inputs:s=[],outputs:n=[]},r=!1){this.id=t,this.kind=e,this.isAsync=r;for(const o of s)this.newInput(o);for(const o of n)this.newOutput(o)}getInputById(t){if(typeof t!="string")throw new TypeError(d("inputId"));const e=this.inputs.get(t);if(e instanceof a)return e;throw new Error(`DflowPin not found, id=${t}, kind={input}`)}getInputByPosition(t){const e=this.#t[t];return typeof e=="undefined"?null:this.inputs.get(e)??null}getOutputById(t){if(typeof t!="string")throw new TypeError(d("outputId"));const e=this.outputs.get(t);if(e instanceof a)return e;throw new Error(`DflowPin not found, id=${t}, kind={output}`)}getOutputByPosition(t){const e=this.#e[t];return typeof e=="undefined"?null:this.outputs.get(e)??null}newInput(t){const e=new a("input",t);this.inputs.set(e.id,e),this.#t.push(e.id)}newOutput(t){const e=new a("output",t);this.outputs.set(e.id,e),this.#e.push(e.id)}run(){throw new Error(`${this.constructor.name} does not implement a run() method`)}toJSON(){return JSON.stringify(this.toObject())}toObject(){const t={id:this.id,kind:this.kind},e=Object.values(this.inputs).map(n=>n.toObject());e.length>0&&(t.inputs=e);const s=Object.values(this.outputs).map(n=>n.toObject());return s.length>0&&(t.outputs=s),t}}class g extends h{static kind="Unknown";constructor(t){super({...t,kind:g.kind})}run(){}}class f{id;source;target;constructor({id:t,source:e,target:s}){this.id=t;const[n,r]=e,[o,i]=s;if(typeof n!="string")throw new TypeError(d("sourceNodeId"));if(typeof r!="string")throw new TypeError(d("sourcePinId"));if(typeof o!="string")throw new TypeError(d("targetNodeId"));if(typeof i!="string")throw new TypeError(d("targetPinId"));this.source=e,this.target=s}toJSON(){return JSON.stringify(this.toObject())}toObject(){return{id:this.id,source:this.source,target:this.target}}}class p{nodes=new Map;edges=new Map;#t="success";static sort(t,e){const s={},n=o=>e.filter(({targetId:i})=>o===i).map(({sourceId:i})=>i),r=o=>{const i=n(o);if(i.length===0)return 0;let c=0;for(const l of i){const w=r(l);c=Math.max(w,c)}return c+1};for(const o of t)s[o]=r(o);return t.slice().sort((o,i)=>s[o]<=s[i]?-1:1)}clear(){this.nodes.clear(),this.edges.clear()}getNodeById(t){if(typeof t!="string")throw new TypeError(d("nodeId"));const e=this.nodes.get(t);if(e instanceof h)return e;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(d("edgeId"));const e=this.edges.get(t);if(e instanceof f)return e;throw new Error(`DflowEdge not found, id=${t}`)}async run(){this.runStatusIsSuccess&&(this.#t="waiting");const t=p.sort([...this.nodes.keys()],[...this.edges.values()].map(e=>({sourceId:e.source[0],targetId:e.target[0]})));for(const e of t){const s=this.nodes.get(e);try{s.isAsync?await s.run():s.run()}catch(n){console.error(n),this.#t="failure"}}this.runStatusIsWaiting&&(this.#t="success")}get runStatusIsSuccess(){return this.#t==="success"}get runStatusIsWaiting(){return this.#t==="waiting"}get runStatusIsFailure(){return this.#t==="failure"}toJSON(){return JSON.stringify(this.toObject())}toObject(){const t=Object.values(this.nodes).map(s=>s.toObject()),e=Object.values(this.edges).map(s=>s.toObject());return{nodes:t,edges:e}}}class y{graph=new p;#t;constructor(t={}){this.#t=t}deleteEdge(t){if(typeof t!="string")throw new TypeError(d("edgeId"));const e=this.graph.getEdgeById(t);if(e instanceof f){const[s,n]=e.target;this.graph.getNodeById(s).getInputById(n).disconnect(),this.graph.edges.delete(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(d("nodeId"));const e=this.graph.getNodeById(t);if(e instanceof h){for(const s of this.graph.edges.values()){const{source:[n],target:[r]}=s;(n===e.id||r===e.id)&&this.deleteEdge(s.id)}this.graph.nodes.delete(t)}else throw new Error(`DflowNode not found, id=${t}`)}newNode(t){const e=this.#t[t.kind]??g,s=new e(t);if(this.graph.nodes.has(s.id))throw new Error(`Cannot overwrite DflowNode, id=${s.id}`);return this.graph.nodes.set(s.id,s),s}newEdge(t){const e=new f(t);if(this.graph.edges.has(e.id))throw new Error(`Cannot overwrite DflowEdge, id=${e.id}`);this.graph.edges.set(e.id,e);const[s,n]=e.source,[r,o]=e.target,i=this.graph.getNodeById(s),c=this.graph.getNodeById(r),l=i.getOutputById(n);return c.getInputById(o).connectTo(l),e}newInput(t,e){this.graph.nodes.get(t)?.newInput(e)}newOutput(t,e){this.graph.nodes.get(t)?.newOutput(e)}}export{a as DflowPin};export{h as DflowNode};export{g as DflowUnknownNode};export{f as DflowEdge};export{p as DflowGraph};export{y as DflowHost};
