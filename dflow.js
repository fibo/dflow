var Ot=Object.defineProperty,bt=Object.defineProperties;var Tt=Object.getOwnPropertyDescriptors;var Z=Object.getOwnPropertySymbols;var ht=Object.prototype.hasOwnProperty,pt=Object.prototype.propertyIsEnumerable;var ot=(i,t,e)=>t in i?Ot(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e,y=(i,t)=>{for(var e in t||(t={}))ht.call(t,e)&&ot(i,e,t[e]);if(Z)for(var e of Z(t))pt.call(t,e)&&ot(i,e,t[e]);return i},b=(i,t)=>bt(i,Tt(t));var N=(i,t)=>{var e={};for(var s in i)ht.call(i,s)&&t.indexOf(s)<0&&(e[s]=i[s]);if(i!=null&&Z)for(var s of Z(i))t.indexOf(s)<0&&pt.call(i,s)&&(e[s]=i[s]);return e};var o=(i,t,e)=>(ot(i,typeof t!="symbol"?t+"":t,e),e),ut=(i,t,e)=>{if(!t.has(i))throw TypeError("Cannot "+e)};var n=(i,t,e)=>(ut(i,t,"read from private field"),e?e.call(i):t.get(i)),g=(i,t,e)=>{if(t.has(i))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(i):t.set(i,e)},x=(i,t,e,s)=>(ut(i,t,"write to private field"),s?s.call(i,e):t.set(i,e),e);var M=(i,t,e)=>(ut(i,t,"access private method"),e);var G,q,A,P,v,R,U,Q,X,It,Y,wt,w,m,h;const T=i=>`${i} must be a string`,lt=i=>`${i} must be a number`,ft=(i,t)=>`${t} pin not found nodeId=${i}`,yt=(i,t,e)=>`${ft(i,t)} position=${e}`,gt=(i,t,e)=>`${ft(i,t)} pinId=${e}`,dt=({id:i,kind:t,outputs:e})=>({id:i,kind:t,outputs:e==null?void 0:e.map(({id:s,data:r,name:a})=>({id:s,data:r,name:a}))});class d{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowGraph(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&Array.isArray(t.nodes)&&Array.isArray(t.edges)&&C.isDflowGraph(t)}static isDflowId(t){return d.isStringNotEmpty(t)}static isDflowType(t){return typeof t=="string"&&B.types.includes(t)}static isObject(t){return!d.isUndefined(t)&&!d.isNull(t)&&!d.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return d.isString(t)&&t.length>0}static isUndefined(t){return typeof t>"u"}static validate(t,e){return e.length===0?!0:e.some(s=>{switch(s){case"array":return d.isArray(t);case"boolean":return d.isBoolean(t);case"null":return d.isNull(t);case"number":return d.isNumber(t);case"object":return d.isObject(t);case"string":return d.isString(t);case"DflowGraph":return d.isDflowGraph(t);case"DflowId":return d.isDflowId(t);case"DflowType":return d.isDflowType(t);default:return!1}},!0)}}class S{constructor({id:t,name:e}){o(this,"id");o(this,"name");this.id=t,this.name=e}static isDflowItem({id:t,name:e}){return d.isDflowId(t)&&(d.isUndefined(e)||d.isStringNotEmpty(e))}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const nt=class extends S{constructor(t,r){var a=r,{types:e=[]}=a,s=N(a,["types"]);super(s);o(this,"kind");o(this,"types");this.kind=t,this.types=e}static isDflowPin(s){var r=s,{types:t=[]}=r,e=N(r,["types"]);return S.isDflowItem(e)&&t.every(a=>nt.isDflowPinType(a))}static isDflowPinType(t){nt.types.includes(t)}get hasTypeAny(){return this.types.length===0}get hasTypeDflowId(){return this.hasTypeAny||this.types.includes("DflowId")}get hasTypeDflowGraph(){return this.hasTypeAny||this.types.includes("DflowGraph")}get hasTypeDflowType(){return this.hasTypeAny||this.types.includes("DflowType")}get hasTypeString(){return this.hasTypeAny||this.types.includes("string")}get hasTypeNumber(){return this.hasTypeAny||this.types.includes("number")}get hasTypeBoolean(){return this.hasTypeAny||this.types.includes("boolean")}get hasTypeNull(){return this.hasTypeAny||this.types.includes("null")}get hasTypeObject(){return this.hasTypeAny||this.types.includes("object")}get hasTypeArray(){return this.hasTypeAny||this.types.includes("array")}addType(t){this.types.push(t)}removeType(t){this.types.splice(this.types.indexOf(t),1)}};let B=nt;o(B,"types",["string","number","boolean","null","object","array","DflowId","DflowGraph","DflowType"]);class _ extends B{constructor(s){var r=s,{optional:t}=r,e=N(r,["optional"]);super("input",e);g(this,G,void 0);g(this,q,void 0);x(this,q,t)}static isDflowInput({id:t,types:e}){return B.isDflowPin({id:t,types:e})}get data(){var t;return(t=n(this,G))==null?void 0:t.data}get isConnected(){return typeof n(this,G)>"u"}get isOptional(){return n(this,q)}connectTo(t){const{hasTypeAny:e,types:s}=this,{types:r}=t;if(e||s.some(a=>r.includes(a)))x(this,G,t);else throw new Error(`mismatching pinTypes, source has types [${r.join()}] and target has types [${s.join()}]`)}disconnect(){x(this,G,void 0)}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}G=new WeakMap,q=new WeakMap;class tt extends B{constructor(s){var r=s,{data:t}=r,e=N(r,["data"]);super("output",e);g(this,A,void 0);x(this,A,t)}static isDflowOutput({id:t,data:e,types:s=[]}){return B.isDflowPin({id:t,types:s})&&d.validate(e,s)}clear(){x(this,A,void 0)}get data(){return n(this,A)}set data(t){switch(!0){case d.isUndefined(t):this.clear();break;case this.hasTypeAny:case(d.isDflowGraph(t)&&this.hasTypeDflowGraph):case(d.isDflowId(t)&&this.hasTypeDflowId):case(d.isString(t)&&this.hasTypeString):case(d.isNumber(t)&&this.hasTypeNumber):case(d.isBoolean(t)&&this.hasTypeBoolean):case(d.isNull(t)&&this.hasTypeNull):case(d.isObject(t)&&this.hasTypeObject):case(d.isArray(t)&&this.hasTypeArray):{x(this,A,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=y({},super.toObject());return d.isUndefined(n(this,A))||(t.data=n(this,A)),this.types.length>0&&(t.types=this.types),t}}A=new WeakMap;const it=class extends S{constructor(f,a,{isAsync:p=!1,isConstant:c=!1,label:l}={}){var E=f,{kind:t,inputs:e=[],outputs:s=[]}=E,r=N(E,["kind","inputs","outputs"]);super(r);g(this,X);g(this,Y);g(this,P,new Map);g(this,v,new Map);g(this,R,[]);g(this,U,[]);g(this,Q,void 0);o(this,"kind");o(this,"meta");o(this,"host");x(this,Q,l),this.host=a,this.kind=t,this.meta={isAsync:p,isConstant:c};for(const O of e)this.newInput(O);for(const O of s)this.newOutput(O);this.onCreate()}static generateInputIds(t=[]){return t.map((e,s)=>b(y({},e),{id:`i${s}`}))}static generateOutputIds(t=[]){return t.map((e,s)=>b(y({},e),{id:`o${s}`}))}static in(t=[],e){return[y({types:t},e)]}static ins(t,e=[]){return Array(t).fill(it.in(e)).flat()}static out(t=[],e){return[y({types:t},e)]}static outs(t,e=[]){return Array(t).fill(it.out(e)).flat()}static outputNumber(t){return b(y({},t),{types:["number"]})}static isDflowNode(a){var p=a,{kind:t,inputs:e=[],outputs:s=[]}=p,r=N(p,["kind","inputs","outputs"]);return S.isDflowItem(r)&&d.isStringNotEmpty(t)&&e.every(c=>_.isDflowInput(c))&&s.every(c=>tt.isDflowOutput(c))}get label(){return n(this,Q)||this.kind}get inputs(){return n(this,P).values()}get outputs(){return n(this,v).values()}get numInputs(){return n(this,P).size}get numOutputs(){return n(this,v).size}clearOutputs(){for(const t of this.outputs)t.clear()}getInputById(t){if(typeof t!="string")throw new TypeError(T("inputId"));const e=n(this,P).get(t);if(e instanceof _)return e;throw new Error(gt(this.id,"input",t))}input(t){if(typeof t!="number")throw new TypeError(lt("position"));const e=n(this,R)[t];if(d.isUndefined(e))throw new Error(yt(this.id,"input",t));return this.getInputById(e)}getOutputById(t){if(typeof t!="string")throw new TypeError(T("outputId"));const e=n(this,v).get(t);if(e instanceof tt)return e;throw new Error(gt(this.id,"output",t))}output(t){if(typeof t!="number")throw new TypeError(lt("position"));const e=n(this,U)[t];if(d.isUndefined(e))throw new Error(yt(this.id,"output",t));return this.getOutputById(e)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),n(this,P).delete(t),n(this,R).splice(n(this,R).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),n(this,v).delete(t),n(this,U).splice(n(this,U).indexOf(t),1)}onCreate(){}newInput(t){const e=d.isDflowId(t.id)?t.id:M(this,X,It).call(this),s=new _(b(y({},t),{id:e}));return n(this,P).set(e,s),n(this,R).push(e),s}newOutput(t){const e=d.isDflowId(t.id)?t.id:M(this,Y,wt).call(this),s=new tt(b(y({},t),{id:e}));return n(this,v).set(e,s),n(this,U).push(e),s}run(){}toObject(){const t=b(y({},super.toObject()),{kind:this.kind}),e=[],s=[];for(const r of this.inputs)e.push(r.toObject());e.length>0&&(t.inputs=e);for(const r of this.outputs)s.push(r.toObject());return s.length>0&&(t.outputs=s),t}};let u=it;P=new WeakMap,v=new WeakMap,R=new WeakMap,U=new WeakMap,Q=new WeakMap,X=new WeakSet,It=function(t=this.numInputs){const e=`i${t}`;return n(this,P).has(e)?M(this,X,It).call(this,t+1):e},Y=new WeakSet,wt=function(t=this.numOutputs){const e=`o${t}`;return n(this,v).has(e)?M(this,Y,wt).call(this,t+1):e},o(u,"kind"),o(u,"isAsync"),o(u,"isConstant"),o(u,"label"),o(u,"inputs"),o(u,"outputs");const at=class extends u{constructor(t,e){super(b(y({},t),{kind:at.kind}),e)}run(){}};let et=at;o(et,"kind","Unknown");class z extends S{constructor(r){var a=r,{source:t,target:e}=a,s=N(a,["source","target"]);super(s);o(this,"source");o(this,"target");const[p,c]=t,[l,f]=e;if(typeof p!="string")throw new TypeError(T("sourceNodeId"));if(typeof c!="string")throw new TypeError(T("sourcePinId"));if(typeof l!="string")throw new TypeError(T("targetNodeId"));if(typeof f!="string")throw new TypeError(T("targetPinId"));this.source=t,this.target=e}static isDflowEdge(a,r){var p=a,{source:t,target:e}=p,s=N(p,["source","target"]);return S.isDflowItem(s)&&Array.isArray(t)&&t.length===2&&r.nodes.find(({id:c,outputs:l=[]})=>c===t[0]&&l.find(({id:f})=>f===t[1]))&&Array.isArray(e)&&e.length===2&&r.nodes.find(({id:c,inputs:l=[]})=>c===e[0]&&l.find(({id:f})=>f===e[1]))}toObject(){return b(y({},super.toObject()),{source:this.source,target:this.target})}}const k=class extends S{constructor(){super(...arguments);g(this,w,new Map);g(this,m,new Map);o(this,"runOptions",{verbose:!1});o(this,"runStatus",null);o(this,"executionReport",null)}static isDflowGraph(t){return t.nodes.every(e=>u.isDflowNode(e))&&t.edges.every(e=>z.isDflowEdge(e,t))}static childrenOfNodeId(t,e){return e.filter(({sourceId:s})=>t===s).map(({targetId:s})=>s)}static parentsOfNodeId(t,e){return e.filter(({targetId:s})=>t===s).map(({sourceId:s})=>s)}static levelOfNodeId(t,e){const s=k.parentsOfNodeId(t,e);if(s.length===0)return 0;let r=0;for(const a of s){const p=k.levelOfNodeId(a,e);r=Math.max(p,r)}return r+1}static ancestorsOfNodeId(t,e){const s=k.parentsOfNodeId(t,e);return s.length===0?[]:s.reduce((r,a,p,c)=>{const l=k.ancestorsOfNodeId(a,e),f=r.concat(l);return p===c.length-1?Array.from(new Set(c.concat(f))):f},[])}static sort(t,e){const s={};for(const r of t)s[r]=k.levelOfNodeId(r,e);return t.slice().sort((r,a)=>s[r]<=s[a]?-1:1)}get edges(){return n(this,m).values()}get nodes(){return n(this,w).values()}get nodeConnections(){return[...n(this,m).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...n(this,m).keys()]}get nodeIds(){return[...n(this,w).keys()]}get numEdges(){return n(this,m).size}get numNodes(){return n(this,w).size}addEdge(t){if(n(this,m).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);n(this,m).set(t.id,t)}addNode(t){if(n(this,w).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);n(this,w).set(t.id,t)}clear(){n(this,w).clear(),n(this,m).clear()}deleteEdge(t){n(this,m).delete(t)}deleteNode(t){n(this,w).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(T("nodeId"));const e=n(this,w).get(t);if(e instanceof u)return e;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(T("edgeId"));const e=n(this,m).get(t);if(e instanceof z)return e;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const e=`e${t}`;return n(this,m).has(e)?this.generateEdgeId(t+1):e}generateNodeId(t=this.numNodes){const e=`n${t}`;return n(this,w).has(e)?this.generateNodeId(t+1):e}nodeIdsInsideFunctions(){const t=[];for(const e of this.nodes)e.kind==="return"&&t.push(k.ancestorsOfNodeId(e.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){var r,a;const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const e=this.nodeIdsInsideFunctions(),s=k.sort(this.nodeIds.filter(p=>!e.includes(p)),this.nodeConnections);e:for(const p of s){const c=n(this,w).get(p);try{if(!c.meta.isConstant){let l=!1;t:for(const{data:f,types:E,isOptional:O}of c.inputs){if(O&&typeof f>"u")continue t;if(!d.validate(f,E)){l=!0;break t}}if(l){for(const f of c.outputs)f.clear();t&&((r=this.executionReport.steps)==null||r.push(dt(c.toObject())));continue e}c.meta.isAsync?await c.run():c.run()}t&&((a=this.executionReport.steps)==null||a.push(dt(c.toObject())))}catch(l){console.error(l),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=b(y({},super.toObject()),{nodes:[],edges:[]});for(const e of this.nodes)t.nodes.push(e.toObject());for(const e of this.edges)t.edges.push(e.toObject());return t}};let C=k;w=new WeakMap,m=new WeakMap;class $ extends u{}o($,"kind","argument"),o($,"isConstant",!0),o($,"inputs",u.in(["number"],{name:"position",optional:!0})),o($,"outputs",u.out());class K extends u{run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t:this.output(0).clear()}}o(K,"kind","array"),o(K,"inputs",u.in()),o(K,"outputs",u.out(["array"]));class F extends u{run(){const t=this.input(0).data;typeof t=="boolean"?this.output(0).data=t:this.output(0).clear()}}o(F,"kind","boolean"),o(F,"inputs",u.in()),o(F,"outputs",u.out(["boolean"]));class H extends u{}o(H,"kind","data"),o(H,"isConstant",!0),o(H,"outputs",u.out());class st extends u{run(){const t=this.output(0);t.data=this.host.nodeKinds}}o(st,"kind","dflow"),o(st,"outputs",u.out(["array"],{name:"nodeKinds"}));class J extends u{onCreate(){this.output(0).data=this.id}}o(J,"kind","function"),o(J,"isConstant",!0),o(J,"outputs",u.out(["DflowId"],{name:"id"}));class L extends u{run(){const t=this.input(0).data;typeof t=="number"?this.output(0).data=t:this.output(0).clear()}}o(L,"kind","number"),o(L,"inputs",u.in()),o(L,"outputs",u.out(["number"]));class V extends u{run(){const t=this.input(0).data;typeof t=="object"&&t!==null?this.output(0).data=t:this.output(0).clear()}}o(V,"kind","object"),o(V,"inputs",u.in()),o(V,"outputs",u.out(["object"]));class D extends u{}o(D,"kind","return"),o(D,"isConstant",!0),o(D,"inputs",[...u.in(["DflowId"],{name:"functionId"}),...u.in([],{name:"value"})]);class W extends u{run(){const t=this.input(0).data;typeof t=="string"?this.output(0).data=t:this.output(0).clear()}}o(W,"kind","string"),o(W,"inputs",u.in()),o(W,"outputs",u.out(["string"]));const Et={[$.kind]:$,[K.kind]:K,[F.kind]:F,[H.kind]:H,[st.kind]:st,[L.kind]:L,[V.kind]:V,[J.kind]:J,[W.kind]:W,[D.kind]:D};class Nt{constructor(t={}){g(this,h,void 0);o(this,"nodesCatalog");o(this,"context");this.nodesCatalog=y(y({},t),Et),x(this,h,new C({id:"g1"})),this.context={}}get executionReport(){return n(this,h).executionReport}get edges(){return n(this,h).edges}get nodes(){return n(this,h).nodes}get numEdges(){return n(this,h).numEdges}get numNodes(){return n(this,h).numNodes}get nodeKinds(){return Object.keys(this.nodesCatalog)}get runStatusIsSuccess(){return n(this,h).runStatus==="success"}get runStatusIsWaiting(){return n(this,h).runStatus==="waiting"}get runStatusIsFailure(){return n(this,h).runStatus==="failure"}set verbose(t){n(this,h).runOptions.verbose=t}clearGraph(){n(this,h).clear()}connect(t,e=0){return{to:(s,r=0)=>{const a=n(this,h).generateEdgeId(),p=t.output(e),c=s.input(r);this.newEdge({id:a,source:[t.id,p.id],target:[s.id,c.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(T("edgeId"));const e=n(this,h).getEdgeById(t);if(e instanceof z){const[s,r]=e.target;this.getNodeById(s).getInputById(r).disconnect(),n(this,h).deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(T("nodeId"));const e=this.getNodeById(t);if(e instanceof u){for(const s of n(this,h).edges){const{source:[r],target:[a]}=s;(r===e.id||a===e.id)&&this.deleteEdge(s.id)}n(this,h).deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,e]){for(const s of this.edges){const[r,a]=s.source,[p,c]=s.target;(r===t&&a===e||p===t&&c===e)&&this.deleteEdge(s.id)}}executeFunction(t,e){var f,E;const{verbose:s}=n(this,h).runOptions,r=n(this,h).nodeConnections,a=C.childrenOfNodeId(t,r),p=[];for(const O of a){const I=this.getNodeById(O);I.kind===D.kind&&p.push(I.id)}const c=p.reduce((O,I,j,rt)=>{const mt=C.ancestorsOfNodeId(I,r),ct=O.concat(mt);return j===rt.length?Array.from(new Set(ct)):ct},[]),l=C.sort([...p,...c],r);for(const O of l){const I=this.getNodeById(O);try{switch(I.kind){case $.kind:{const j=I.input(0).data,rt=typeof j=="number"&&!isNaN(j)?Math.max(j,0):0;I.output(0).data=e[rt];break}case D.kind:return I.input(1).data;default:!I.meta.isConstant&&!I.meta.isAsync&&I.run(),s&&((E=(f=this.executionReport)==null?void 0:f.steps)==null||E.push(dt(I.toObject())))}}catch(j){console.error(j)}}}getEdgeById(t){return n(this,h).getEdgeById(t)}getNodeById(t){return n(this,h).getNodeById(t)}newNode(t){var l;const e=(l=this.nodesCatalog[t.kind])!=null?l:et,s=d.isDflowId(t.id)?t.id:n(this,h).generateNodeId(),r={isAsync:e.isAsync,isConstant:e.isConstant,label:e.label},a=Array.isArray(t.inputs)?t.inputs:u.generateInputIds(e.inputs),p=Array.isArray(t.outputs)?t.outputs:u.generateOutputIds(e.outputs),c=new e(b(y({},t),{id:s,inputs:a,outputs:p}),this,r);return n(this,h).addNode(c),c}newEdge(t){const e=d.isDflowId(t.id)?t.id:n(this,h).generateEdgeId(),s=new z(b(y({},t),{id:e}));n(this,h).addEdge(s);const[r,a]=s.source,[p,c]=s.target,l=n(this,h).getNodeById(r),f=n(this,h).getNodeById(p),E=l.getOutputById(a);return f.getInputById(c).connectTo(E),s}newInput(t,e){return n(this,h).getNodeById(t).newInput(e)}newOutput(t,e){return n(this,h).getNodeById(t).newOutput(e)}toObject(){return n(this,h).toObject()}async run(){await n(this,h).run()}}h=new WeakMap;export{d as DflowData};export{S as DflowItem};export{B as DflowPin};export{_ as DflowInput};export{tt as DflowOutput};export{u as DflowNode};export{et as DflowUnknownNode};export{z as DflowEdge};export{C as DflowGraph};export{Nt as DflowHost};
