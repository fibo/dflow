var xt=Object.defineProperty,kt=Object.defineProperties;var Tt=Object.getOwnPropertyDescriptors;var H=Object.getOwnPropertySymbols;var lt=Object.prototype.hasOwnProperty,ft=Object.prototype.propertyIsEnumerable;var ot=(i,t,e)=>t in i?xt(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e,g=(i,t)=>{for(var e in t||(t={}))lt.call(t,e)&&ot(i,e,t[e]);if(H)for(var e of H(t))ft.call(t,e)&&ot(i,e,t[e]);return i},E=(i,t)=>kt(i,Tt(t));var x=(i,t)=>{var e={};for(var s in i)lt.call(i,s)&&t.indexOf(s)<0&&(e[s]=i[s]);if(i!=null&&H)for(var s of H(i))t.indexOf(s)<0&&ft.call(i,s)&&(e[s]=i[s]);return e};var o=(i,t,e)=>(ot(i,typeof t!="symbol"?t+"":t,e),e),ut=(i,t,e)=>{if(!t.has(i))throw TypeError("Cannot "+e)};var n=(i,t,e)=>(ut(i,t,"read from private field"),e?e.call(i):t.get(i)),w=(i,t,e)=>{if(t.has(i))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(i):t.set(i,e)},A=(i,t,e,s)=>(ut(i,t,"write to private field"),s?s.call(i,e):t.set(i,e),e);var C=(i,t,e)=>(ut(i,t,"access private method"),e);var $,X,T,P,j,U,z,Y,wt,Z,mt,m,O,p,st,jt,nt,vt;const N=i=>`${i} must be a string`,gt=(i,t)=>`${t} pin not found nodeId=${i}`,yt=(i,t,e)=>`${gt(i,t)} position=${e}`,It=(i,t,e)=>`${gt(i,t)} pinId=${e}`,dt=({id:i,kind:t,outputs:e},s)=>{const r={id:i,kind:t,outputs:e==null?void 0:e.map(({id:c,data:h,name:d})=>({id:c,data:h,name:d}))};return s&&(r.error=s),r};class u{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowId(t){return u.isStringNotEmpty(t)}static isObject(t){return!u.isUndefined(t)&&!u.isNull(t)&&!u.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"&&!isNaN(t)}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return u.isString(t)&&t.length>0}static isUndefined(t){return typeof t>"u"}static validate(t,e){return e.length===0?!0:e.some(s=>{switch(s){case"array":return u.isArray(t);case"boolean":return u.isBoolean(t);case"null":return u.isNull(t);case"number":return u.isNumber(t);case"object":return u.isObject(t);case"string":return u.isString(t);case"DflowId":return u.isDflowId(t);default:return!1}},!0)}}class S{constructor({id:t,name:e}){o(this,"id");o(this,"name");this.id=t,this.name=e}static isDflowItem({id:t,name:e}){return u.isDflowId(t)&&(u.isUndefined(e)||u.isStringNotEmpty(e))}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const Q=class extends S{constructor(t,r){var c=r,{types:e=[]}=c,s=x(c,["types"]);super(s);o(this,"kind");o(this,"types");this.kind=t,this.types=e}static isDflowPin(s){var r=s,{types:t=[]}=r,e=x(r,["types"]);return S.isDflowItem(e)&&Q.isDflowPinTypes(t)}static isDflowPinType(t){return typeof t!="string"?!1:Q.types.includes(t)}static isDflowPinTypes(t){return Array.isArray(t)?t.every(e=>Q.isDflowPinType(e)):!1}get hasTypeAny(){return this.types.length===0}hasType(t){return this.hasTypeAny||this.types.includes(t)}toObject(){const t=super.toObject();return this.types.length>0&&(t.types=this.types),t}};let b=Q;o(b,"types",["string","number","boolean","null","object","array","DflowId"]);class ct extends b{constructor(s){var r=s,{optional:t}=r,e=x(r,["optional"]);super("input",e);w(this,$,void 0);w(this,X,void 0);A(this,X,t)}static isDflowInput({id:t,types:e}){return b.isDflowPin({id:t,types:e})}get data(){var t,e;return console.log("get data",this.toObject()),console.log("source",(t=n(this,$))==null?void 0:t.toObject()),(e=n(this,$))==null?void 0:e.data}get isConnected(){return typeof n(this,$)>"u"}get isOptional(){return n(this,X)}connectTo(t){const{hasTypeAny:e,types:s}=this,{types:r}=t;if(e||s.some(c=>r.includes(c)))A(this,$,t);else throw new Error(`mismatching pinTypes, source has types [${r.join()}] and target has types [${s.join()}]`)}disconnect(){A(this,$,void 0)}toObject(){return super.toObject()}}$=new WeakMap,X=new WeakMap;class at extends b{constructor(s){var r=s,{data:t}=r,e=x(r,["data"]);super("output",e);w(this,T,void 0);A(this,T,t)}static isDflowOutput({id:t,data:e,types:s=[]}){return b.isDflowPin({id:t,types:s})&&u.validate(e,s)}clear(){A(this,T,void 0)}get data(){return n(this,T)}set data(t){switch(!0){case u.isUndefined(t):this.clear();break;case this.hasTypeAny:case(u.isDflowId(t)&&this.hasType("DflowId")):case(u.isString(t)&&this.hasType("string")):case(u.isNumber(t)&&this.hasType("number")):case(u.isBoolean(t)&&this.hasType("boolean")):case(u.isNull(t)&&this.hasType("null")):case(u.isObject(t)&&this.hasType("object")):case(u.isArray(t)&&this.hasType("array")):{A(this,T,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=super.toObject();return typeof n(this,T)<"u"&&(t.data=n(this,T)),t}}T=new WeakMap;class a extends S{constructor(f,c,{isAsync:h=!1,isConstant:d=!1}={}){var l=f,{kind:t,inputs:e=[],outputs:s=[]}=l,r=x(l,["kind","inputs","outputs"]);super(r);w(this,Y);w(this,Z);w(this,P,new Map);w(this,j,new Map);w(this,U,[]);w(this,z,[]);o(this,"kind");o(this,"meta");o(this,"host");this.host=c,this.kind=t,this.meta={isAsync:h,isConstant:d};for(const y of e)this.newInput(y);for(const y of s)this.newOutput(y)}static input(t=[],e){if(b.isDflowPinType(t))return g({types:[t]},e);if(b.isDflowPinTypes(t))return g({types:t},e);throw new TypeError("invalid input definition")}static output(t=[],e){if(b.isDflowPinType(t))return g({types:[t]},e);if(b.isDflowPinTypes(t))return g({types:t},e);throw new TypeError("invalid output definition")}static in(t=[],e){return[g({types:t},e)]}static out(t=[],e){return[g({types:t},e)]}static isDflowNode(c){var h=c,{kind:t,inputs:e=[],outputs:s=[]}=h,r=x(h,["kind","inputs","outputs"]);return S.isDflowItem(r)&&u.isStringNotEmpty(t)&&e.every(d=>ct.isDflowInput(d))&&s.every(d=>at.isDflowOutput(d))}get inputs(){return n(this,P).values()}get outputs(){return n(this,j).values()}get numInputs(){return n(this,P).size}get numOutputs(){return n(this,j).size}clearOutputs(){for(const t of this.outputs)t.clear()}getInputById(t){if(typeof t!="string")throw new TypeError(N("inputId"));const e=n(this,P).get(t);if(e)return e;throw new Error(It(this.id,"input",t))}input(t){const e=n(this,U)[t];if(!e)throw new Error(yt(this.id,"input",t));return this.getInputById(e)}getOutputById(t){if(typeof t!="string")throw new TypeError(N("outputId"));const e=n(this,j).get(t);if(e)return e;throw new Error(It(this.id,"output",t))}output(t){const e=n(this,z)[t];if(!e)throw new Error(yt(this.id,"output",t));return this.getOutputById(e)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),n(this,P).delete(t),n(this,U).splice(n(this,U).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),n(this,j).delete(t),n(this,z).splice(n(this,z).indexOf(t),1)}newInput(t){const e=u.isDflowId(t.id)?t.id:C(this,Y,wt).call(this),s=new ct(E(g({},t),{id:e}));return n(this,P).set(e,s),n(this,U).push(e),s}newOutput(t){const e=u.isDflowId(t.id)?t.id:C(this,Z,mt).call(this),s=new at(E(g({},t),{id:e}));return n(this,j).set(e,s),n(this,z).push(e),s}run(){}toObject(){const t=E(g({},super.toObject()),{kind:this.kind}),e=[],s=[];for(const r of this.inputs)e.push(r.toObject());e.length>0&&(t.inputs=e);for(const r of this.outputs)s.push(r.toObject());return s.length>0&&(t.outputs=s),t}}P=new WeakMap,j=new WeakMap,U=new WeakMap,z=new WeakMap,Y=new WeakSet,wt=function(t=this.numInputs){const e=`i${t}`;return n(this,P).has(e)?C(this,Y,wt).call(this,t+1):e},Z=new WeakSet,mt=function(t=this.numOutputs){const e=`o${t}`;return n(this,j).has(e)?C(this,Z,mt).call(this,t+1):e},o(a,"kind"),o(a,"isAsync"),o(a,"isConstant"),o(a,"inputs"),o(a,"outputs");const ht=class extends a{constructor(t,e){super(E(g({},t),{kind:ht.kind}),e)}run(){}};let _=ht;o(_,"kind","Unknown");class Ot extends S{constructor(r){var c=r,{source:t,target:e}=c,s=x(c,["source","target"]);super(s);o(this,"source");o(this,"target");const[h,d]=t,[f,l]=e;if(typeof h!="string")throw new TypeError(N("sourceNodeId"));if(typeof d!="string")throw new TypeError(N("sourcePinId"));if(typeof f!="string")throw new TypeError(N("targetNodeId"));if(typeof l!="string")throw new TypeError(N("targetPinId"));this.source=t,this.target=e}static isDflowEdge(c,r){var h=c,{source:t,target:e}=h,s=x(h,["source","target"]);return S.isDflowItem(s)&&Array.isArray(t)&&t.length===2&&r.nodes.find(({id:d,outputs:f=[]})=>d===t[0]&&f.find(({id:l})=>l===t[1]))&&Array.isArray(e)&&e.length===2&&r.nodes.find(({id:d,inputs:f=[]})=>d===e[0]&&f.find(({id:l})=>l===e[1]))}toObject(){return E(g({},super.toObject()),{source:this.source,target:this.target})}}const k=class extends S{constructor(){super(...arguments);w(this,m,new Map);w(this,O,new Map);o(this,"runOptions",{verbose:!1});o(this,"runStatus",null);o(this,"executionReport",null)}static childrenOfNodeId(t,e){return e.filter(({sourceId:s})=>t===s).map(({targetId:s})=>s)}static parentsOfNodeId(t,e){return e.filter(({targetId:s})=>t===s).map(({sourceId:s})=>s)}static levelOfNodeId(t,e){const s=k.parentsOfNodeId(t,e);if(s.length===0)return 0;let r=0;for(const c of s){const h=k.levelOfNodeId(c,e);r=Math.max(h,r)}return r+1}static ancestorsOfNodeId(t,e){const s=k.parentsOfNodeId(t,e);return s.length===0?[]:s.reduce((r,c,h,d)=>{const f=k.ancestorsOfNodeId(c,e),l=r.concat(f);return h===d.length-1?Array.from(new Set(d.concat(l))):l},[])}static sort(t,e){const s={};for(const r of t)s[r]=k.levelOfNodeId(r,e);return t.slice().sort((r,c)=>s[r]<=s[c]?-1:1)}get edges(){return n(this,O).values()}get nodes(){return n(this,m).values()}get nodeConnections(){return[...n(this,O).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...n(this,O).keys()]}get nodeIds(){return[...n(this,m).keys()]}get numEdges(){return n(this,O).size}get numNodes(){return n(this,m).size}addEdge(t){if(n(this,O).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);n(this,O).set(t.id,t)}addNode(t){if(n(this,m).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);n(this,m).set(t.id,t)}clear(){n(this,m).clear(),n(this,O).clear()}deleteEdge(t){n(this,O).delete(t)}deleteNode(t){n(this,m).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(N("nodeId"));const e=n(this,m).get(t);if(e)return e;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(N("edgeId"));const e=n(this,O).get(t);if(e)return e;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const e=`e${t}`;return n(this,O).has(e)?this.generateEdgeId(t+1):e}generateNodeId(t=this.numNodes){const e=`n${t}`;return n(this,m).has(e)?this.generateNodeId(t+1):e}nodeIdsInsideFunctions(){const t=[];for(const e of this.nodes)e.kind==="return"&&t.push(k.ancestorsOfNodeId(e.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){var r,c;const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const e=this.nodeIdsInsideFunctions(),s=k.sort(this.nodeIds.filter(h=>!e.includes(h)),this.nodeConnections);e:for(const h of s){const d=n(this,m).get(h);try{if(!d.meta.isConstant){let f=!1;t:for(const{id:l,data:y,types:v,isOptional:I}of d.inputs){if(I&&typeof y>"u")continue t;if(!u.validate(y,v)){f=!0,t&&((r=this.executionReport.steps)==null||r.push(dt(d.toObject(),`invalid input data nodeId=${h} inputId=${l} data=${y}`)));break t}}if(f){for(const l of d.outputs)l.clear();continue e}d.meta.isAsync?await d.run():d.run()}t&&((c=this.executionReport.steps)==null||c.push(dt(d.toObject())))}catch(f){console.error(f),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=E(g({},super.toObject()),{nodes:[],edges:[]});for(const e of this.nodes)t.nodes.push(e.toObject());for(const e of this.edges)t.edges.push(e.toObject());return t}};let K=k;m=new WeakMap,O=new WeakMap;const{input:Et,output:bt}=a;class R extends a{}o(R,"kind","argument"),o(R,"isConstant",!0),o(R,"inputs",[Et("number",{name:"position",optional:!0})]),o(R,"outputs",[bt()]);class F extends a{run(){const t=this.input(0).data;u.isArray(t)?this.output(0).data=t:this.output(0).clear()}}o(F,"kind","array"),o(F,"inputs",a.in()),o(F,"outputs",a.out(["array"]));class G extends a{run(){const t=this.input(0).data;u.isBoolean(t)?this.output(0).data=t:this.output(0).clear()}}o(G,"kind","boolean"),o(G,"inputs",[Et()]),o(G,"outputs",[bt("boolean")]);class D extends a{}o(D,"kind","data"),o(D,"isConstant",!0),o(D,"outputs",a.out());class J extends a{constructor(...t){super(...t);this.output(0).data=this.id}}o(J,"kind","function"),o(J,"isConstant",!0),o(J,"outputs",a.out(["DflowId"],{name:"id"}));class tt extends a{run(){const t=this.output(0);t.data=this.host.nodeKinds}}o(tt,"kind","dflow"),o(tt,"outputs",a.out(["array"],{name:"nodeKinds"}));class L extends a{run(){this.output(0).data=u.isUndefined(this.input(0).data)}}o(L,"kind","isUndefined"),o(L,"inputs",a.in()),o(L,"outputs",a.out(["boolean"]));class V extends a{run(){const t=this.input(0).data;u.isNumber(t)?this.output(0).data=t:this.output(0).clear()}}o(V,"kind","number"),o(V,"inputs",a.in()),o(V,"outputs",a.out(["number"]));class W extends a{run(){const t=this.input(0).data;u.isObject(t)?this.output(0).data=t:this.output(0).clear()}}o(W,"kind","object"),o(W,"inputs",a.in()),o(W,"outputs",a.out(["object"]));class M extends a{}o(M,"kind","return"),o(M,"isConstant",!0),o(M,"inputs",[...a.in(["DflowId"],{name:"functionId"}),...a.in([],{name:"value"})]);class q extends a{run(){const t=this.input(0).data;u.isString(t)?this.output(0).data=t:this.output(0).clear()}}o(q,"kind","string"),o(q,"inputs",a.in()),o(q,"outputs",a.out(["string"]));const Pt={[R.kind]:R,[F.kind]:F,[G.kind]:G,[D.kind]:D,[tt.kind]:tt,[L.kind]:L,[V.kind]:V,[W.kind]:W,[J.kind]:J,[q.kind]:q,[M.kind]:M},it=class{constructor(t={}){w(this,p,void 0);o(this,"nodesCatalog");o(this,"context");this.nodesCatalog=g(g({},t),Pt),A(this,p,new K({id:"g1"})),this.context={}}get executionReport(){return n(this,p).executionReport}get edges(){return n(this,p).edges}get nodes(){return n(this,p).nodes}get numEdges(){return n(this,p).numEdges}get numNodes(){return n(this,p).numNodes}get nodeKinds(){return Object.keys(this.nodesCatalog)}get runStatusIsSuccess(){return n(this,p).runStatus==="success"}get runStatusIsWaiting(){return n(this,p).runStatus==="waiting"}get runStatusIsFailure(){return n(this,p).runStatus==="failure"}set verbose(t){n(this,p).runOptions.verbose=t}clearGraph(){n(this,p).clear()}connect(t,e=0){return{to:(s,r=0)=>{const c=n(this,p).generateEdgeId(),h=t.output(e),d=s.input(r);this.newEdge({id:c,source:[t.id,h.id],target:[s.id,d.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(N("edgeId"));const e=n(this,p).getEdgeById(t);if(e){const[s,r]=e.target;this.getNodeById(s).getInputById(r).disconnect(),n(this,p).deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(N("nodeId"));const e=this.getNodeById(t);if(e){for(const s of n(this,p).edges){const{source:[r],target:[c]}=s;(r===e.id||c===e.id)&&this.deleteEdge(s.id)}n(this,p).deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,e]){for(const s of this.edges){const[r,c]=s.source,[h,d]=s.target;(r===t&&c===e||h===t&&d===e)&&this.deleteEdge(s.id)}}executeFunction(t,e){var l,y;const{verbose:s}=n(this,p).runOptions,r=n(this,p).nodeConnections,c=K.childrenOfNodeId(t,r),h=[];for(const v of c){const I=this.getNodeById(v);I.kind===M.kind&&h.push(I.id)}const d=h.reduce((v,I,B,rt)=>{const Nt=K.ancestorsOfNodeId(I,r),pt=v.concat(Nt);return B===rt.length?Array.from(new Set(pt)):pt},[]),f=K.sort([...h,...d],r);for(const v of f){const I=this.getNodeById(v);try{switch(I.kind){case R.kind:{const B=I.input(0).data,rt=typeof B=="number"&&!isNaN(B)?Math.max(B,0):0;I.output(0).data=e[rt];break}case M.kind:return I.input(1).data;default:!I.meta.isConstant&&!I.meta.isAsync&&I.run(),s&&((y=(l=this.executionReport)==null?void 0:l.steps)==null||y.push(dt(I.toObject())))}}catch(B){console.error(B)}}}getEdgeById(t){return n(this,p).getEdgeById(t)}getNodeById(t){return n(this,p).getNodeById(t)}newNode(t){var f,l,y;const e=(f=this.nodesCatalog[t.kind])!=null?f:_,s=u.isDflowId(t.id)?t.id:n(this,p).generateNodeId(),r={isAsync:e.isAsync,isConstant:e.isConstant},c=Array.isArray(t.inputs)?t.inputs:C(l=it,st,jt).call(l,e.inputs),h=Array.isArray(t.outputs)?t.outputs:C(y=it,nt,vt).call(y,e.outputs),d=new e(E(g({},t),{id:s,inputs:c,outputs:h}),this,r);return n(this,p).addNode(d),d}newEdge(t){const e=u.isDflowId(t.id)?t.id:n(this,p).generateEdgeId(),s=new Ot(E(g({},t),{id:e}));n(this,p).addEdge(s);const[r,c]=s.source,[h,d]=s.target,f=n(this,p).getNodeById(r),l=n(this,p).getNodeById(h),y=f.getOutputById(c);return l.getInputById(d).connectTo(y),s}newInput(t,e){return n(this,p).getNodeById(t).newInput(e)}newOutput(t,e){return n(this,p).getNodeById(t).newOutput(e)}toObject(){return n(this,p).toObject()}async run(){await n(this,p).run()}};let et=it;p=new WeakMap,st=new WeakSet,jt=function(t=[]){return t.map((e,s)=>E(g({},e),{id:`i${s}`}))},nt=new WeakSet,vt=function(t=[]){return t.map((e,s)=>E(g({},e),{id:`o${s}`}))},w(et,st),w(et,nt);export{u as DflowData};export{S as DflowItem};export{b as DflowPin};export{ct as DflowInput};export{at as DflowOutput};export{a as DflowNode};export{_ as DflowUnknownNode};export{Ot as DflowEdge};export{K as DflowGraph};export{et as DflowHost};
