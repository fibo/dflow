var pt=Object.defineProperty,lt=Object.defineProperties;var ft=Object.getOwnPropertyDescriptors;var L=Object.getOwnPropertySymbols;var st=Object.prototype.hasOwnProperty,nt=Object.prototype.propertyIsEnumerable;var Y=(i,t,e)=>t in i?pt(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e,f=(i,t)=>{for(var e in t||(t={}))st.call(t,e)&&Y(i,e,t[e]);if(L)for(var e of L(t))nt.call(t,e)&&Y(i,e,t[e]);return i},N=(i,t)=>lt(i,ft(t));var A=(i,t)=>{var e={};for(var s in i)st.call(i,s)&&t.indexOf(s)<0&&(e[s]=i[s]);if(i!=null&&L)for(var s of L(i))t.indexOf(s)<0&&nt.call(i,s)&&(e[s]=i[s]);return e};var a=(i,t,e)=>(Y(i,typeof t!="symbol"?t+"":t,e),e),Z=(i,t,e)=>{if(!t.has(i))throw TypeError("Cannot "+e)};var n=(i,t,e)=>(Z(i,t,"read from private field"),e?e.call(i):t.get(i)),g=(i,t,e)=>{if(t.has(i))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(i):t.set(i,e)},O=(i,t,e,s)=>(Z(i,t,"write to private field"),s?s.call(i,e):t.set(i,e),e);var M=(i,t,e)=>(Z(i,t,"access private method"),e);var $,z,D,P,B,k,C,H,J,dt,K,ct,I,m,c,G;const T=i=>`${i} must be a string`,rt=i=>`${i} must be a number`,it=(i,t)=>`${t} pin not found nodeId=${i}`,ot=(i,t,e)=>`${it(i,t)} position=${e}`,ut=(i,t,e)=>`${it(i,t)} pinId=${e}`,_=({id:i,kind:t,outputs:e})=>({id:i,kind:t,outputs:e==null?void 0:e.map(({id:s,data:r,name:u})=>({id:s,data:r,name:u}))});class o{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowGraph(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&Array.isArray(t.nodes)&&Array.isArray(t.edges)&&j.isDflowGraph(t)}static isDflowId(t){return o.isStringNotEmpty(t)}static isDflowType(t){return typeof t=="string"&&v.types.includes(t)}static isObject(t){return!o.isUndefined(t)&&!o.isNull(t)&&!o.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return o.isString(t)&&t.length>0}static isUndefined(t){return typeof t>"u"}static validate(t,e){return e.length===0?!0:e.some(s=>{switch(s){case"array":return o.isArray(t);case"boolean":return o.isBoolean(t);case"null":return o.isNull(t);case"number":return o.isNumber(t);case"object":return o.isObject(t);case"string":return o.isString(t);case"DflowGraph":return o.isDflowGraph(t);case"DflowId":return o.isDflowId(t);case"DflowType":return o.isDflowType(t);default:return!1}},!0)}}class S{constructor({id:t,name:e}){a(this,"id");a(this,"name");this.id=t,this.name=e}static isDflowItem({id:t,name:e}){return o.isDflowId(t)&&(o.isUndefined(e)||o.isStringNotEmpty(e))}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const Q=class extends S{constructor(t,r){var u=r,{types:e=[]}=u,s=A(u,["types"]);super(s);a(this,"kind");a(this,"types");this.kind=t,this.types=e}static isDflowPin(s){var r=s,{types:t=[]}=r,e=A(r,["types"]);return S.isDflowItem(e)&&t.every(u=>Q.isDflowPinType(u))}static isDflowPinType(t){Q.types.includes(t)}get hasTypeAny(){return this.types.length===0}get hasTypeDflowId(){return this.hasTypeAny||this.types.includes("DflowId")}get hasTypeDflowGraph(){return this.hasTypeAny||this.types.includes("DflowGraph")}get hasTypeDflowType(){return this.hasTypeAny||this.types.includes("DflowType")}get hasTypeString(){return this.hasTypeAny||this.types.includes("string")}get hasTypeNumber(){return this.hasTypeAny||this.types.includes("number")}get hasTypeBoolean(){return this.hasTypeAny||this.types.includes("boolean")}get hasTypeNull(){return this.hasTypeAny||this.types.includes("null")}get hasTypeObject(){return this.hasTypeAny||this.types.includes("object")}get hasTypeArray(){return this.hasTypeAny||this.types.includes("array")}addType(t){this.types.push(t)}removeType(t){this.types.splice(this.types.indexOf(t),1)}};let v=Q;a(v,"types",["string","number","boolean","null","object","array","DflowId","DflowGraph","DflowType"]);class V extends v{constructor(s){var r=s,{optional:t}=r,e=A(r,["optional"]);super("input",e);g(this,$,void 0);g(this,z,void 0);O(this,z,t)}static isDflowInput({id:t,types:e}){return v.isDflowPin({id:t,types:e})}get data(){var t;return(t=n(this,$))==null?void 0:t.data}get isConnected(){return typeof n(this,$)>"u"}get isOptional(){return n(this,z)}connectTo(t){const{hasTypeAny:e,types:s}=this,{types:r}=t;if(e||s.some(u=>r.includes(u)))O(this,$,t);else throw new Error(`mismatching pinTypes, source has types [${r.join()}] and target has types [${s.join()}]`)}disconnect(){O(this,$,void 0)}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}$=new WeakMap,z=new WeakMap;class W extends v{constructor(s){var r=s,{data:t}=r,e=A(r,["data"]);super("output",e);g(this,D,void 0);O(this,D,t)}static isDflowOutput({id:t,data:e,types:s=[]}){return v.isDflowPin({id:t,types:s})&&o.validate(e,s)}clear(){O(this,D,void 0)}get data(){return n(this,D)}set data(t){switch(!0){case o.isUndefined(t):this.clear();break;case this.hasTypeAny:case(o.isDflowGraph(t)&&this.hasTypeDflowGraph):case(o.isDflowId(t)&&this.hasTypeDflowId):case(o.isString(t)&&this.hasTypeString):case(o.isNumber(t)&&this.hasTypeNumber):case(o.isBoolean(t)&&this.hasTypeBoolean):case(o.isNull(t)&&this.hasTypeNull):case(o.isObject(t)&&this.hasTypeObject):case(o.isArray(t)&&this.hasTypeArray):{O(this,D,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=f({},super.toObject());return o.isUndefined(n(this,D))||(t.data=n(this,D)),this.types.length>0&&(t.types=this.types),t}}D=new WeakMap;const X=class extends S{constructor(l,u,{isAsync:h=!1,isConstant:d=!1,label:p}={}){var E=l,{kind:t,inputs:e=[],outputs:s=[]}=E,r=A(E,["kind","inputs","outputs"]);super(r);g(this,J);g(this,K);g(this,P,new Map);g(this,B,new Map);g(this,k,[]);g(this,C,[]);g(this,H,void 0);a(this,"kind");a(this,"meta");a(this,"host");O(this,H,p),this.host=u,this.kind=t,this.meta={isAsync:h,isConstant:d};for(const b of e)this.newInput(b);for(const b of s)this.newOutput(b);this.onCreate()}static generateInputIds(t=[]){return t.map((e,s)=>N(f({},e),{id:`i${s}`}))}static generateOutputIds(t=[]){return t.map((e,s)=>N(f({},e),{id:`o${s}`}))}static in(t=[],e){return[f({types:t},e)]}static ins(t,e=[]){return Array(t).fill(X.in(e)).flat()}static out(t=[],e){return[f({types:t},e)]}static outs(t,e=[]){return Array(t).fill(X.out(e)).flat()}static outputNumber(t){return N(f({},t),{types:["number"]})}static isDflowNode(u){var h=u,{kind:t,inputs:e=[],outputs:s=[]}=h,r=A(h,["kind","inputs","outputs"]);return S.isDflowItem(r)&&o.isStringNotEmpty(t)&&e.every(d=>V.isDflowInput(d))&&s.every(d=>W.isDflowOutput(d))}get label(){return n(this,H)||this.kind}get inputs(){return n(this,P).values()}get outputs(){return n(this,B).values()}get numInputs(){return n(this,P).size}get numOutputs(){return n(this,B).size}clearOutputs(){for(const t of this.outputs)t.clear()}getInputById(t){if(typeof t!="string")throw new TypeError(T("inputId"));const e=n(this,P).get(t);if(e instanceof V)return e;throw new Error(ut(this.id,"input",t))}input(t){if(typeof t!="number")throw new TypeError(rt("position"));const e=n(this,k)[t];if(o.isUndefined(e))throw new Error(ot(this.id,"input",t));return this.getInputById(e)}getOutputById(t){if(typeof t!="string")throw new TypeError(T("outputId"));const e=n(this,B).get(t);if(e instanceof W)return e;throw new Error(ut(this.id,"output",t))}output(t){if(typeof t!="number")throw new TypeError(rt("position"));const e=n(this,C)[t];if(o.isUndefined(e))throw new Error(ot(this.id,"output",t));return this.getOutputById(e)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),n(this,P).delete(t),n(this,k).splice(n(this,k).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),n(this,B).delete(t),n(this,C).splice(n(this,C).indexOf(t),1)}onBeforeConnectInput(t,e){}onCreate(){}newInput(t){const e=o.isDflowId(t.id)?t.id:M(this,J,dt).call(this),s=new V(N(f({},t),{id:e}));return n(this,P).set(e,s),n(this,k).push(e),s}newOutput(t){const e=o.isDflowId(t.id)?t.id:M(this,K,ct).call(this),s=new W(N(f({},t),{id:e}));return n(this,B).set(e,s),n(this,C).push(e),s}run(){}toObject(){const t=N(f({},super.toObject()),{kind:this.kind}),e=[],s=[];for(const r of this.inputs)e.push(r.toObject());e.length>0&&(t.inputs=e);for(const r of this.outputs)s.push(r.toObject());return s.length>0&&(t.outputs=s),t}};let y=X;P=new WeakMap,B=new WeakMap,k=new WeakMap,C=new WeakMap,H=new WeakMap,J=new WeakSet,dt=function(t=this.numInputs){const e=`i${t}`;return n(this,P).has(e)?M(this,J,dt).call(this,t+1):e},K=new WeakSet,ct=function(t=this.numOutputs){const e=`o${t}`;return n(this,B).has(e)?M(this,K,ct).call(this,t+1):e},a(y,"kind"),a(y,"isAsync"),a(y,"isConstant"),a(y,"label"),a(y,"inputs"),a(y,"outputs");const tt=class extends y{constructor(t,e){super(N(f({},t),{kind:tt.kind}),e)}run(){}};let q=tt;a(q,"kind","Unknown");class F extends S{constructor(r){var u=r,{source:t,target:e}=u,s=A(u,["source","target"]);super(s);a(this,"source");a(this,"target");const[h,d]=t,[p,l]=e;if(typeof h!="string")throw new TypeError(T("sourceNodeId"));if(typeof d!="string")throw new TypeError(T("sourcePinId"));if(typeof p!="string")throw new TypeError(T("targetNodeId"));if(typeof l!="string")throw new TypeError(T("targetPinId"));this.source=t,this.target=e}static isDflowEdge(u,r){var h=u,{source:t,target:e}=h,s=A(h,["source","target"]);return S.isDflowItem(s)&&Array.isArray(t)&&t.length===2&&r.nodes.find(({id:d,outputs:p=[]})=>d===t[0]&&p.find(({id:l})=>l===t[1]))&&Array.isArray(e)&&e.length===2&&r.nodes.find(({id:d,inputs:p=[]})=>d===e[0]&&p.find(({id:l})=>l===e[1]))}toObject(){return N(f({},super.toObject()),{source:this.source,target:this.target})}}const x=class extends S{constructor(){super(...arguments);g(this,I,new Map);g(this,m,new Map);a(this,"runOptions",{verbose:!1});a(this,"runStatus",null);a(this,"executionReport",null)}static isDflowGraph(t){return t.nodes.every(e=>y.isDflowNode(e))&&t.edges.every(e=>F.isDflowEdge(e,t))}static childrenOfNodeId(t,e){return e.filter(({sourceId:s})=>t===s).map(({targetId:s})=>s)}static parentsOfNodeId(t,e){return e.filter(({targetId:s})=>t===s).map(({sourceId:s})=>s)}static levelOfNodeId(t,e){const s=x.parentsOfNodeId(t,e);if(s.length===0)return 0;let r=0;for(const u of s){const h=x.levelOfNodeId(u,e);r=Math.max(h,r)}return r+1}static ancestorsOfNodeId(t,e){const s=x.parentsOfNodeId(t,e);return s.length===0?[]:s.reduce((r,u,h,d)=>{const p=x.ancestorsOfNodeId(u,e),l=r.concat(p);return h===d.length-1?Array.from(new Set(d.concat(l))):l},[])}static sort(t,e){const s={};for(const r of t)s[r]=x.levelOfNodeId(r,e);return t.slice().sort((r,u)=>s[r]<=s[u]?-1:1)}get edges(){return n(this,m).values()}get nodes(){return n(this,I).values()}get nodeConnections(){return[...n(this,m).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...n(this,m).keys()]}get nodeIds(){return[...n(this,I).keys()]}get numEdges(){return n(this,m).size}get numNodes(){return n(this,I).size}addEdge(t){if(n(this,m).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);n(this,m).set(t.id,t)}addNode(t){if(n(this,I).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);n(this,I).set(t.id,t)}clear(){n(this,I).clear(),n(this,m).clear()}deleteEdge(t){n(this,m).delete(t)}deleteNode(t){n(this,I).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(T("nodeId"));const e=n(this,I).get(t);if(e instanceof y)return e;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(T("edgeId"));const e=n(this,m).get(t);if(e instanceof F)return e;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const e=`e${t}`;return n(this,m).has(e)?this.generateEdgeId(t+1):e}generateNodeId(t=this.numNodes){const e=`n${t}`;return n(this,I).has(e)?this.generateNodeId(t+1):e}nodeIdsInsideFunctions(){const t=[];for(const e of this.nodes)e.kind==="return"&&t.push(x.ancestorsOfNodeId(e.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){var r,u;const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const e=this.nodeIdsInsideFunctions(),s=x.sort(this.nodeIds.filter(h=>!e.includes(h)),this.nodeConnections);e:for(const h of s){const d=n(this,I).get(h);try{if(!d.meta.isConstant){let p=!1;t:for(const{data:l,types:E,isOptional:b}of d.inputs){if(b&&typeof l>"u")continue t;if(!o.validate(l,E)){p=!0;break t}}if(p){for(const l of d.outputs)l.clear();t&&((r=this.executionReport.steps)==null||r.push(_(d.toObject())));continue e}d.meta.isAsync?await d.run():d.run()}t&&((u=this.executionReport.steps)==null||u.push(_(d.toObject())))}catch(p){console.error(p),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=N(f({},super.toObject()),{nodes:[],edges:[]});for(const e of this.nodes)t.nodes.push(e.toObject());for(const e of this.edges)t.edges.push(e.toObject());return t}};let j=x;I=new WeakMap,m=new WeakMap;class gt{constructor(t={}){g(this,c,void 0);g(this,G,void 0);a(this,"context");O(this,G,t),O(this,c,new j({id:"g1"})),this.context={}}get executionReport(){return n(this,c).executionReport}get edges(){return n(this,c).edges}get nodes(){return n(this,c).nodes}get numEdges(){return n(this,c).numEdges}get numNodes(){return n(this,c).numNodes}get nodeKinds(){return Object.keys(n(this,G))}get runStatusIsSuccess(){return n(this,c).runStatus==="success"}get runStatusIsWaiting(){return n(this,c).runStatus==="waiting"}get runStatusIsFailure(){return n(this,c).runStatus==="failure"}set verbose(t){n(this,c).runOptions.verbose=t}clearGraph(){n(this,c).clear()}connect(t,e=0){return{to:(s,r=0)=>{const u=n(this,c).generateEdgeId(),h=t.output(e),d=s.input(r);s.onBeforeConnectInput(t,e),this.newEdge({id:u,source:[t.id,h.id],target:[s.id,d.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(T("edgeId"));const e=n(this,c).getEdgeById(t);if(e instanceof F){const[s,r]=e.target;this.getNodeById(s).getInputById(r).disconnect(),n(this,c).deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(T("nodeId"));const e=this.getNodeById(t);if(e instanceof y){for(const s of n(this,c).edges){const{source:[r],target:[u]}=s;(r===e.id||u===e.id)&&this.deleteEdge(s.id)}n(this,c).deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,e]){for(const s of this.edges){const[r,u]=s.source,[h,d]=s.target;(r===t&&u===e||h===t&&d===e)&&this.deleteEdge(s.id)}}executeFunction(t,e){var l,E,b;const{verbose:s}=n(this,c).runOptions,r=n(this,c).nodeConnections,u=j.childrenOfNodeId(t,r),h=[];for(const R of u){const w=this.getNodeById(R);w.kind==="return"&&h.push(w.id)}const d=h.reduce((R,w,U,ht)=>{const at=j.ancestorsOfNodeId(w,r),et=R.concat(at);return U===ht.length?Array.from(new Set(et)):et},[]),p=j.sort([...h,...d],r);for(const R of p){const w=this.getNodeById(R);try{switch(w.kind){case"argument":{const U=Math.max((l=w.input(1).data)!=null?l:0,0);w.output(0).data=e[U];break}case"return":return w.input(1).data;default:!w.meta.isConstant&&!w.meta.isAsync&&w.run(),s&&((b=(E=this.executionReport)==null?void 0:E.steps)==null||b.push(_(w.toObject())))}}catch(U){console.error(U)}}}getEdgeById(t){return n(this,c).getEdgeById(t)}getNodeById(t){return n(this,c).getNodeById(t)}newNode(t){var p;const e=(p=n(this,G)[t.kind])!=null?p:q,s=o.isDflowId(t.id)?t.id:n(this,c).generateNodeId(),r={isAsync:e.isAsync,isConstant:e.isConstant,label:e.label},u=Array.isArray(t.inputs)?t.inputs:y.generateInputIds(e.inputs),h=Array.isArray(t.outputs)?t.outputs:y.generateOutputIds(e.outputs),d=new e(N(f({},t),{id:s,inputs:u,outputs:h}),this,r);return n(this,c).addNode(d),d}newEdge(t){const e=o.isDflowId(t.id)?t.id:n(this,c).generateEdgeId(),s=new F(N(f({},t),{id:e}));n(this,c).addEdge(s);const[r,u]=s.source,[h,d]=s.target,p=n(this,c).getNodeById(r),l=n(this,c).getNodeById(h),E=p.getOutputById(u);return l.getInputById(d).connectTo(E),s}newInput(t,e){return n(this,c).getNodeById(t).newInput(e)}newOutput(t,e){return n(this,c).getNodeById(t).newOutput(e)}toObject(){return n(this,c).toObject()}async run(){await n(this,c).run()}}c=new WeakMap,G=new WeakMap;export{o as DflowData};export{S as DflowItem};export{v as DflowPin};export{V as DflowInput};export{W as DflowOutput};export{y as DflowNode};export{q as DflowUnknownNode};export{F as DflowEdge};export{j as DflowGraph};export{gt as DflowHost};
