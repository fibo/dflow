var ms=Object.defineProperty,ks=Object.defineProperties;var gs=Object.getOwnPropertyDescriptors;var Yt=Object.getOwnPropertySymbols;var is=Object.prototype.hasOwnProperty,ns=Object.prototype.propertyIsEnumerable;var _t=(e,t,n)=>t in e?ms(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,d=(e,t)=>{for(var n in t||(t={}))is.call(t,n)&&_t(e,n,t[n]);if(Yt)for(var n of Yt(t))ns.call(t,n)&&_t(e,n,t[n]);return e},b=(e,t)=>ks(e,gs(t));var x=(e,t)=>{var n={};for(var a in e)is.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(e!=null&&Yt)for(var a of Yt(e))t.indexOf(a)<0&&ns.call(e,a)&&(n[a]=e[a]);return n};var s=(e,t,n)=>(_t(e,typeof t!="symbol"?t+"":t,n),n),wt=(e,t,n)=>{if(!t.has(e))throw TypeError("Cannot "+n)};var u=(e,t,n)=>(wt(e,t,"read from private field"),n?n.call(e):t.get(e)),m=(e,t,n)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,n)},N=(e,t,n,a)=>(wt(e,t,"write to private field"),a?a.call(e,n):t.set(e,n),n);var G=(e,t,n)=>(wt(e,t,"access private method"),n);var C,Ft,I,T,O,B,P,Qt,Vt,ds,Wt,cs,k,g;const E=e=>`${e} must be a string`,es=e=>`${e} must be a number`,as=(e,t)=>`${t} pin not found nodeId=${e}`,us=(e,t,n)=>`${as(e,t)} position=${n}`,rs=(e,t,n)=>`${as(e,t)} pinId=${n}`,os=({id:e,kind:t,outputs:n})=>({id:e,kind:t,outputs:n==null?void 0:n.map(({id:a,data:r,name:c})=>({id:a,data:r,name:c}))});class o{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowGraph(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&Array.isArray(t.nodes)&&Array.isArray(t.edges)&&ls.isDflowGraph(t)}static isDflowId(t){return o.isStringNotEmpty(t)}static isDflowType(t){return typeof t=="string"&&v.types.includes(t)}static isObject(t){return!o.isUndefined(t)&&!o.isNull(t)&&!o.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return o.isString(t)&&t.length>0}static isUndefined(t){return typeof t>"u"}static validate(t,n){return n.length===0?!0:n.some(a=>{switch(a){case"array":return o.isArray(t);case"boolean":return o.isBoolean(t);case"null":return o.isNull(t);case"number":return o.isNumber(t);case"object":return o.isObject(t);case"string":return o.isString(t);case"DflowGraph":return o.isDflowGraph(t);case"DflowId":return o.isDflowId(t);case"DflowType":return o.isDflowType(t);default:return!1}},!0)}}class j{constructor({id:t,name:n}){s(this,"id");s(this,"name");this.id=t,this.name=n}static isDflowItem({id:t,name:n}){return o.isDflowId(t)&&(o.isUndefined(n)||o.isStringNotEmpty(n))}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const Mt=class extends j{constructor(t,r){var c=r,{types:n=[]}=c,a=x(c,["types"]);super(a);s(this,"kind");s(this,"types");this.kind=t,this.types=n}static isDflowPin(a){var r=a,{types:t=[]}=r,n=x(r,["types"]);return j.isDflowItem(n)&&t.every(c=>Mt.isDflowPinType(c))}static isDflowPinType(t){Mt.types.includes(t)}get hasTypeAny(){return this.types.length===0}get hasTypeDflowId(){return this.hasTypeAny||this.types.includes("DflowId")}get hasTypeDflowGraph(){return this.hasTypeAny||this.types.includes("DflowGraph")}get hasTypeDflowType(){return this.hasTypeAny||this.types.includes("DflowType")}get hasTypeString(){return this.hasTypeAny||this.types.includes("string")}get hasTypeNumber(){return this.hasTypeAny||this.types.includes("number")}get hasTypeBoolean(){return this.hasTypeAny||this.types.includes("boolean")}get hasTypeNull(){return this.hasTypeAny||this.types.includes("null")}get hasTypeObject(){return this.hasTypeAny||this.types.includes("object")}get hasTypeArray(){return this.hasTypeAny||this.types.includes("array")}addType(t){this.types.push(t)}removeType(t){this.types.splice(this.types.indexOf(t),1)}};let v=Mt;s(v,"types",["string","number","boolean","null","object","array","DflowId","DflowGraph","DflowType"]);class Dt extends v{constructor(a){var r=a,{optional:t}=r,n=x(r,["optional"]);super("input",n);m(this,C,void 0);m(this,Ft,void 0);N(this,Ft,t)}static isDflowInput({id:t,types:n}){return v.isDflowPin({id:t,types:n})}get data(){var t;return(t=u(this,C))==null?void 0:t.data}get isConnected(){return typeof u(this,C)>"u"}get isOptional(){return u(this,Ft)}connectTo(t){const{hasTypeAny:n,types:a}=this,{types:r}=t;if(n||a.some(c=>r.includes(c)))N(this,C,t);else throw new Error(`mismatching pinTypes, source has types [${r.join()}] and target has types [${a.join()}]`)}disconnect(){N(this,C,void 0)}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}C=new WeakMap,Ft=new WeakMap;class ts extends v{constructor(a){var r=a,{data:t}=r,n=x(r,["data"]);super("output",n);m(this,I,void 0);N(this,I,t)}static isDflowOutput({id:t,data:n,types:a=[]}){return v.isDflowPin({id:t,types:a})&&o.validate(n,a)}clear(){N(this,I,void 0)}get data(){return u(this,I)}set data(t){switch(!0){case o.isUndefined(t):this.clear();break;case this.hasTypeAny:case(o.isDflowGraph(t)&&this.hasTypeDflowGraph):case(o.isDflowId(t)&&this.hasTypeDflowId):case(o.isString(t)&&this.hasTypeString):case(o.isNumber(t)&&this.hasTypeNumber):case(o.isBoolean(t)&&this.hasTypeBoolean):case(o.isNull(t)&&this.hasTypeNull):case(o.isObject(t)&&this.hasTypeObject):case(o.isArray(t)&&this.hasTypeArray):{N(this,I,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=d({},super.toObject());return o.isUndefined(u(this,I))||(t.data=u(this,I)),this.types.length>0&&(t.types=this.types),t}}I=new WeakMap;const Lt=class extends j{constructor(y,c,{isAsync:h=!1,isConstant:p=!1,label:l}={}){var Xt=y,{kind:t,inputs:n=[],outputs:a=[]}=Xt,r=x(Xt,["kind","inputs","outputs"]);super(r);m(this,Vt);m(this,Wt);m(this,T,new Map);m(this,O,new Map);m(this,B,[]);m(this,P,[]);m(this,Qt,void 0);s(this,"kind");s(this,"meta");s(this,"host");N(this,Qt,l),this.host=c,this.kind=t,this.meta={isAsync:h,isConstant:p};for(const A of n)this.newInput(A);for(const A of a)this.newOutput(A);this.onCreate()}static generateInputIds(t=[]){return t.map((n,a)=>b(d({},n),{id:`i${a}`}))}static generateOutputIds(t=[]){return t.map((n,a)=>b(d({},n),{id:`o${a}`}))}static in(t=[],n){return[d({types:t},n)]}static ins(t,n=[]){return Array(t).fill(Lt.in(n)).flat()}static out(t=[],n){return[d({types:t},n)]}static outs(t,n=[]){return Array(t).fill(Lt.out(n)).flat()}static outputNumber(t){return b(d({},t),{types:["number"]})}static isDflowNode(c){var h=c,{kind:t,inputs:n=[],outputs:a=[]}=h,r=x(h,["kind","inputs","outputs"]);return j.isDflowItem(r)&&o.isStringNotEmpty(t)&&n.every(p=>Dt.isDflowInput(p))&&a.every(p=>ts.isDflowOutput(p))}get label(){return u(this,Qt)||this.kind}get inputs(){return u(this,T).values()}get outputs(){return u(this,O).values()}get numInputs(){return u(this,T).size}get numOutputs(){return u(this,O).size}clearOutputs(){for(const t of this.outputs)t.clear()}getInputById(t){if(typeof t!="string")throw new TypeError(E("inputId"));const n=u(this,T).get(t);if(n instanceof Dt)return n;throw new Error(rs(this.id,"input",t))}input(t){if(typeof t!="number")throw new TypeError(es("position"));const n=u(this,B)[t];if(o.isUndefined(n))throw new Error(us(this.id,"input",t));return this.getInputById(n)}getOutputById(t){if(typeof t!="string")throw new TypeError(E("outputId"));const n=u(this,O).get(t);if(n instanceof ts)return n;throw new Error(rs(this.id,"output",t))}output(t){if(typeof t!="number")throw new TypeError(es("position"));const n=u(this,P)[t];if(o.isUndefined(n))throw new Error(us(this.id,"output",t));return this.getOutputById(n)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),u(this,T).delete(t),u(this,B).splice(u(this,B).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),u(this,O).delete(t),u(this,P).splice(u(this,P).indexOf(t),1)}onBeforeConnectInput(t,n){}onCreate(){}newInput(t){const n=o.isDflowId(t.id)?t.id:G(this,Vt,ds).call(this),a=new Dt(b(d({},t),{id:n}));return u(this,T).set(n,a),u(this,B).push(n),a}newOutput(t){const n=o.isDflowId(t.id)?t.id:G(this,Wt,cs).call(this),a=new ts(b(d({},t),{id:n}));return u(this,O).set(n,a),u(this,P).push(n),a}run(){}toObject(){const t=b(d({},super.toObject()),{kind:this.kind}),n=[],a=[];for(const r of this.inputs)n.push(r.toObject());n.length>0&&(t.inputs=n);for(const r of this.outputs)a.push(r.toObject());return a.length>0&&(t.outputs=a),t}};let i=Lt;T=new WeakMap,O=new WeakMap,B=new WeakMap,P=new WeakMap,Qt=new WeakMap,Vt=new WeakSet,ds=function(t=this.numInputs){const n=`i${t}`;return u(this,T).has(n)?G(this,Vt,ds).call(this,t+1):n},Wt=new WeakSet,cs=function(t=this.numOutputs){const n=`o${t}`;return u(this,O).has(n)?G(this,Wt,cs).call(this,t+1):n},s(i,"kind"),s(i,"isAsync"),s(i,"isConstant"),s(i,"label"),s(i,"inputs"),s(i,"outputs");const ss=class extends i{constructor(t,n){super(b(d({},t),{kind:ss.kind}),n)}run(){}};let ps=ss;s(ps,"kind","Unknown");class hs extends j{constructor(r){var c=r,{source:t,target:n}=c,a=x(c,["source","target"]);super(a);s(this,"source");s(this,"target");const[h,p]=t,[l,y]=n;if(typeof h!="string")throw new TypeError(E("sourceNodeId"));if(typeof p!="string")throw new TypeError(E("sourcePinId"));if(typeof l!="string")throw new TypeError(E("targetNodeId"));if(typeof y!="string")throw new TypeError(E("targetPinId"));this.source=t,this.target=n}static isDflowEdge(c,r){var h=c,{source:t,target:n}=h,a=x(h,["source","target"]);return j.isDflowItem(a)&&Array.isArray(t)&&t.length===2&&r.nodes.find(({id:p,outputs:l=[]})=>p===t[0]&&l.find(({id:y})=>y===t[1]))&&Array.isArray(n)&&n.length===2&&r.nodes.find(({id:p,inputs:l=[]})=>p===n[0]&&l.find(({id:y})=>y===n[1]))}toObject(){return b(d({},super.toObject()),{source:this.source,target:this.target})}}const f=class extends j{constructor(){super(...arguments);m(this,k,new Map);m(this,g,new Map);s(this,"runOptions",{verbose:!1});s(this,"runStatus",null);s(this,"executionReport",null)}static isDflowGraph(t){return t.nodes.every(n=>i.isDflowNode(n))&&t.edges.every(n=>hs.isDflowEdge(n,t))}static childrenOfNodeId(t,n){return n.filter(({sourceId:a})=>t===a).map(({targetId:a})=>a)}static parentsOfNodeId(t,n){return n.filter(({targetId:a})=>t===a).map(({sourceId:a})=>a)}static levelOfNodeId(t,n){const a=f.parentsOfNodeId(t,n);if(a.length===0)return 0;let r=0;for(const c of a){const h=f.levelOfNodeId(c,n);r=Math.max(h,r)}return r+1}static ancestorsOfNodeId(t,n){const a=f.parentsOfNodeId(t,n);return a.length===0?[]:a.reduce((r,c,h,p)=>{const l=f.ancestorsOfNodeId(c,n),y=r.concat(l);return h===p.length-1?Array.from(new Set(p.concat(y))):y},[])}static sort(t,n){const a={};for(const r of t)a[r]=f.levelOfNodeId(r,n);return t.slice().sort((r,c)=>a[r]<=a[c]?-1:1)}get edges(){return u(this,g).values()}get nodes(){return u(this,k).values()}get nodeConnections(){return[...u(this,g).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...u(this,g).keys()]}get nodeIds(){return[...u(this,k).keys()]}get numEdges(){return u(this,g).size}get numNodes(){return u(this,k).size}addEdge(t){if(u(this,g).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);u(this,g).set(t.id,t)}addNode(t){if(u(this,k).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);u(this,k).set(t.id,t)}clear(){u(this,k).clear(),u(this,g).clear()}deleteEdge(t){u(this,g).delete(t)}deleteNode(t){u(this,k).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(E("nodeId"));const n=u(this,k).get(t);if(n instanceof i)return n;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(E("edgeId"));const n=u(this,g).get(t);if(n instanceof hs)return n;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const n=`e${t}`;return u(this,g).has(n)?this.generateEdgeId(t+1):n}generateNodeId(t=this.numNodes){const n=`n${t}`;return u(this,k).has(n)?this.generateNodeId(t+1):n}nodeIdsInsideFunctions(){const t=[];for(const n of this.nodes)n.kind==="return"&&t.push(f.ancestorsOfNodeId(n.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){var r,c;const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const n=this.nodeIdsInsideFunctions(),a=f.sort(this.nodeIds.filter(h=>!n.includes(h)),this.nodeConnections);s:for(const h of a){const p=u(this,k).get(h);try{if(!p.meta.isConstant){let l=!1;t:for(const{data:y,types:Xt,isOptional:A}of p.inputs){if(A&&typeof y>"u")continue t;if(!o.validate(y,Xt)){l=!0;break t}}if(l){for(const y of p.outputs)y.clear();t&&((r=this.executionReport.steps)==null||r.push(os(p.toObject())));continue s}p.meta.isAsync?await p.run():p.run()}t&&((c=this.executionReport.steps)==null||c.push(os(p.toObject())))}catch(l){console.error(l),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=b(d({},super.toObject()),{nodes:[],edges:[]});for(const n of this.nodes)t.nodes.push(n.toObject());for(const n of this.edges)t.edges.push(n.toObject());return t}};let ls=f;k=new WeakMap,g=new WeakMap;class U extends i{run(){const t=this.input(0).data,n=this.input(1).data;this.output(0).data=t.at(n)}}s(U,"kind","arrayAt"),s(U,"inputs",[...i.in(["array"]),...i.in(["number"],{name:"index"})]),s(U,"outputs",i.out());class z extends i{run(){this.output(0).data=this.input(0).data.filter((...t)=>this.host.executeFunction(this.input(1).data,t))}}s(z,"kind","arrayFilter"),s(z,"inputs",[...i.in(["array"]),...i.in(["DflowId"],{name:"functionId"})]),s(z,"outputs",i.out(["array"]));class R extends i{run(){this.output(0).data=this.input(0).data.findLastIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}s(R,"kind","arrayFindLastIndex"),s(R,"inputs",[...i.in(["array"]),...i.in(["DflowId"],{name:"functionId"})]),s(R,"outputs",i.out(["number"]));class J extends i{run(){this.output(0).data=this.input(0).data.findIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}s(J,"kind","arrayFindIndex"),s(J,"inputs",[...i.in(["array"]),...i.in(["DflowId"],{name:"functionId"})]),s(J,"outputs",i.out(["number"]));class K extends i{run(){const t=this.input(0).data,n=this.input(1).data;Array.isArray(t)&&(this.output(0).data=t.includes(n))}}s(K,"kind","arrayIncludes"),s(K,"inputs",[...i.in(["array"],{name:"array"}),...i.in(["string"],{name:"element"})]),s(K,"outputs",i.out(["boolean"]));class H extends i{run(){var a;const t=this.input(0).data,n=(a=this.input(1).data)!=null?a:",";Array.isArray(t)&&(this.output(0).data=t.join(n))}}s(H,"kind","arrayJoin"),s(H,"inputs",[...i.in(["array"],{name:"array"}),...i.in(["string"],{name:"separator",optional:!0})]),s(H,"outputs",i.out(["string"]));class F extends i{run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t.length:this.output(0).clear}}s(F,"kind","arrayLength"),s(F,"inputs",i.in(["array"])),s(F,"outputs",i.out(["number"]));class Q extends i{run(){this.output(0).data=this.input(0).data.map((...t)=>this.host.executeFunction(this.input(1).data,t))}}s(Q,"kind","arrayMap"),s(Q,"inputs",[...i.in(["array"]),...i.in(["DflowId"],{name:"functionId"})]),s(Q,"outputs",i.out(["array"]));class V extends i{run(){const t=this.input(0).data.slice(),n=t.pop();this.output(0).data=n,this.output(1).data=t}}s(V,"kind","arrayPop"),s(V,"inputs",i.in(["array"])),s(V,"outputs",[...i.out([],{name:"element"}),...i.out(["array"],{name:"rest"})]);class W extends i{run(){const t=this.input(0).data.slice(),n=this.input(1).data;n&&t.push(n),this.output(0).data=t}}s(W,"kind","arrayPush"),s(W,"inputs",[...i.in(["array"]),...i.in([],{name:"element"})]),s(W,"outputs",i.out(["array"]));class X extends i{run(){const t=this.input(0).data.slice();this.output(0).data=t.reverse()}}s(X,"kind","arrayReverse"),s(X,"inputs",i.in(["array"])),s(X,"outputs",i.in(["array"]));class Y extends i{run(){const t=this.input(0).data.slice(),n=t.shift();this.output(0).data=n,this.output(1).data=t}}s(Y,"kind","arrayShift"),s(Y,"inputs",i.in(["array"])),s(Y,"outputs",[...i.out([],{name:"element"}),...i.out(["array"],{name:"rest"})]);class Z extends i{run(){const t=super.input(0).data,n=super.input(1).data,a=super.input(2).data;typeof a=="number"?super.output(0).data=t.slice(n,a):super.output(0).data=t.slice(n)}}s(Z,"kind","arraySlice"),s(Z,"inputs",[...i.in(["array"]),...i.in(["number"],{name:"start"}),...i.in(["number"],{name:"end",optional:!0})]),s(Z,"outputs",i.out(["array"]));const bs={[U.kind]:U,[z.kind]:z,[R.kind]:R,[J.kind]:J,[K.kind]:K,[H.kind]:H,[F.kind]:F,[Q.kind]:Q,[V.kind]:V,[W.kind]:W,[X.kind]:X,[Y.kind]:Y,[Z.kind]:Z};class q extends i{run(){this.output(0).data=this.input(0).data?this.input(1).data:this.input(2).data}}s(q,"kind","if"),s(q,"inputs",[...i.in(["boolean"],{name:"condition"}),...i.in([],{name:"then"}),...i.in([],{name:"else"})]),s(q,"outputs",i.out());const xs={[q.kind]:q};class Zt extends i{run(){console.log(this.input(0).data)}}s(Zt,"kind","consoleLog"),s(Zt,"inputs",[...i.in([])]);const fs={[Zt.kind]:Zt},ys=[...i.out(["string"]),...i.out(["number"],{name:"milliseconds"})];class M extends i{run(){const t=this.input(0).data;if(typeof t=="string"||typeof t=="number"){const a=new Date(t),r=a.toJSON();r!==null&&(this.output(0).data=r,this.output(1).data=a.getTime())}const n=new Date;this.output(0).data=n.toJSON(),this.output(1).data=n.getTime()}}s(M,"kind","newDate"),s(M,"inputs",i.in(["string","number"],{optional:!0})),s(M,"outputs",ys);class qt extends i{run(){const t=Date.now();this.output(0).data=new Date(t).toJSON(),this.output(1).data=t}}s(qt,"kind","now"),s(qt,"outputs",ys);const Is={[M.kind]:M,[qt.kind]:qt};class L extends i{}s(L,"kind","data"),s(L,"isConstant",!0),s(L,"outputs",i.out());class _ extends i{run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t:this.output(0).clear()}}s(_,"kind","array"),s(_,"inputs",i.in()),s(_,"outputs",i.out(["array"]));class w extends i{run(){const t=this.input(0).data;typeof t=="boolean"?this.output(0).data=t:this.output(0).clear()}}s(w,"kind","boolean"),s(w,"inputs",i.in()),s(w,"outputs",i.out(["boolean"]));class D extends i{run(){const t=this.input(0).data;typeof t=="number"?this.output(0).data=t:this.output(0).clear()}}s(D,"kind","number"),s(D,"inputs",i.in()),s(D,"outputs",i.out(["number"]));class tt extends i{run(){const t=this.input(0).data;typeof t=="object"&&t!==null?this.output(0).data=t:this.output(0).clear()}}s(tt,"kind","object"),s(tt,"inputs",i.in()),s(tt,"outputs",i.out(["object"]));class st extends i{run(){const t=this.input(0).data;typeof t=="string"?this.output(0).data=t:this.output(0).clear()}}s(st,"kind","string"),s(st,"inputs",i.in()),s(st,"outputs",i.out(["string"]));class it extends i{run(){const t=this.input(0).data;this.output(0).data=Array.isArray(t)}}s(it,"kind","isArray"),s(it,"inputs",i.out()),s(it,"outputs",i.out(["boolean"]));class nt extends i{run(){const t=this.input(0).data;this.output(0).data=typeof t<"u"}}s(nt,"kind","isDefined"),s(nt,"inputs",i.in()),s(nt,"outputs",i.out(["boolean"]));class et extends i{run(){const t=this.input(0).data;this.output(0).data=typeof t>"u"}}s(et,"kind","isUndefined"),s(et,"inputs",i.in()),s(et,"outputs",i.out(["boolean"]));const Ts={[L.kind]:L,[nt.kind]:nt,[et.kind]:et,[_.kind]:_,[w.kind]:w,[D.kind]:D,[tt.kind]:tt,[st.kind]:st,[it.kind]:it};class $ extends i{run(){const t=this.output(0);t.data=this.host.nodeKinds}}s($,"kind","dflow"),s($,"outputs",i.out(["array"],{name:"nodeKinds"}));class at extends i{}s(at,"kind","comment"),s(at,"isConstant",!0),s(at,"outputs",i.out(["string"]));class ut extends i{}s(ut,"kind","typeNumber"),s(ut,"isConstant",!0),s(ut,"outputs",i.out(["DflowType"],{name:"number",data:"number"}));class S extends i{onBeforeConnectInput(t,n){const a=t.output(n).data;this.output(0).addType(a)}}s(S,"kind","argument"),s(S,"isConstant",!0),s(S,"inputs",[...i.in(["DflowType"],{name:"type"}),...i.in(["number"],{name:"argumentPosition"})]),s(S,"outputs",i.out());class rt extends i{onCreate(){this.output(0).data=this.id}}s(rt,"kind","function"),s(rt,"isConstant",!0),s(rt,"outputs",$.out(["DflowId"],{name:"id"}));class ot extends i{}s(ot,"kind","return"),s(ot,"isConstant",!0),s(ot,"inputs",[...$.in(["DflowId"],{name:"functionId"}),...$.in([],{name:"value"})]);const Os={[$.kind]:$,[S.kind]:S,[at.kind]:at,[rt.kind]:rt,[ot.kind]:ot,[ut.kind]:ut};class dt extends i{run(){this.output(0).data=this.input(0).data&&this.input(1).data}}s(dt,"kind","and"),s(dt,"inputs",i.ins(2,["boolean"])),s(dt,"outputs",i.out(["boolean"]));class ct extends i{run(){this.output(0).data=!this.input(0).data}}s(ct,"kind","not"),s(ct,"inputs",i.in(["boolean"])),s(ct,"outputs",i.out(["boolean"]));class pt extends i{run(){this.output(0).data=this.input(0).data||this.input(1).data}}s(pt,"kind","or"),s(pt,"inputs",i.ins(2,["boolean"])),s(pt,"outputs",i.out(["boolean"]));const Ns={[dt.kind]:dt,[ct.kind]:ct,[pt.kind]:pt};class ht extends i{run(){this.output(0).data=Math.abs(this.input(0).data)}}s(ht,"kind","mathAbs"),s(ht,"inputs",i.in(["number"])),s(ht,"outputs",i.out(["number"]));class lt extends i{run(){this.output(0).data=Math.cos(this.input(0).data)}}s(lt,"kind","mathCos"),s(lt,"inputs",i.in(["number"])),s(lt,"outputs",i.out(["number"]));class yt extends i{run(){this.output(0).data=Math.cosh(this.input(0).data)}}s(yt,"kind","mathCosh"),s(yt,"inputs",i.in(["number"])),s(yt,"outputs",i.out(["number"]));class mt extends i{run(){this.output(0).data=Math.floor(this.input(0).data)}}s(mt,"kind","mathFloor"),s(mt,"inputs",i.in(["number"])),s(mt,"outputs",i.out(["number"]));class kt extends i{run(){const t=this.input(0).data,n=Math.max(...t);isNaN(n)?this.output(0).clear():this.output(0).data=n}}s(kt,"kind","mathMax"),s(kt,"inputs",i.in(["array"])),s(kt,"outputs",i.out(["number"]));class gt extends i{run(){const t=this.input(0).data,n=Math.min(...t);isNaN(n)?this.output(0).clear():this.output(0).data=n}}s(gt,"kind","mathMin"),s(gt,"inputs",i.in(["array"])),s(gt,"outputs",i.out(["number"]));class bt extends i{}s(bt,"kind","mathPI"),s(bt,"isConstant",!0),s(bt,"outputs",i.out(["number"],{name:"\u03C0",data:Math.PI}));class xt extends i{run(){this.output(0).data=Math.round(this.input(0).data)}}s(xt,"kind","mathRound"),s(xt,"inputs",i.in(["number"])),s(xt,"outputs",i.out(["number"]));class ft extends i{run(){this.output(0).data=Math.sin(this.input(0).data)}}s(ft,"kind","mathSin"),s(ft,"inputs",i.in(["number"])),s(ft,"outputs",i.out(["number"]));class It extends i{run(){this.output(0).data=Math.sinh(this.input(0).data)}}s(It,"kind","mathSinh"),s(It,"inputs",i.in(["number"])),s(It,"outputs",i.out(["number"]));const Es={[ht.kind]:ht,[lt.kind]:lt,[yt.kind]:yt,[mt.kind]:mt,[kt.kind]:kt,[gt.kind]:gt,[bt.kind]:bt,[xt.kind]:xt,[ft.kind]:ft,[It.kind]:It};class Tt extends i{run(){this.output(0).data=Number.isFinite(this.input(0).data)}}s(Tt,"kind","isFinite"),s(Tt,"inputs",i.in(["number"])),s(Tt,"outputs",i.out(["boolean"]));class Ot extends i{run(){this.output(0).data=Number.isInteger(this.input(0).data)}}s(Ot,"kind","isInteger"),s(Ot,"inputs",i.in([])),s(Ot,"outputs",i.out(["boolean"]));class Nt extends i{run(){this.output(0).data=Number.isNaN(this.input(0).data)}}s(Nt,"kind","isNaN"),s(Nt,"inputs",i.in([])),s(Nt,"outputs",i.out(["boolean"]));class Et extends i{run(){this.output(0).data=parseFloat(this.input(0).data)}}s(Et,"kind","parseFloat"),s(Et,"inputs",i.in(["string"])),s(Et,"outputs",i.out(["number"]));class jt extends i{run(){this.output(0).data=parseInt(this.input(0).data)}}s(jt,"kind","parseInt"),s(jt,"inputs",i.in(["number","string"])),s(jt,"outputs",i.out(["number"]));const js={[Tt.kind]:Tt,[Ot.kind]:Ot,[Nt.kind]:Nt,[Et.kind]:Et,[jt.kind]:jt};class vt extends i{run(){this.output(0).data=Object.keys(this.input(0).data)}}s(vt,"kind","objectKeys"),s(vt,"inputs",i.in(["object"])),s(vt,"outputs",i.out(["array"]));class $t extends i{run(){this.output(0).data=Object.values(this.input(0).data)}}s($t,"kind","objectValues"),s($t,"inputs",i.in(["object"])),s($t,"outputs",i.out(["array"]));const vs={[vt.kind]:vt,[$t.kind]:$t};class Ct extends i{run(){this.output(0).data=this.input(0).data+this.input(1).data}}s(Ct,"kind","addition"),s(Ct,"inputs",i.ins(2,["number"])),s(Ct,"outputs",i.out(["number"]));class Bt extends i{run(){this.input(1).data?this.output(0).data=this.input(0).data/this.input(1).data:this.output(0).clear()}}s(Bt,"kind","division"),s(Bt,"inputs",i.ins(2,["number"])),s(Bt,"outputs",i.out(["number"]));class Pt extends i{run(){this.output(0).data=this.input(0).data==this.input(1).data}}s(Pt,"kind","equality"),s(Pt,"inputs",i.ins(2)),s(Pt,"outputs",i.out(["boolean"]));class St extends i{run(){this.output(0).data=this.input(0).data<this.input(1).data}}s(St,"kind","lessThan"),s(St,"inputs",i.ins(2,["number"])),s(St,"outputs",i.out(["boolean"]));class At extends i{run(){this.output(0).data=this.input(0).data<=this.input(1).data}}s(At,"kind","lessThanOrEqual"),s(At,"inputs",i.ins(2,["number"])),s(At,"outputs",i.out(["boolean"]));class Gt extends i{run(){this.output(0).data=this.input(0).data>this.input(1).data}}s(Gt,"kind","greaterThan"),s(Gt,"inputs",i.ins(2,["number"])),s(Gt,"outputs",i.out(["boolean"]));class Ut extends i{run(){this.output(0).data=this.input(0).data>=this.input(1).data}}s(Ut,"kind","greaterThanOrEqual"),s(Ut,"inputs",i.ins(2,["number"])),s(Ut,"outputs",i.out(["boolean"]));class zt extends i{run(){this.output(0).data=this.input(0).data!=this.input(1).data}}s(zt,"kind","inequality"),s(zt,"inputs",i.ins(2)),s(zt,"outputs",i.out(["boolean"]));class Rt extends i{run(){this.output(0).data=this.input(0).data*this.input(1).data}}s(Rt,"kind","multiplication"),s(Rt,"inputs",i.ins(2,["number"])),s(Rt,"outputs",i.out(["number"]));class Jt extends i{run(){this.output(0).data=this.input(0).data-this.input(1).data}}s(Jt,"kind","subtraction"),s(Jt,"inputs",i.ins(2,["number"])),s(Jt,"outputs",i.out(["number"]));const $s={[Ct.kind]:Ct,[Bt.kind]:Bt,[Pt.kind]:Pt,[Gt.kind]:Gt,[Ut.kind]:Ut,[St.kind]:St,[At.kind]:At,[zt.kind]:zt,[Rt.kind]:Rt,[Jt.kind]:Jt};class Kt extends i{run(){this.output(0).data=this.input(0).data.length}}s(Kt,"kind","stringLength"),s(Kt,"inputs",i.in(["string"])),s(Kt,"outputs",i.out(["number"]));class Ht extends i{run(){const t=this.input(0).data,n=this.input(1).data,a=this.input(2).data;this.output(0).data=t.substring(n,a)}}s(Ht,"kind","substring"),s(Ht,"inputs",[...i.in(["string"]),...i.in(["number"],{name:"start"}),...i.in(["number"],{name:"end",optional:!0})]),s(Ht,"outputs",i.out(["string"]));const Cs={[Kt.kind]:Kt,[Ht.kind]:Ht},Bs=d(d(d(d(d(d(d(d(d(d(d(d({},bs),xs),fs),Ts),Is),Os),Ns),Es),js),vs),$s),Cs);export{Bs as nodesCatalog};
