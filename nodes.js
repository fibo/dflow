var Os=Object.defineProperty,Es=Object.defineProperties;var Ns=Object.getOwnPropertyDescriptors;var ts=Object.getOwnPropertySymbols;var cs=Object.prototype.hasOwnProperty,ps=Object.prototype.propertyIsEnumerable;var as=(a,t,i)=>t in a?Os(a,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):a[t]=i,l=(a,t)=>{for(var i in t||(t={}))cs.call(t,i)&&as(a,i,t[i]);if(ts)for(var i of ts(t))ps.call(t,i)&&as(a,i,t[i]);return a},N=(a,t)=>Es(a,Ns(t));var $=(a,t)=>{var i={};for(var e in a)cs.call(a,e)&&t.indexOf(e)<0&&(i[e]=a[e]);if(a!=null&&ts)for(var e of ts(a))t.indexOf(e)<0&&ps.call(a,e)&&(i[e]=a[e]);return i};var s=(a,t,i)=>(as(a,typeof t!="symbol"?t+"":t,i),i),us=(a,t,i)=>{if(!t.has(a))throw TypeError("Cannot "+i)};var u=(a,t,i)=>(us(a,t,"read from private field"),i?i.call(a):t.get(a)),b=(a,t,i)=>{if(t.has(a))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(a):t.set(a,i)},T=(a,t,i,e)=>(us(a,t,"write to private field"),e?e.call(a,i):t.set(a,i),i);var Z=(a,t,i)=>(us(a,t,"access private method"),i);var w,Mt,Q,R,z,F,J,U,V,I,x,h,_t,fs,Dt,ks;const j=a=>`${a} must be a string`,hs=(a,t)=>`${t} pin not found nodeId=${a}`,ls=(a,t,i)=>`${hs(a,t)} position=${i}`,gs=(a,t,i)=>`${hs(a,t)} pinId=${i}`,rs=({id:a,kind:t,outputs:i},e)=>{const r={id:a,kind:t,outputs:i==null?void 0:i.map(({id:o,data:d,name:c})=>({id:o,data:d,name:c}))};return e&&(r.error=e),r};class p{static isArray(t){return!!Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowId(t){return p.isStringNotEmpty(t)}static isObject(t){return!(typeof t!="object"||!t||Array.isArray(t))}static isNumber(t){return typeof t=="number"&&!isNaN(t)}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return p.isString(t)&&t!==""}static validate(t,i){return i.length===0?!0:i.some(e=>{switch(e){case"array":return p.isArray(t);case"boolean":return p.isBoolean(t);case"number":return p.isNumber(t);case"object":return p.isObject(t);case"string":return p.isString(t);case"DflowId":return p.isDflowId(t);default:return!1}},!0)}}class A{constructor({id:t,name:i}){s(this,"id");s(this,"name");this.id=t,this.name=i}static isDflowItem(t){if(typeof t!="object"||!t)return!1;const{id:i,name:e}=t;return p.isDflowId(i)&&(typeof e>"u"||p.isStringNotEmpty(e))}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const Lt=class extends A{constructor(t,r){var o=r,{types:i=[]}=o,e=$(o,["types"]);super(e);s(this,"kind");s(this,"types");this.kind=t,this.types=i}static isDflowPin(t){if(typeof t!="object"||!t)return!1;const r=t,{types:i}=r,e=$(r,["types"]);return A.isDflowItem(e)&&Lt.isDflowPinTypes(i)}static isDflowPinType(t){return typeof t!="string"?!1:Lt.types.includes(t)}static isDflowPinTypes(t){return Array.isArray(t)?t.every(i=>Lt.isDflowPinType(i)):!1}get hasTypeAny(){return this.types.length===0}hasType(t){return this.hasTypeAny||this.types.includes(t)}toObject(){const t=super.toObject();return this.types.length>0&&(t.types=this.types),t}};let P=Lt;s(P,"types",["string","number","boolean","object","array","DflowId"]);class ys extends P{constructor(r){var o=r,{multi:t,optional:i}=o,e=$(o,["multi","optional"]);super("input",e);b(this,w,void 0);b(this,Mt,void 0);b(this,Q,void 0);b(this,R,void 0);T(this,w,t),T(this,Mt,i)}static isDflowInput(t){if(typeof t!="object"||!t)return!1;const{id:i,types:e,optional:r,multi:o}=t;return P.isDflowPin({id:i,types:e})&&(typeof o>"u"||typeof o=="boolean")&&(typeof r>"u"||typeof r=="boolean")}get data(){var t,i;if(u(this,w)){const e=Array.from((t=u(this,R))!=null?t:[]);return e.length?e.map(r=>r.data):void 0}else return(i=u(this,Q))==null?void 0:i.data}get isConnected(){var t;return u(this,w)?Array.from((t=u(this,R))!=null?t:[]).length>0:typeof u(this,Q)>"u"}get isMulti(){return u(this,w)}get isOptional(){return u(this,Mt)}connectTo(t){const{hasTypeAny:i,types:e}=this,{types:r}=t;if(i||e.some(d=>r.includes(d)))u(this,w)?(u(this,R)||T(this,R,new Set),u(this,R).add(t)):T(this,Q,t);else throw new Error(`mismatching pinTypes, source has types [${r.join()}] and target has types [${e.join()}]`)}disconnect(){var t;u(this,w)?(t=u(this,R))==null||t.clear():T(this,Q,void 0)}toObject(){return super.toObject()}}w=new WeakMap,Mt=new WeakMap,Q=new WeakMap,R=new WeakMap;class ms extends P{constructor(e){var r=e,{data:t}=r,i=$(r,["data"]);super("output",i);b(this,z,void 0);T(this,z,t)}static isDflowOutput({id:t,data:i,types:e=[]}){return P.isDflowPin({id:t,types:e})&&p.validate(i,e)}clear(){T(this,z,void 0)}get data(){return u(this,z)}set data(t){switch(!0){case typeof t>"u":this.clear();break;case this.hasTypeAny:case(this.hasType("string")&&p.isString(t)):case(this.hasType("number")&&p.isNumber(t)):case(this.hasType("boolean")&&p.isBoolean(t)):case(this.hasType("object")&&p.isObject(t)):case(this.hasType("array")&&p.isArray(t)):case(this.hasType("DflowId")&&p.isDflowId(t)):{T(this,z,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=super.toObject();return typeof u(this,z)<"u"&&(t.data=u(this,z)),t}}z=new WeakMap;class n extends A{constructor(f,o,{isAsync:d=!1,isConstant:c=!1}={}){var y=f,{kind:t,inputs:i=[],outputs:e=[]}=y,r=$(y,["kind","inputs","outputs"]);super(r);b(this,F,new Map);b(this,J,new Map);b(this,U,[]);b(this,V,[]);s(this,"kind");s(this,"meta");s(this,"host");this.host=o,this.kind=t,this.meta={isAsync:d,isConstant:c};for(const k of i)this.newInput(k);for(const k of e)this.newOutput(k)}static input(t=[],i){if(P.isDflowPinType(t))return l({types:[t]},i);if(P.isDflowPinTypes(t))return l({types:t},i);throw new TypeError("invalid input definition")}static output(t=[],i){if(P.isDflowPinType(t))return l({types:[t]},i);if(P.isDflowPinTypes(t))return l({types:t},i);throw new TypeError("invalid output definition")}static in(t=[],i){return[l({types:t},i)]}static out(t=[],i){return[l({types:t},i)]}static isDflowNode(t){if(typeof t!="object"||!t)return!1;const d=t,{kind:i,inputs:e=[],outputs:r=[]}=d,o=$(d,["kind","inputs","outputs"]);return A.isDflowItem(o)&&p.isStringNotEmpty(i)&&e.every(c=>ys.isDflowInput(c))&&r.every(c=>ms.isDflowOutput(c))}get inputs(){return u(this,F).values()}get outputs(){return u(this,J).values()}clearOutputs(){for(const t of this.outputs)t.clear()}getInputById(t){if(typeof t!="string")throw new TypeError(j("inputId"));const i=u(this,F).get(t);if(i)return i;throw new Error(gs(this.id,"input",t))}input(t){const i=u(this,U)[t];if(!i)throw new Error(ls(this.id,"input",t));return this.getInputById(i)}getOutputById(t){if(typeof t!="string")throw new TypeError(j("outputId"));const i=u(this,J).get(t);if(i)return i;throw new Error(gs(this.id,"output",t))}output(t){const i=u(this,V)[t];if(!i)throw new Error(ls(this.id,"output",t));return this.getOutputById(i)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),u(this,F).delete(t),u(this,U).splice(u(this,U).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),u(this,J).delete(t),u(this,V).splice(u(this,V).indexOf(t),1)}newInput(t){const i=u(this,F).size,e=(d=i)=>{const c=`i${d}`;return u(this,F).has(c)?e(d+1):c},r=p.isDflowId(t.id)?t.id:e(),o=new ys(N(l({},t),{id:r}));return u(this,F).set(r,o),u(this,U).push(r),o}newOutput(t){const i=u(this,J).size,e=(d=i)=>{const c=`o${d}`;return u(this,J).has(c)?e(d+1):c},r=p.isDflowId(t.id)?t.id:e(),o=new ms(N(l({},t),{id:r}));return u(this,J).set(r,o),u(this,V).push(r),o}run(){}toObject(){const t=N(l({},super.toObject()),{kind:this.kind}),i=[],e=[];for(const r of this.inputs)i.push(r.toObject());i.length>0&&(t.inputs=i);for(const r of this.outputs)e.push(r.toObject());return e.length>0&&(t.outputs=e),t}}F=new WeakMap,J=new WeakMap,U=new WeakMap,V=new WeakMap,s(n,"kind"),s(n,"isAsync"),s(n,"isConstant"),s(n,"inputs"),s(n,"outputs");class Ts extends A{constructor(r){var o=r,{source:t,target:i}=o,e=$(o,["source","target"]);super(e);s(this,"source");s(this,"target");const[d,c]=t,[f,y]=i;if(typeof d!="string")throw new TypeError(j("sourceNodeId"));if(typeof c!="string")throw new TypeError(j("sourcePinId"));if(typeof f!="string")throw new TypeError(j("targetNodeId"));if(typeof y!="string")throw new TypeError(j("targetPinId"));this.source=t,this.target=i}static isDflowEdge(t){if(typeof t!="object"||!t)return!1;const o=t,{source:i,target:e}=o,r=$(o,["source","target"]);return!(A.isDflowItem(r)||!Array.isArray(i)||i.length!==2||p.isDflowId(i[0])||p.isDflowId(i[1])||!Array.isArray(e)||e.length!==2||p.isDflowId(e[0])||p.isDflowId(e[1]))}toObject(){return N(l({},super.toObject()),{source:this.source,target:this.target})}}const S=class extends A{constructor(){super(...arguments);b(this,I,new Map);b(this,x,new Map);s(this,"runOptions",{verbose:!1});s(this,"runStatus",null);s(this,"executionReport",null)}static childrenOfNodeId(t,i){return i.filter(({sourceId:e})=>t===e).map(({targetId:e})=>e)}static parentsOfNodeId(t,i){return i.filter(({targetId:e})=>t===e).map(({sourceId:e})=>e)}static levelOfNodeId(t,i){const e=S.parentsOfNodeId(t,i);if(e.length===0)return 0;let r=0;for(const o of e){const d=S.levelOfNodeId(o,i);r=Math.max(d,r)}return r+1}static ancestorsOfNodeId(t,i){const e=S.parentsOfNodeId(t,i);return e.length===0?[]:e.reduce((r,o,d,c)=>{const f=S.ancestorsOfNodeId(o,i),y=r.concat(f);return d===c.length-1?Array.from(new Set(c.concat(y))):y},[])}static sort(t,i){const e={};for(const r of t)e[r]=S.levelOfNodeId(r,i);return t.slice().sort((r,o)=>e[r]<=e[o]?-1:1)}get edges(){return u(this,x).values()}get nodes(){return u(this,I).values()}get nodeConnections(){return[...u(this,x).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...u(this,x).keys()]}get nodeIds(){return[...u(this,I).keys()]}get numEdges(){return u(this,x).size}get numNodes(){return u(this,I).size}addEdge(t){if(u(this,x).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);u(this,x).set(t.id,t)}addNode(t){if(u(this,I).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);u(this,I).set(t.id,t)}clear(){u(this,I).clear(),u(this,x).clear()}deleteEdge(t){u(this,x).delete(t)}deleteNode(t){u(this,I).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(j("nodeId"));const i=u(this,I).get(t);if(i)return i;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(j("edgeId"));const i=u(this,x).get(t);if(i)return i;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const i=`e${t}`;return u(this,x).has(i)?this.generateEdgeId(t+1):i}generateNodeId(t=this.numNodes){const i=`n${t}`;return u(this,I).has(i)?this.generateNodeId(t+1):i}nodeIdsInsideFunctions(){const t=[];for(const i of this.nodes)i.kind==="return"&&t.push(S.ancestorsOfNodeId(i.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){var r,o;const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const i=this.nodeIdsInsideFunctions(),e=S.sort(this.nodeIds.filter(d=>!i.includes(d)),this.nodeConnections);s:for(const d of e){const c=u(this,I).get(d);try{if(!c.meta.isConstant){let f=!1;t:for(const{id:y,data:k,types:O,isOptional:m}of c.inputs){if(m&&typeof k>"u")continue t;if(!p.validate(k,O)){f=!0,t&&((r=this.executionReport.steps)==null||r.push(rs(c.toObject(),`invalid input data nodeId=${d} inputId=${y} data=${k}`)));break t}}if(f){for(const y of c.outputs)y.clear();continue s}c.meta.isAsync?await c.run():c.run()}t&&((o=this.executionReport.steps)==null||o.push(rs(c.toObject())))}catch(f){console.error(f),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=N(l({},super.toObject()),{nodes:[],edges:[]});for(const i of this.nodes)t.nodes.push(i.toObject());for(const i of this.edges)t.edges.push(i.toObject());return t}};let H=S;I=new WeakMap,x=new WeakMap;const Y=class{constructor(t={}){b(this,h,void 0);s(this,"nodesCatalog");s(this,"context");this.nodesCatalog=l(l({},t),Ps),T(this,h,new H({id:"g1"})),this.context={}}get executionReport(){return u(this,h).executionReport}get edges(){return u(this,h).edges}get nodes(){return u(this,h).nodes}get numEdges(){return u(this,h).numEdges}get numNodes(){return u(this,h).numNodes}get nodeKinds(){return Object.keys(this.nodesCatalog)}get runStatusIsSuccess(){return u(this,h).runStatus==="success"}get runStatusIsWaiting(){return u(this,h).runStatus==="waiting"}get runStatusIsFailure(){return u(this,h).runStatus==="failure"}set verbose(t){u(this,h).runOptions.verbose=t}clearGraph(){u(this,h).clear()}connect(t,i=0){return{to:(e,r=0)=>{const o=u(this,h).generateEdgeId(),d=t.output(i),c=e.input(r);this.newEdge({id:o,source:[t.id,d.id],target:[e.id,c.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(j("edgeId"));const i=u(this,h).getEdgeById(t);if(i){const[e,r]=i.target;this.getNodeById(e).getInputById(r).disconnect(),u(this,h).deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(j("nodeId"));const i=this.getNodeById(t);if(i){for(const e of u(this,h).edges){const{source:[r],target:[o]}=e;(r===i.id||o===i.id)&&this.deleteEdge(e.id)}u(this,h).deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,i]){for(const e of this.edges){const[r,o]=e.source,[d,c]=e.target;(r===t&&o===i||d===t&&c===i)&&this.deleteEdge(e.id)}}executeFunction(t,i){var y,k;const{verbose:e}=u(this,h).runOptions,r=u(this,h).nodeConnections,o=H.childrenOfNodeId(t,r),d=[];for(const O of o){const m=this.getNodeById(O);m.kind===K.kind&&d.push(m.id)}const c=d.reduce((O,m,E,X)=>{const xs=H.ancestorsOfNodeId(m,r),ds=O.concat(xs);return E===X.length?Array.from(new Set(ds)):ds},[]),f=H.sort([...d,...c],r);for(const O of f){const m=this.getNodeById(O);try{switch(m.kind){case W.kind:{const E=m.input(0).data,X=typeof E=="number"&&!isNaN(E)?Math.max(E,0):0;m.output(0).data=i[X];break}case K.kind:return m.input(1).data;default:!m.meta.isConstant&&!m.meta.isAsync&&m.run(),e&&((k=(y=this.executionReport)==null?void 0:y.steps)==null||k.push(rs(m.toObject())))}}catch(E){console.error(E)}}}getEdgeById(t){return u(this,h).getEdgeById(t)}getNodeById(t){return u(this,h).getNodeById(t)}newNode(t){var f,y,k,O,m,E,X;const i=(f=this.nodesCatalog[t.kind])!=null?f:js,e=p.isDflowId(t.id)?t.id:u(this,h).generateNodeId(),r={isAsync:i.isAsync,isConstant:i.isConstant},o=Array.isArray(t.inputs)?Z(y=Y,_t,fs).call(y,t.inputs):Z(O=Y,_t,fs).call(O,(k=i.inputs)!=null?k:[]),d=Array.isArray(t.outputs)?Z(m=Y,Dt,ks).call(m,t.outputs):Z(X=Y,Dt,ks).call(X,(E=i.outputs)!=null?E:[]),c=new i(N(l({},t),{id:e,inputs:o,outputs:d}),this,r);return u(this,h).addNode(c),c}newEdge(t){const i=p.isDflowId(t.id)?t.id:u(this,h).generateEdgeId(),e=new Ts(N(l({},t),{id:i}));u(this,h).addEdge(e);const[r,o]=e.source,[d,c]=e.target,f=u(this,h).getNodeById(r),y=u(this,h).getNodeById(d),k=f.getOutputById(o);return y.getInputById(c).connectTo(k),e}newInput(t,i){return u(this,h).getNodeById(t).newInput(i)}newOutput(t,i){return u(this,h).getNodeById(t).newOutput(i)}toObject(){return u(this,h).toObject()}async run(){await u(this,h).run()}};let os=Y;h=new WeakMap,_t=new WeakSet,fs=function(t=[]){return t.map((i,e)=>N(l({},i),{id:p.isDflowId(i.id)?i.id:`i${e}`}))},Dt=new WeakSet,ks=function(t=[]){return t.map((i,e)=>N(l({},i),{id:p.isDflowId(i.id)?i.id:`o${e}`}))},b(os,_t),b(os,Dt);const{input:B,output:C}=n;class W extends n{}s(W,"kind","argument"),s(W,"isConstant",!0),s(W,"inputs",[B("number",{name:"position",optional:!0})]),s(W,"outputs",[C()]);class G extends n{run(){const t=this.input(0).data;p.isArray(t)?this.output(0).data=t:this.output(0).clear()}}s(G,"kind","array"),s(G,"inputs",[B()]),s(G,"outputs",[C("array")]);class q extends n{run(){const t=this.input(0).data;p.isBoolean(t)?this.output(0).data=t:this.output(0).clear()}}s(q,"kind","boolean"),s(q,"inputs",[B()]),s(q,"outputs",[C("boolean")]);class L extends n{}s(L,"kind","data"),s(L,"isConstant",!0),s(L,"outputs",[C()]);class M extends n{constructor(...t){super(...t);this.output(0).data=this.id}}s(M,"kind","function"),s(M,"isConstant",!0),s(M,"outputs",[C("DflowId",{name:"id"})]);class _ extends n{run(){this.output(0).data=typeof this.input(0).data>"u"}}s(_,"kind","isUndefined"),s(_,"inputs",[B()]),s(_,"outputs",[C("boolean")]);class D extends n{run(){const t=this.input(0).data;p.isNumber(t)?this.output(0).data=t:this.output(0).clear()}}s(D,"kind","number"),s(D,"inputs",[B()]),s(D,"outputs",[C("number")]);class tt extends n{run(){const t=this.input(0).data;p.isObject(t)?this.output(0).data=t:this.output(0).clear()}}s(tt,"kind","object"),s(tt,"inputs",[B()]),s(tt,"outputs",[C("object")]);class K extends n{}s(K,"kind","return"),s(K,"isConstant",!0),s(K,"inputs",[B("DflowId",{name:"functionId"}),B([],{name:"value"})]);class st extends n{run(){const t=this.input(0).data;p.isString(t)?this.output(0).data=t:this.output(0).clear()}}s(st,"kind","string"),s(st,"inputs",[B()]),s(st,"outputs",[C("string")]);class js extends n{}const Ps={[W.kind]:W,[G.kind]:G,[q.kind]:q,[L.kind]:L,[_.kind]:_,[D.kind]:D,[tt.kind]:tt,[M.kind]:M,[st.kind]:st,[K.kind]:K};class it extends n{run(){const t=this.input(0).data,i=this.input(1).data;this.output(0).data=t.at(i)}}s(it,"kind","arrayAt"),s(it,"inputs",[...n.in(["array"]),...n.in(["number"],{name:"index"})]),s(it,"outputs",n.out());class nt extends n{run(){this.output(0).data=this.input(0).data.filter((...t)=>this.host.executeFunction(this.input(1).data,t))}}s(nt,"kind","arrayFilter"),s(nt,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),s(nt,"outputs",n.out(["array"]));class et extends n{run(){this.output(0).data=this.input(0).data.findLastIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}s(et,"kind","arrayFindLastIndex"),s(et,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),s(et,"outputs",n.out(["number"]));class at extends n{run(){this.output(0).data=this.input(0).data.findIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}s(at,"kind","arrayFindIndex"),s(at,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),s(at,"outputs",n.out(["number"]));class ut extends n{run(){const t=this.input(0).data,i=this.input(1).data;Array.isArray(t)&&(this.output(0).data=t.includes(i))}}s(ut,"kind","arrayIncludes"),s(ut,"inputs",[...n.in(["array"],{name:"array"}),...n.in(["string"],{name:"element"})]),s(ut,"outputs",n.out(["boolean"]));class rt extends n{run(){this.output(0).data=this.input(0).data.join(this.input(1).data)}}s(rt,"kind","arrayJoin"),s(rt,"inputs",[...n.in(["array"],{name:"array"}),...n.in(["string"],{name:"separator",optional:!0})]),s(rt,"outputs",n.out(["string"]));class ot extends n{run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t.length:this.output(0).clear}}s(ot,"kind","arrayLength"),s(ot,"inputs",n.in(["array"])),s(ot,"outputs",n.out(["number"]));class dt extends n{run(){this.output(0).data=this.input(0).data.map((...t)=>this.host.executeFunction(this.input(1).data,t))}}s(dt,"kind","arrayMap"),s(dt,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),s(dt,"outputs",n.out(["array"]));class ct extends n{run(){const t=this.input(0).data.slice(),i=t.pop();this.output(0).data=i,this.output(1).data=t}}s(ct,"kind","arrayPop"),s(ct,"inputs",n.in(["array"])),s(ct,"outputs",[...n.out([],{name:"element"}),...n.out(["array"],{name:"rest"})]);class pt extends n{run(){const t=this.input(0).data.slice(),i=this.input(1).data;i&&t.push(i),this.output(0).data=t}}s(pt,"kind","arrayPush"),s(pt,"inputs",[...n.in(["array"]),...n.in([],{name:"element"})]),s(pt,"outputs",n.out(["array"]));class ht extends n{run(){const t=this.input(0).data.slice();this.output(0).data=t.reverse()}}s(ht,"kind","arrayReverse"),s(ht,"inputs",n.in(["array"])),s(ht,"outputs",n.in(["array"]));class lt extends n{run(){const t=this.input(0).data.slice(),i=t.shift();this.output(0).data=i,this.output(1).data=t}}s(lt,"kind","arrayShift"),s(lt,"inputs",n.in(["array"])),s(lt,"outputs",[...n.out([],{name:"element"}),...n.out(["array"],{name:"rest"})]);class gt extends n{run(){const t=super.input(0).data,i=super.input(1).data,e=super.input(2).data;typeof e=="number"?super.output(0).data=t.slice(i,e):super.output(0).data=t.slice(i)}}s(gt,"kind","arraySlice"),s(gt,"inputs",[...n.in(["array"]),...n.in(["number"],{name:"start"}),...n.in(["number"],{name:"end",optional:!0})]),s(gt,"outputs",n.out(["array"]));const vs={[it.kind]:it,[nt.kind]:nt,[et.kind]:et,[at.kind]:at,[ut.kind]:ut,[rt.kind]:rt,[ot.kind]:ot,[dt.kind]:dt,[ct.kind]:ct,[pt.kind]:pt,[ht.kind]:ht,[lt.kind]:lt,[gt.kind]:gt};class yt extends n{run(){this.output(0).data=this.input(0).data?this.input(1).data:this.input(2).data}}s(yt,"kind","if"),s(yt,"inputs",[...n.in([],{name:"condition"}),...n.in([],{name:"then"}),...n.in([],{name:"else"})]),s(yt,"outputs",n.out());const $s={[yt.kind]:yt};class ss extends n{run(){console.log(this.input(0).data)}}s(ss,"kind","consoleLog"),s(ss,"inputs",[...n.in([])]);const Bs={[ss.kind]:ss},bs=[...n.out(["string"]),...n.out(["number"],{name:"milliseconds"})];class mt extends n{run(){const t=this.input(0).data;if(typeof t=="string"||typeof t=="number"){const e=new Date(t),r=e.toJSON();r!==null&&(this.output(0).data=r,this.output(1).data=e.getTime())}const i=new Date;this.output(0).data=i.toJSON(),this.output(1).data=i.getTime()}}s(mt,"kind","newDate"),s(mt,"inputs",n.in(["string","number"],{optional:!0})),s(mt,"outputs",bs);class is extends n{run(){const t=Date.now();this.output(0).data=new Date(t).toJSON(),this.output(1).data=t}}s(is,"kind","now"),s(is,"outputs",bs);const Cs={[mt.kind]:mt,[is.kind]:is},{input:ns,output:Ss}=n;class ft extends n{run(){this.output(0).data=this.input(0).data&&this.input(1).data}}s(ft,"kind","and"),s(ft,"inputs",[ns("boolean"),ns("boolean")]),s(ft,"outputs",[Ss("boolean")]);class kt extends n{run(){this.output(0).data=!this.input(0).data}}s(kt,"kind","not"),s(kt,"inputs",n.in(["boolean"])),s(kt,"outputs",n.out(["boolean"]));class bt extends n{run(){var t;this.output(0).data=(t=this.input(0).data)!=null?t:this.input(1).data}}s(bt,"kind","??"),s(bt,"inputs",[...n.in(),...n.in()]),s(bt,"outputs",n.out());class It extends n{run(){this.output(0).data=this.input(0).data||this.input(1).data}}s(It,"kind","or"),s(It,"inputs",[ns("boolean"),ns("boolean")]),s(It,"outputs",n.out(["boolean"]));const ws={[ft.kind]:ft,[kt.kind]:kt,[bt.kind]:bt,[It.kind]:It},{input:Rs,output:zs}=n;class xt extends n{run(){this.output(0).data=Math.abs(this.input(0).data)}}s(xt,"kind","mathAbs"),s(xt,"inputs",n.in(["number"])),s(xt,"outputs",n.out(["number"]));class Ot extends n{run(){this.output(0).data=Math.cos(this.input(0).data)}}s(Ot,"kind","mathCos"),s(Ot,"inputs",[Rs("number")]),s(Ot,"outputs",n.out(["number"]));class Et extends n{run(){this.output(0).data=Math.cosh(this.input(0).data)}}s(Et,"kind","mathCosh"),s(Et,"inputs",n.in(["number"])),s(Et,"outputs",n.out(["number"]));class Nt extends n{run(){this.output(0).data=Math.floor(this.input(0).data)}}s(Nt,"kind","mathFloor"),s(Nt,"inputs",n.in(["number"])),s(Nt,"outputs",n.out(["number"]));class Tt extends n{run(){const t=this.input(0).data,i=Math.max(...t);isNaN(i)?this.output(0).clear():this.output(0).data=i}}s(Tt,"kind","mathMax"),s(Tt,"inputs",n.in(["array"])),s(Tt,"outputs",n.out(["number"]));class jt extends n{run(){const t=this.input(0).data,i=Math.min(...t);isNaN(i)?this.output(0).clear():this.output(0).data=i}}s(jt,"kind","mathMin"),s(jt,"inputs",n.in(["array"])),s(jt,"outputs",n.out(["number"]));class Pt extends n{}s(Pt,"kind","mathPI"),s(Pt,"isConstant",!0),s(Pt,"outputs",[zs("number",{name:"\u03C0",data:Math.PI})]);class vt extends n{run(){this.output(0).data=Math.round(this.input(0).data)}}s(vt,"kind","mathRound"),s(vt,"inputs",n.in(["number"])),s(vt,"outputs",n.out(["number"]));class $t extends n{run(){this.output(0).data=Math.sin(this.input(0).data)}}s($t,"kind","mathSin"),s($t,"inputs",n.in(["number"])),s($t,"outputs",n.out(["number"]));class Bt extends n{run(){this.output(0).data=Math.sinh(this.input(0).data)}}s(Bt,"kind","mathSinh"),s(Bt,"inputs",n.in(["number"])),s(Bt,"outputs",n.out(["number"]));const Fs={[xt.kind]:xt,[Ot.kind]:Ot,[Et.kind]:Et,[Nt.kind]:Nt,[Tt.kind]:Tt,[jt.kind]:jt,[Pt.kind]:Pt,[vt.kind]:vt,[$t.kind]:$t,[Bt.kind]:Bt};class Ct extends n{run(){this.output(0).data=Number.isFinite(this.input(0).data)}}s(Ct,"kind","isFinite"),s(Ct,"inputs",n.in(["number"])),s(Ct,"outputs",n.out(["boolean"]));class St extends n{run(){this.output(0).data=Number.isInteger(this.input(0).data)}}s(St,"kind","isInteger"),s(St,"inputs",n.in([])),s(St,"outputs",n.out(["boolean"]));class wt extends n{run(){this.output(0).data=Number.isNaN(this.input(0).data)}}s(wt,"kind","isNaN"),s(wt,"inputs",n.in([])),s(wt,"outputs",n.out(["boolean"]));class Rt extends n{run(){this.output(0).data=parseFloat(this.input(0).data)}}s(Rt,"kind","parseFloat"),s(Rt,"inputs",n.in(["string"])),s(Rt,"outputs",n.out(["number"]));class zt extends n{run(){this.output(0).data=parseInt(this.input(0).data)}}s(zt,"kind","parseInt"),s(zt,"inputs",n.in(["number","string"])),s(zt,"outputs",n.out(["number"]));const Js={[Ct.kind]:Ct,[St.kind]:St,[wt.kind]:wt,[Rt.kind]:Rt,[zt.kind]:zt};class Ft extends n{run(){this.output(0).data=Object.keys(this.input(0).data)}}s(Ft,"kind","objectKeys"),s(Ft,"inputs",n.in(["object"])),s(Ft,"outputs",n.out(["array"]));class Jt extends n{run(){this.output(0).data=Object.values(this.input(0).data)}}s(Jt,"kind","objectValues"),s(Jt,"inputs",n.in(["object"])),s(Jt,"outputs",n.out(["array"]));const As={[Ft.kind]:Ft,[Jt.kind]:Jt},{input:g,output:v}=n;class At extends n{run(){this.output(0).data=this.input(0).data+this.input(1).data}}s(At,"kind","addition"),s(At,"inputs",[g("number"),g("number",{multi:!0})]),s(At,"outputs",[v("number")]);class Wt extends n{run(){this.input(1).data?this.output(0).data=this.input(0).data/this.input(1).data:this.output(0).clear()}}s(Wt,"kind","division"),s(Wt,"inputs",[g("number"),g("number")]),s(Wt,"outputs",[v("number")]);class Kt extends n{run(){this.output(0).data=this.input(0).data==this.input(1).data}}s(Kt,"kind","equality"),s(Kt,"inputs",[g(),g()]),s(Kt,"outputs",[v("boolean")]);class Qt extends n{run(){this.output(0).data=this.input(0).data<this.input(1).data}}s(Qt,"kind","lessThan"),s(Qt,"inputs",[g("number"),g("number")]),s(Qt,"outputs",[v("boolean")]);class Ut extends n{run(){this.output(0).data=this.input(0).data<=this.input(1).data}}s(Ut,"kind","lessThanOrEqual"),s(Ut,"inputs",[g("number"),g("number")]),s(Ut,"outputs",[v("boolean")]);class Vt extends n{run(){this.output(0).data=this.input(0).data>this.input(1).data}}s(Vt,"kind","greaterThan"),s(Vt,"inputs",[g("number"),g("number")]),s(Vt,"outputs",[v("boolean")]);class Xt extends n{run(){this.output(0).data=this.input(0).data>=this.input(1).data}}s(Xt,"kind","greaterThanOrEqual"),s(Xt,"inputs",[g("number"),g("number")]),s(Xt,"outputs",[v("boolean")]);class Yt extends n{run(){this.output(0).data=this.input(0).data!=this.input(1).data}}s(Yt,"kind","inequality"),s(Yt,"inputs",[g(),g()]),s(Yt,"outputs",[v("boolean")]);class Zt extends n{run(){this.output(0).data=this.input(0).data*this.input(1).data}}s(Zt,"kind","multiplication"),s(Zt,"inputs",[g("number"),g("number")]),s(Zt,"outputs",[v("number")]);class Ht extends n{run(){this.output(0).data=this.input(0).data-this.input(1).data}}s(Ht,"kind","subtraction"),s(Ht,"inputs",[g("number"),g("number")]),s(Ht,"outputs",[v("number")]);const Ws={[At.kind]:At,[Wt.kind]:Wt,[Kt.kind]:Kt,[Vt.kind]:Vt,[Xt.kind]:Xt,[Qt.kind]:Qt,[Ut.kind]:Ut,[Yt.kind]:Yt,[Zt.kind]:Zt,[Ht.kind]:Ht},{input:es,output:Is}=n;class Gt extends n{run(){this.output(0).data=this.input(0).data.length}}s(Gt,"kind","stringLength"),s(Gt,"inputs",[es("string")]),s(Gt,"outputs",[Is("number")]);class qt extends n{run(){const t=this.input(0).data,i=this.input(1).data,e=this.input(2).data;this.output(0).data=t.substring(i,e)}}s(qt,"kind","substring"),s(qt,"inputs",[es("string"),es("number",{name:"start"}),es("number",{name:"end",optional:!0})]),s(qt,"outputs",[Is("string")]);const Ks={[qt.kind]:qt,[Gt.kind]:Gt},Qs=l(l(l(l(l(l(l(l(l(l({},vs),$s),Bs),Cs),ws),Fs),Js),As),Ws),Ks);export{Qs as nodesCatalog};
