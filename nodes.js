var Ts=Object.defineProperty,js=Object.defineProperties;var vs=Object.getOwnPropertyDescriptors;var ts=Object.getOwnPropertySymbols;var hs=Object.prototype.hasOwnProperty,ls=Object.prototype.propertyIsEnumerable;var rs=(u,t,s)=>t in u?Ts(u,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):u[t]=s,l=(u,t)=>{for(var s in t||(t={}))hs.call(t,s)&&rs(u,s,t[s]);if(ts)for(var s of ts(t))ls.call(t,s)&&rs(u,s,t[s]);return u},N=(u,t)=>js(u,vs(t));var $=(u,t)=>{var s={};for(var e in u)hs.call(u,e)&&t.indexOf(e)<0&&(s[e]=u[e]);if(u!=null&&ts)for(var e of ts(u))t.indexOf(e)<0&&ls.call(u,e)&&(s[e]=u[e]);return s};var i=(u,t,s)=>(rs(u,typeof t!="symbol"?t+"":t,s),s),os=(u,t,s)=>{if(!t.has(u))throw TypeError("Cannot "+s)};var a=(u,t,s)=>(os(u,t,"read from private field"),s?s.call(u):t.get(u)),f=(u,t,s)=>{if(t.has(u))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(u):t.set(u,s)},T=(u,t,s,e)=>(os(u,t,"write to private field"),e?e.call(u,s):t.set(u,s),s);var B=(u,t,s)=>(os(u,t,"access private method"),s);var R,qt,U,z,F,J,A,V,X,Lt,bs,Mt,Is,I,x,c,_t,xs,Dt,Os;const j=u=>`${u} must be a string`,gs=(u,t)=>`${t} pin not found nodeId=${u}`,ms=(u,t,s)=>`${gs(u,t)} position=${s}`,ys=(u,t,s)=>`${gs(u,t)} pinId=${s}`,ds=({id:u,kind:t,outputs:s},e)=>{const r={id:u,kind:t,outputs:s==null?void 0:s.map(({id:o,data:p,name:h})=>({id:o,data:p,name:h}))};return e&&(r.error=e),r};class d{static isArray(t){return!!Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowId(t){return d.isStringNotEmpty(t)}static isObject(t){return!(typeof t!="object"||!t||Array.isArray(t))}static isNumber(t){return typeof t=="number"&&!isNaN(t)}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return d.isString(t)&&t!==""}static validate(t,s){return s.length===0?!0:s.some(e=>{switch(e){case"array":return d.isArray(t);case"boolean":return d.isBoolean(t);case"number":return d.isNumber(t);case"object":return d.isObject(t);case"string":return d.isString(t);case"DflowId":return d.isDflowId(t);default:return!1}},!0)}}class W{constructor({id:t,name:s}){i(this,"id");i(this,"name");this.id=t,this.name=s}static isDflowItem(t){if(typeof t!="object"||!t)return!1;const{id:s,name:e}=t;return d.isDflowId(s)&&(typeof e>"u"||d.isStringNotEmpty(e))}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const Gt=class extends W{constructor(t,r){var o=r,{types:s=[]}=o,e=$(o,["types"]);super(e);i(this,"kind");i(this,"types");this.kind=t,this.types=s}static isDflowPin(t){if(typeof t!="object"||!t)return!1;const r=t,{types:s}=r,e=$(r,["types"]);return W.isDflowItem(e)&&Gt.isDflowPinTypes(s)}static isDflowPinType(t){return typeof t!="string"?!1:Gt.types.includes(t)}static isDflowPinTypes(t){return Array.isArray(t)?t.every(s=>Gt.isDflowPinType(s)):!1}get hasTypeAny(){return this.types.length===0}hasType(t){return this.hasTypeAny||this.types.includes(t)}toObject(){const t=super.toObject();return this.types.length>0&&(t.types=this.types),t}};let v=Gt;i(v,"types",["string","number","boolean","object","array","DflowId"]);class fs extends v{constructor(r){var o=r,{multi:t,optional:s}=o,e=$(o,["multi","optional"]);super("input",e);f(this,R,void 0);f(this,qt,void 0);f(this,U,void 0);f(this,z,void 0);T(this,R,t),T(this,qt,s)}static isDflowInput(t){if(typeof t!="object"||!t)return!1;const{id:s,types:e,optional:r,multi:o}=t;return v.isDflowPin({id:s,types:e})&&(typeof o>"u"||typeof o=="boolean")&&(typeof r>"u"||typeof r=="boolean")}get data(){var t,s;if(a(this,R)){const e=Array.from((t=a(this,z))!=null?t:[]);return e.length?e.map(r=>r.data):void 0}else return(s=a(this,U))==null?void 0:s.data}get isConnected(){var t;return a(this,R)?Array.from((t=a(this,z))!=null?t:[]).length>0:typeof a(this,U)>"u"}get isMulti(){return a(this,R)}get isOptional(){return a(this,qt)}connectTo(t){const{hasTypeAny:s,types:e}=this,{types:r}=t;if(s||e.some(p=>r.includes(p)))a(this,R)?(a(this,z)||T(this,z,new Set),a(this,z).add(t)):T(this,U,t);else throw new Error(`mismatching pinTypes, source has types [${r.join()}] and target has types [${e.join()}]`)}disconnect(){var t;a(this,R)?(t=a(this,z))==null||t.clear():T(this,U,void 0)}toObject(){return super.toObject()}}R=new WeakMap,qt=new WeakMap,U=new WeakMap,z=new WeakMap;class ks extends v{constructor(e){var r=e,{data:t}=r,s=$(r,["data"]);super("output",s);f(this,F,void 0);T(this,F,t)}static isDflowOutput({id:t,data:s,types:e=[]}){return v.isDflowPin({id:t,types:e})&&d.validate(s,e)}clear(){T(this,F,void 0)}get data(){return a(this,F)}set data(t){switch(!0){case typeof t>"u":this.clear();break;case this.hasTypeAny:case(this.hasType("string")&&d.isString(t)):case(this.hasType("number")&&d.isNumber(t)):case(this.hasType("boolean")&&d.isBoolean(t)):case(this.hasType("object")&&d.isObject(t)):case(this.hasType("array")&&d.isArray(t)):case(this.hasType("DflowId")&&d.isDflowId(t)):{T(this,F,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=super.toObject();return typeof a(this,F)<"u"&&(t.data=a(this,F)),t}}F=new WeakMap;class n extends W{constructor(k,o,{isAsync:p=!1,isConstant:h=!1}={}){var m=k,{kind:t,inputs:s=[],outputs:e=[]}=m,r=$(m,["kind","inputs","outputs"]);super(r);f(this,Lt);f(this,Mt);f(this,J,new Map);f(this,A,new Map);f(this,V,[]);f(this,X,[]);i(this,"kind");i(this,"meta");i(this,"host");this.host=o,this.kind=t,this.meta={isAsync:p,isConstant:h};for(const b of s)this.newInput(b);for(const b of e)this.newOutput(b)}static input(t=[],s){if(v.isDflowPinType(t))return l({types:[t]},s);if(v.isDflowPinTypes(t))return l({types:t},s);throw new TypeError("invalid input definition")}static output(t=[],s){if(v.isDflowPinType(t))return l({types:[t]},s);if(v.isDflowPinTypes(t))return l({types:t},s);throw new TypeError("invalid output definition")}static in(t=[],s){return[l({types:t},s)]}static out(t=[],s){return[l({types:t},s)]}static isDflowNode(t){if(typeof t!="object"||!t)return!1;const p=t,{kind:s,inputs:e=[],outputs:r=[]}=p,o=$(p,["kind","inputs","outputs"]);return W.isDflowItem(o)&&d.isStringNotEmpty(s)&&e.every(h=>fs.isDflowInput(h))&&r.every(h=>ks.isDflowOutput(h))}get inputs(){return a(this,J).values()}get outputs(){return a(this,A).values()}get numInputs(){return a(this,J).size}get numOutputs(){return a(this,A).size}clearOutputs(){for(const t of this.outputs)t.clear()}getInputById(t){if(typeof t!="string")throw new TypeError(j("inputId"));const s=a(this,J).get(t);if(s)return s;throw new Error(ys(this.id,"input",t))}input(t){const s=a(this,V)[t];if(!s)throw new Error(ms(this.id,"input",t));return this.getInputById(s)}getOutputById(t){if(typeof t!="string")throw new TypeError(j("outputId"));const s=a(this,A).get(t);if(s)return s;throw new Error(ys(this.id,"output",t))}output(t){const s=a(this,X)[t];if(!s)throw new Error(ms(this.id,"output",t));return this.getOutputById(s)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),a(this,J).delete(t),a(this,V).splice(a(this,V).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),a(this,A).delete(t),a(this,X).splice(a(this,X).indexOf(t),1)}newInput(t){const s=d.isDflowId(t.id)?t.id:B(this,Lt,bs).call(this),e=new fs(N(l({},t),{id:s}));return a(this,J).set(s,e),a(this,V).push(s),e}newOutput(t){const s=d.isDflowId(t.id)?t.id:B(this,Mt,Is).call(this),e=new ks(N(l({},t),{id:s}));return a(this,A).set(s,e),a(this,X).push(s),e}run(){}toObject(){const t=N(l({},super.toObject()),{kind:this.kind}),s=[],e=[];for(const r of this.inputs)s.push(r.toObject());s.length>0&&(t.inputs=s);for(const r of this.outputs)e.push(r.toObject());return e.length>0&&(t.outputs=e),t}}J=new WeakMap,A=new WeakMap,V=new WeakMap,X=new WeakMap,Lt=new WeakSet,bs=function(t=this.numInputs){const s=`i${t}`;return a(this,J).has(s)?B(this,Lt,bs).call(this,t+1):s},Mt=new WeakSet,Is=function(t=this.numOutputs){const s=`o${t}`;return a(this,A).has(s)?B(this,Mt,Is).call(this,t+1):s},i(n,"kind"),i(n,"isAsync"),i(n,"isConstant"),i(n,"inputs"),i(n,"outputs");class Ps extends W{constructor(r){var o=r,{source:t,target:s}=o,e=$(o,["source","target"]);super(e);i(this,"source");i(this,"target");const[p,h]=t,[k,m]=s;if(typeof p!="string")throw new TypeError(j("sourceNodeId"));if(typeof h!="string")throw new TypeError(j("sourcePinId"));if(typeof k!="string")throw new TypeError(j("targetNodeId"));if(typeof m!="string")throw new TypeError(j("targetPinId"));this.source=t,this.target=s}static isDflowEdge(t){if(typeof t!="object"||!t)return!1;const o=t,{source:s,target:e}=o,r=$(o,["source","target"]);return!(W.isDflowItem(r)||!Array.isArray(s)||s.length!==2||d.isDflowId(s[0])||d.isDflowId(s[1])||!Array.isArray(e)||e.length!==2||d.isDflowId(e[0])||d.isDflowId(e[1]))}toObject(){return N(l({},super.toObject()),{source:this.source,target:this.target})}}const w=class extends W{constructor(){super(...arguments);f(this,I,new Map);f(this,x,new Map);i(this,"runOptions",{verbose:!1});i(this,"runStatus",null);i(this,"executionReport",null)}static childrenOfNodeId(t,s){return s.filter(({sourceId:e})=>t===e).map(({targetId:e})=>e)}static parentsOfNodeId(t,s){return s.filter(({targetId:e})=>t===e).map(({sourceId:e})=>e)}static levelOfNodeId(t,s){const e=w.parentsOfNodeId(t,s);if(e.length===0)return 0;let r=0;for(const o of e){const p=w.levelOfNodeId(o,s);r=Math.max(p,r)}return r+1}static ancestorsOfNodeId(t,s){const e=w.parentsOfNodeId(t,s);return e.length===0?[]:e.reduce((r,o,p,h)=>{const k=w.ancestorsOfNodeId(o,s),m=r.concat(k);return p===h.length-1?Array.from(new Set(h.concat(m))):m},[])}static sort(t,s){const e={};for(const r of t)e[r]=w.levelOfNodeId(r,s);return t.slice().sort((r,o)=>e[r]<=e[o]?-1:1)}get edges(){return a(this,x).values()}get nodes(){return a(this,I).values()}get nodeConnections(){return[...a(this,x).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...a(this,x).keys()]}get nodeIds(){return[...a(this,I).keys()]}get numEdges(){return a(this,x).size}get numNodes(){return a(this,I).size}addEdge(t){if(a(this,x).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);a(this,x).set(t.id,t)}addNode(t){if(a(this,I).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);a(this,I).set(t.id,t)}clear(){a(this,I).clear(),a(this,x).clear()}deleteEdge(t){a(this,x).delete(t)}deleteNode(t){a(this,I).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(j("nodeId"));const s=a(this,I).get(t);if(s)return s;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(j("edgeId"));const s=a(this,x).get(t);if(s)return s;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const s=`e${t}`;return a(this,x).has(s)?this.generateEdgeId(t+1):s}generateNodeId(t=this.numNodes){const s=`n${t}`;return a(this,I).has(s)?this.generateNodeId(t+1):s}nodeIdsInsideFunctions(){const t=[];for(const s of this.nodes)s.kind==="return"&&t.push(w.ancestorsOfNodeId(s.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){var r,o;const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const s=this.nodeIdsInsideFunctions(),e=w.sort(this.nodeIds.filter(p=>!s.includes(p)),this.nodeConnections);s:for(const p of e){const h=a(this,I).get(p);try{if(!h.meta.isConstant){let k=!1;t:for(const{id:m,data:b,types:O,isOptional:y}of h.inputs){if(y&&typeof b>"u")continue t;if(!d.validate(b,O)){k=!0,t&&((r=this.executionReport.steps)==null||r.push(ds(h.toObject(),`invalid input data nodeId=${p} inputId=${m} data=${b}`)));break t}}if(k){for(const m of h.outputs)m.clear();continue s}h.meta.isAsync?await h.run():h.run()}t&&((o=this.executionReport.steps)==null||o.push(ds(h.toObject())))}catch(k){console.error(k),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=N(l({},super.toObject()),{nodes:[],edges:[]});for(const s of this.nodes)t.nodes.push(s.toObject());for(const s of this.edges)t.edges.push(s.toObject());return t}};let H=w;I=new WeakMap,x=new WeakMap;const Z=class{constructor(t={}){f(this,c,void 0);i(this,"nodesCatalog");i(this,"context");this.nodesCatalog=l(l({},t),Bs),T(this,c,new H({id:"g1"})),this.context={}}get executionReport(){return a(this,c).executionReport}get edges(){return a(this,c).edges}get nodes(){return a(this,c).nodes}get numEdges(){return a(this,c).numEdges}get numNodes(){return a(this,c).numNodes}get nodeKinds(){return Object.keys(this.nodesCatalog)}get runStatusIsSuccess(){return a(this,c).runStatus==="success"}get runStatusIsWaiting(){return a(this,c).runStatus==="waiting"}get runStatusIsFailure(){return a(this,c).runStatus==="failure"}set verbose(t){a(this,c).runOptions.verbose=t}clearGraph(){a(this,c).clear()}connect(t,s=0){return{to:(e,r=0)=>{const o=a(this,c).generateEdgeId(),p=t.output(s),h=e.input(r);this.newEdge({id:o,source:[t.id,p.id],target:[e.id,h.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(j("edgeId"));const s=a(this,c).getEdgeById(t);if(s){const[e,r]=s.target;this.getNodeById(e).getInputById(r).disconnect(),a(this,c).deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(j("nodeId"));const s=this.getNodeById(t);if(s){for(const e of a(this,c).edges){const{source:[r],target:[o]}=e;(r===s.id||o===s.id)&&this.deleteEdge(e.id)}a(this,c).deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,s]){for(const e of this.edges){const[r,o]=e.source,[p,h]=e.target;(r===t&&o===s||p===t&&h===s)&&this.deleteEdge(e.id)}}executeFunction(t,s){var m,b;const{verbose:e}=a(this,c).runOptions,r=a(this,c).nodeConnections,o=H.childrenOfNodeId(t,r),p=[];for(const O of o){const y=this.getNodeById(O);y.kind===Q.kind&&p.push(y.id)}const h=p.reduce((O,y,E,Y)=>{const Ns=H.ancestorsOfNodeId(y,r),ps=O.concat(Ns);return E===Y.length?Array.from(new Set(ps)):ps},[]),k=H.sort([...p,...h],r);for(const O of k){const y=this.getNodeById(O);try{switch(y.kind){case K.kind:{const E=y.input(0).data,Y=typeof E=="number"&&!isNaN(E)?Math.max(E,0):0;y.output(0).data=s[Y];break}case Q.kind:return y.input(1).data;default:!y.meta.isConstant&&!y.meta.isAsync&&y.run(),e&&((b=(m=this.executionReport)==null?void 0:m.steps)==null||b.push(ds(y.toObject())))}}catch(E){console.error(E)}}}getEdgeById(t){return a(this,c).getEdgeById(t)}getNodeById(t){return a(this,c).getNodeById(t)}newNode(t){var k,m,b,O,y,E,Y;const s=(k=this.nodesCatalog[t.kind])!=null?k:$s,e=d.isDflowId(t.id)?t.id:a(this,c).generateNodeId(),r={isAsync:s.isAsync,isConstant:s.isConstant},o=Array.isArray(t.inputs)?B(m=Z,_t,xs).call(m,t.inputs):B(O=Z,_t,xs).call(O,(b=s.inputs)!=null?b:[]),p=Array.isArray(t.outputs)?B(y=Z,Dt,Os).call(y,t.outputs):B(Y=Z,Dt,Os).call(Y,(E=s.outputs)!=null?E:[]),h=new s(N(l({},t),{id:e,inputs:o,outputs:p}),this,r);return a(this,c).addNode(h),h}newEdge(t){const s=d.isDflowId(t.id)?t.id:a(this,c).generateEdgeId(),e=new Ps(N(l({},t),{id:s}));a(this,c).addEdge(e);const[r,o]=e.source,[p,h]=e.target,k=a(this,c).getNodeById(r),m=a(this,c).getNodeById(p),b=k.getOutputById(o);return m.getInputById(h).connectTo(b),e}newInput(t,s){return a(this,c).getNodeById(t).newInput(s)}newOutput(t,s){return a(this,c).getNodeById(t).newOutput(s)}toObject(){return a(this,c).toObject()}async run(){await a(this,c).run()}};let cs=Z;c=new WeakMap,_t=new WeakSet,xs=function(t=[]){return t.map((s,e)=>N(l({},s),{id:d.isDflowId(s.id)?s.id:`i${e}`}))},Dt=new WeakSet,Os=function(t=[]){return t.map((s,e)=>N(l({},s),{id:d.isDflowId(s.id)?s.id:`o${e}`}))},f(cs,_t),f(cs,Dt);const{input:C,output:S}=n;class K extends n{}i(K,"kind","argument"),i(K,"isConstant",!0),i(K,"inputs",[C("number",{name:"position",optional:!0})]),i(K,"outputs",[S()]);class G extends n{run(){const t=this.input(0).data;d.isArray(t)?this.output(0).data=t:this.output(0).clear()}}i(G,"kind","array"),i(G,"inputs",[C()]),i(G,"outputs",[S("array")]);class q extends n{run(){const t=this.input(0).data;d.isBoolean(t)?this.output(0).data=t:this.output(0).clear()}}i(q,"kind","boolean"),i(q,"inputs",[C()]),i(q,"outputs",[S("boolean")]);class L extends n{}i(L,"kind","data"),i(L,"isConstant",!0),i(L,"outputs",[S()]);class M extends n{constructor(...t){super(...t);this.output(0).data=this.id}}i(M,"kind","function"),i(M,"isConstant",!0),i(M,"outputs",[S("DflowId",{name:"id"})]);class _ extends n{run(){this.output(0).data=typeof this.input(0).data>"u"}}i(_,"kind","isUndefined"),i(_,"inputs",[C()]),i(_,"outputs",[S("boolean")]);class D extends n{run(){const t=this.input(0).data;d.isNumber(t)?this.output(0).data=t:this.output(0).clear()}}i(D,"kind","number"),i(D,"inputs",[C()]),i(D,"outputs",[S("number")]);class tt extends n{run(){const t=this.input(0).data;d.isObject(t)?this.output(0).data=t:this.output(0).clear()}}i(tt,"kind","object"),i(tt,"inputs",[C()]),i(tt,"outputs",[S("object")]);class Q extends n{}i(Q,"kind","return"),i(Q,"isConstant",!0),i(Q,"inputs",[C("DflowId",{name:"functionId"}),C([],{name:"value"})]);class st extends n{run(){const t=this.input(0).data;d.isString(t)?this.output(0).data=t:this.output(0).clear()}}i(st,"kind","string"),i(st,"inputs",[C()]),i(st,"outputs",[S("string")]);class $s extends n{}const Bs={[K.kind]:K,[G.kind]:G,[q.kind]:q,[L.kind]:L,[_.kind]:_,[D.kind]:D,[tt.kind]:tt,[M.kind]:M,[st.kind]:st,[Q.kind]:Q};class it extends n{run(){const t=this.input(0).data,s=this.input(1).data;this.output(0).data=t.at(s)}}i(it,"kind","arrayAt"),i(it,"inputs",[...n.in(["array"]),...n.in(["number"],{name:"index"})]),i(it,"outputs",n.out());class nt extends n{run(){this.output(0).data=this.input(0).data.filter((...t)=>this.host.executeFunction(this.input(1).data,t))}}i(nt,"kind","arrayFilter"),i(nt,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),i(nt,"outputs",n.out(["array"]));class et extends n{run(){this.output(0).data=this.input(0).data.findLastIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}i(et,"kind","arrayFindLastIndex"),i(et,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),i(et,"outputs",n.out(["number"]));class ut extends n{run(){this.output(0).data=this.input(0).data.findIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}i(ut,"kind","arrayFindIndex"),i(ut,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),i(ut,"outputs",n.out(["number"]));class at extends n{run(){const t=this.input(0).data,s=this.input(1).data;Array.isArray(t)&&(this.output(0).data=t.includes(s))}}i(at,"kind","arrayIncludes"),i(at,"inputs",[...n.in(["array"],{name:"array"}),...n.in(["string"],{name:"element"})]),i(at,"outputs",n.out(["boolean"]));class rt extends n{run(){this.output(0).data=this.input(0).data.join(this.input(1).data)}}i(rt,"kind","arrayJoin"),i(rt,"inputs",[...n.in(["array"],{name:"array"}),...n.in(["string"],{name:"separator",optional:!0})]),i(rt,"outputs",n.out(["string"]));class ot extends n{run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t.length:this.output(0).clear}}i(ot,"kind","arrayLength"),i(ot,"inputs",n.in(["array"])),i(ot,"outputs",n.out(["number"]));class dt extends n{run(){this.output(0).data=this.input(0).data.map((...t)=>this.host.executeFunction(this.input(1).data,t))}}i(dt,"kind","arrayMap"),i(dt,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),i(dt,"outputs",n.out(["array"]));class ct extends n{run(){const t=this.input(0).data.slice(),s=t.pop();this.output(0).data=s,this.output(1).data=t}}i(ct,"kind","arrayPop"),i(ct,"inputs",n.in(["array"])),i(ct,"outputs",[...n.out([],{name:"element"}),...n.out(["array"],{name:"rest"})]);class pt extends n{run(){const t=this.input(0).data.slice(),s=this.input(1).data;s&&t.push(s),this.output(0).data=t}}i(pt,"kind","arrayPush"),i(pt,"inputs",[...n.in(["array"]),...n.in([],{name:"element"})]),i(pt,"outputs",n.out(["array"]));class ht extends n{run(){const t=this.input(0).data.slice();this.output(0).data=t.reverse()}}i(ht,"kind","arrayReverse"),i(ht,"inputs",n.in(["array"])),i(ht,"outputs",n.in(["array"]));class lt extends n{run(){const t=this.input(0).data.slice(),s=t.shift();this.output(0).data=s,this.output(1).data=t}}i(lt,"kind","arrayShift"),i(lt,"inputs",n.in(["array"])),i(lt,"outputs",[...n.out([],{name:"element"}),...n.out(["array"],{name:"rest"})]);class gt extends n{run(){const t=super.input(0).data,s=super.input(1).data,e=super.input(2).data;typeof e=="number"?super.output(0).data=t.slice(s,e):super.output(0).data=t.slice(s)}}i(gt,"kind","arraySlice"),i(gt,"inputs",[...n.in(["array"]),...n.in(["number"],{name:"start"}),...n.in(["number"],{name:"end",optional:!0})]),i(gt,"outputs",n.out(["array"]));const Cs={[it.kind]:it,[nt.kind]:nt,[et.kind]:et,[ut.kind]:ut,[at.kind]:at,[rt.kind]:rt,[ot.kind]:ot,[dt.kind]:dt,[ct.kind]:ct,[pt.kind]:pt,[ht.kind]:ht,[lt.kind]:lt,[gt.kind]:gt};class mt extends n{run(){this.output(0).data=this.input(0).data?this.input(1).data:this.input(2).data}}i(mt,"kind","if"),i(mt,"inputs",[...n.in([],{name:"condition"}),...n.in([],{name:"then"}),...n.in([],{name:"else"})]),i(mt,"outputs",n.out());const Ss={[mt.kind]:mt};class ss extends n{run(){console.log(this.input(0).data)}}i(ss,"kind","consoleLog"),i(ss,"inputs",[...n.in([])]);const ws={[ss.kind]:ss},Es=[...n.out(["string"]),...n.out(["number"],{name:"milliseconds"})];class yt extends n{run(){const t=this.input(0).data;if(typeof t=="string"||typeof t=="number"){const e=new Date(t),r=e.toJSON();r!==null&&(this.output(0).data=r,this.output(1).data=e.getTime())}const s=new Date;this.output(0).data=s.toJSON(),this.output(1).data=s.getTime()}}i(yt,"kind","newDate"),i(yt,"inputs",n.in(["string","number"],{optional:!0})),i(yt,"outputs",Es);class is extends n{run(){const t=Date.now();this.output(0).data=new Date(t).toJSON(),this.output(1).data=t}}i(is,"kind","now"),i(is,"outputs",Es);const Rs={[yt.kind]:yt,[is.kind]:is},{input:ns,output:zs}=n;class ft extends n{run(){this.output(0).data=this.input(0).data&&this.input(1).data}}i(ft,"kind","and"),i(ft,"inputs",[ns("boolean"),ns("boolean")]),i(ft,"outputs",[zs("boolean")]);class kt extends n{run(){this.output(0).data=!this.input(0).data}}i(kt,"kind","not"),i(kt,"inputs",n.in(["boolean"])),i(kt,"outputs",n.out(["boolean"]));class bt extends n{run(){var t;this.output(0).data=(t=this.input(0).data)!=null?t:this.input(1).data}}i(bt,"kind","??"),i(bt,"inputs",[...n.in(),...n.in()]),i(bt,"outputs",n.out());class It extends n{run(){this.output(0).data=this.input(0).data||this.input(1).data}}i(It,"kind","or"),i(It,"inputs",[ns("boolean"),ns("boolean")]),i(It,"outputs",n.out(["boolean"]));const Fs={[ft.kind]:ft,[kt.kind]:kt,[bt.kind]:bt,[It.kind]:It},{input:Js,output:As}=n;class xt extends n{run(){this.output(0).data=Math.abs(this.input(0).data)}}i(xt,"kind","mathAbs"),i(xt,"inputs",n.in(["number"])),i(xt,"outputs",n.out(["number"]));class Ot extends n{run(){this.output(0).data=Math.cos(this.input(0).data)}}i(Ot,"kind","mathCos"),i(Ot,"inputs",[Js("number")]),i(Ot,"outputs",n.out(["number"]));class Et extends n{run(){this.output(0).data=Math.cosh(this.input(0).data)}}i(Et,"kind","mathCosh"),i(Et,"inputs",n.in(["number"])),i(Et,"outputs",n.out(["number"]));class Nt extends n{run(){this.output(0).data=Math.floor(this.input(0).data)}}i(Nt,"kind","mathFloor"),i(Nt,"inputs",n.in(["number"])),i(Nt,"outputs",n.out(["number"]));class Tt extends n{run(){const t=this.input(0).data,s=Math.max(...t);isNaN(s)?this.output(0).clear():this.output(0).data=s}}i(Tt,"kind","mathMax"),i(Tt,"inputs",n.in(["array"])),i(Tt,"outputs",n.out(["number"]));class jt extends n{run(){const t=this.input(0).data,s=Math.min(...t);isNaN(s)?this.output(0).clear():this.output(0).data=s}}i(jt,"kind","mathMin"),i(jt,"inputs",n.in(["array"])),i(jt,"outputs",n.out(["number"]));class vt extends n{}i(vt,"kind","mathPI"),i(vt,"isConstant",!0),i(vt,"outputs",[As("number",{name:"\u03C0",data:Math.PI})]);class Pt extends n{run(){this.output(0).data=Math.round(this.input(0).data)}}i(Pt,"kind","mathRound"),i(Pt,"inputs",n.in(["number"])),i(Pt,"outputs",n.out(["number"]));class $t extends n{run(){this.output(0).data=Math.sin(this.input(0).data)}}i($t,"kind","mathSin"),i($t,"inputs",n.in(["number"])),i($t,"outputs",n.out(["number"]));class Bt extends n{run(){this.output(0).data=Math.sinh(this.input(0).data)}}i(Bt,"kind","mathSinh"),i(Bt,"inputs",n.in(["number"])),i(Bt,"outputs",n.out(["number"]));const Ws={[xt.kind]:xt,[Ot.kind]:Ot,[Et.kind]:Et,[Nt.kind]:Nt,[Tt.kind]:Tt,[jt.kind]:jt,[vt.kind]:vt,[Pt.kind]:Pt,[$t.kind]:$t,[Bt.kind]:Bt};class Ct extends n{run(){this.output(0).data=Number.isFinite(this.input(0).data)}}i(Ct,"kind","isFinite"),i(Ct,"inputs",n.in(["number"])),i(Ct,"outputs",n.out(["boolean"]));class St extends n{run(){this.output(0).data=Number.isInteger(this.input(0).data)}}i(St,"kind","isInteger"),i(St,"inputs",n.in([])),i(St,"outputs",n.out(["boolean"]));class wt extends n{run(){this.output(0).data=Number.isNaN(this.input(0).data)}}i(wt,"kind","isNaN"),i(wt,"inputs",n.in([])),i(wt,"outputs",n.out(["boolean"]));class Rt extends n{run(){this.output(0).data=parseFloat(this.input(0).data)}}i(Rt,"kind","parseFloat"),i(Rt,"inputs",n.in(["string"])),i(Rt,"outputs",n.out(["number"]));class zt extends n{run(){this.output(0).data=parseInt(this.input(0).data)}}i(zt,"kind","parseInt"),i(zt,"inputs",n.in(["number","string"])),i(zt,"outputs",n.out(["number"]));const Ks={[Ct.kind]:Ct,[St.kind]:St,[wt.kind]:wt,[Rt.kind]:Rt,[zt.kind]:zt};class Ft extends n{run(){this.output(0).data=Object.keys(this.input(0).data)}}i(Ft,"kind","objectKeys"),i(Ft,"inputs",n.in(["object"])),i(Ft,"outputs",n.out(["array"]));class Jt extends n{run(){this.output(0).data=Object.values(this.input(0).data)}}i(Jt,"kind","objectValues"),i(Jt,"inputs",n.in(["object"])),i(Jt,"outputs",n.out(["array"]));const Qs={[Ft.kind]:Ft,[Jt.kind]:Jt},{input:g,output:P}=n;class At extends n{run(){this.output(0).data=this.input(0).data+this.input(1).data}}i(At,"kind","addition"),i(At,"inputs",[g("number"),g("number",{multi:!0})]),i(At,"outputs",[P("number")]);class Wt extends n{run(){this.input(1).data?this.output(0).data=this.input(0).data/this.input(1).data:this.output(0).clear()}}i(Wt,"kind","division"),i(Wt,"inputs",[g("number"),g("number")]),i(Wt,"outputs",[P("number")]);class Kt extends n{run(){this.output(0).data=this.input(0).data==this.input(1).data}}i(Kt,"kind","equality"),i(Kt,"inputs",[g(),g()]),i(Kt,"outputs",[P("boolean")]);class Qt extends n{run(){this.output(0).data=this.input(0).data<this.input(1).data}}i(Qt,"kind","lessThan"),i(Qt,"inputs",[g("number"),g("number")]),i(Qt,"outputs",[P("boolean")]);class Ut extends n{run(){this.output(0).data=this.input(0).data<=this.input(1).data}}i(Ut,"kind","lessThanOrEqual"),i(Ut,"inputs",[g("number"),g("number")]),i(Ut,"outputs",[P("boolean")]);class Vt extends n{run(){this.output(0).data=this.input(0).data>this.input(1).data}}i(Vt,"kind","greaterThan"),i(Vt,"inputs",[g("number"),g("number")]),i(Vt,"outputs",[P("boolean")]);class Xt extends n{run(){this.output(0).data=this.input(0).data>=this.input(1).data}}i(Xt,"kind","greaterThanOrEqual"),i(Xt,"inputs",[g("number"),g("number")]),i(Xt,"outputs",[P("boolean")]);class Yt extends n{run(){this.output(0).data=this.input(0).data!=this.input(1).data}}i(Yt,"kind","inequality"),i(Yt,"inputs",[g(),g()]),i(Yt,"outputs",[P("boolean")]);class Zt extends n{run(){this.output(0).data=this.input(0).data*this.input(1).data}}i(Zt,"kind","multiplication"),i(Zt,"inputs",[g("number"),g("number")]),i(Zt,"outputs",[P("number")]);class Ht extends n{run(){this.output(0).data=this.input(0).data-this.input(1).data}}i(Ht,"kind","subtraction"),i(Ht,"inputs",[g("number"),g("number")]),i(Ht,"outputs",[P("number")]);const Us={[At.kind]:At,[Wt.kind]:Wt,[Kt.kind]:Kt,[Vt.kind]:Vt,[Xt.kind]:Xt,[Qt.kind]:Qt,[Ut.kind]:Ut,[Yt.kind]:Yt,[Zt.kind]:Zt,[Ht.kind]:Ht},{input:es,output:Vs}=n;class us extends n{run(){this.output(0).data=this.input(0).data.length}}i(us,"kind","stringLength"),i(us,"inputs",[es("string")]),i(us,"outputs",[Vs("number")]);class as extends n{run(){const t=this.input(0).data,s=this.input(1).data,e=this.input(2).data;this.output(0).data=t.substring(s,e)}}i(as,"kind","substring"),i(as,"inputs",[es("string"),es("number",{name:"start"}),es("number",{name:"end",optional:!0})]),i(as,"outputs",n.out(["string"]));const Xs={DflowNodeStringLength:us,DflowNodeSubstring:as},Ys=Object.values(Xs).reduce((u,t)=>l({[t.kind]:t},u),{}),Zs=l(l(l(l(l(l(l(l(l(l({},Cs),Ss),ws),Rs),Fs),Ws),Ks),Qs),Us),Ys);export{Zs as nodesCatalog};
