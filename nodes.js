var hs=Object.defineProperty,ls=Object.defineProperties;var ys=Object.getOwnPropertyDescriptors;var Qt=Object.getOwnPropertySymbols;var Dt=Object.prototype.hasOwnProperty,ts=Object.prototype.propertyIsEnumerable;var qt=(e,t,n)=>t in e?hs(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,c=(e,t)=>{for(var n in t||(t={}))Dt.call(t,n)&&qt(e,n,t[n]);if(Qt)for(var n of Qt(t))ts.call(t,n)&&qt(e,n,t[n]);return e},b=(e,t)=>ls(e,ys(t));var f=(e,t)=>{var n={};for(var a in e)Dt.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(e!=null&&Qt)for(var a of Qt(e))t.indexOf(a)<0&&ts.call(e,a)&&(n[a]=e[a]);return n};var i=(e,t,n)=>(qt(e,typeof t!="symbol"?t+"":t,n),n),Mt=(e,t,n)=>{if(!t.has(e))throw TypeError("Cannot "+n)};var u=(e,t,n)=>(Mt(e,t,"read from private field"),n?n.call(e):t.get(e)),m=(e,t,n)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,n)},E=(e,t,n,a)=>(Mt(e,t,"write to private field"),a?a.call(e,n):t.set(e,n),n);var A=(e,t,n)=>(Mt(e,t,"access private method"),n);var $,Rt,I,T,O,C,S,Jt,Kt,us,Ft,rs,k,g;const j=e=>`${e} must be a string`,ss=e=>`${e} must be a number`,is=(e,t)=>`${t} pin not found nodeId=${e}`,ns=(e,t,n)=>`${is(e,t)} position=${n}`,es=(e,t,n)=>`${is(e,t)} pinId=${n}`,as=({id:e,kind:t,outputs:n})=>({id:e,kind:t,outputs:n==null?void 0:n.map(({id:a,data:r,name:d})=>({id:a,data:r,name:d}))});class o{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowGraph(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&Array.isArray(t.nodes)&&Array.isArray(t.edges)&&cs.isDflowGraph(t)}static isDflowId(t){return o.isStringNotEmpty(t)}static isDflowType(t){return typeof t=="string"&&N.types.includes(t)}static isObject(t){return!o.isUndefined(t)&&!o.isNull(t)&&!o.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return o.isString(t)&&t.length>0}static isUndefined(t){return typeof t>"u"}static validate(t,n){return n.length===0?!0:n.some(a=>{switch(a){case"array":return o.isArray(t);case"boolean":return o.isBoolean(t);case"null":return o.isNull(t);case"number":return o.isNumber(t);case"object":return o.isObject(t);case"string":return o.isString(t);case"DflowGraph":return o.isDflowGraph(t);case"DflowId":return o.isDflowId(t);case"DflowType":return o.isDflowType(t);default:return!1}},!0)}}class v{constructor({id:t,name:n}){i(this,"id");i(this,"name");this.id=t,this.name=n}static isDflowItem({id:t,name:n}){return o.isDflowId(t)&&(o.isUndefined(n)||o.isStringNotEmpty(n))}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const Yt=class extends v{constructor(t,r){var d=r,{types:n=[]}=d,a=f(d,["types"]);super(a);i(this,"kind");i(this,"types");this.kind=t,this.types=n}static isDflowPin(a){var r=a,{types:t=[]}=r,n=f(r,["types"]);return v.isDflowItem(n)&&t.every(d=>Yt.isDflowPinType(d))}static isDflowPinType(t){Yt.types.includes(t)}get hasTypeAny(){return this.types.length===0}get hasTypeDflowId(){return this.hasTypeAny||this.types.includes("DflowId")}get hasTypeDflowGraph(){return this.hasTypeAny||this.types.includes("DflowGraph")}get hasTypeDflowType(){return this.hasTypeAny||this.types.includes("DflowType")}get hasTypeString(){return this.hasTypeAny||this.types.includes("string")}get hasTypeNumber(){return this.hasTypeAny||this.types.includes("number")}get hasTypeBoolean(){return this.hasTypeAny||this.types.includes("boolean")}get hasTypeNull(){return this.hasTypeAny||this.types.includes("null")}get hasTypeObject(){return this.hasTypeAny||this.types.includes("object")}get hasTypeArray(){return this.hasTypeAny||this.types.includes("array")}addType(t){this.types.push(t)}removeType(t){this.types.splice(this.types.indexOf(t),1)}};let N=Yt;i(N,"types",["string","number","boolean","null","object","array","DflowId","DflowGraph","DflowType"]);class Lt extends N{constructor(a){var r=a,{optional:t}=r,n=f(r,["optional"]);super("input",n);m(this,$,void 0);m(this,Rt,void 0);E(this,Rt,t)}static isDflowInput({id:t,types:n}){return N.isDflowPin({id:t,types:n})}get data(){var t;return(t=u(this,$))==null?void 0:t.data}get isConnected(){return typeof u(this,$)>"u"}get isOptional(){return u(this,Rt)}connectTo(t){const{hasTypeAny:n,types:a}=this,{types:r}=t;if(n||a.some(d=>r.includes(d)))E(this,$,t);else throw new Error(`mismatching pinTypes, source has types [${r.join()}] and target has types [${a.join()}]`)}disconnect(){E(this,$,void 0)}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}$=new WeakMap,Rt=new WeakMap;class wt extends N{constructor(a){var r=a,{data:t}=r,n=f(r,["data"]);super("output",n);m(this,I,void 0);E(this,I,t)}static isDflowOutput({id:t,data:n,types:a=[]}){return N.isDflowPin({id:t,types:a})&&o.validate(n,a)}clear(){E(this,I,void 0)}get data(){return u(this,I)}set data(t){switch(!0){case o.isUndefined(t):this.clear();break;case this.hasTypeAny:case(o.isDflowGraph(t)&&this.hasTypeDflowGraph):case(o.isDflowId(t)&&this.hasTypeDflowId):case(o.isString(t)&&this.hasTypeString):case(o.isNumber(t)&&this.hasTypeNumber):case(o.isBoolean(t)&&this.hasTypeBoolean):case(o.isNull(t)&&this.hasTypeNull):case(o.isObject(t)&&this.hasTypeObject):case(o.isArray(t)&&this.hasTypeArray):{E(this,I,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=c({},super.toObject());return o.isUndefined(u(this,I))||(t.data=u(this,I)),this.types.length>0&&(t.types=this.types),t}}I=new WeakMap;const Zt=class extends v{constructor(y,d,{isAsync:h=!1,isConstant:p=!1,label:l}={}){var Ht=y,{kind:t,inputs:n=[],outputs:a=[]}=Ht,r=f(Ht,["kind","inputs","outputs"]);super(r);m(this,Kt);m(this,Ft);m(this,T,new Map);m(this,O,new Map);m(this,C,[]);m(this,S,[]);m(this,Jt,void 0);i(this,"kind");i(this,"meta");i(this,"host");E(this,Jt,l),this.host=d,this.kind=t,this.meta={isAsync:h,isConstant:p};for(const P of n)this.newInput(P);for(const P of a)this.newOutput(P);this.onCreate()}static generateInputIds(t=[]){return t.map((n,a)=>b(c({},n),{id:`i${a}`}))}static generateOutputIds(t=[]){return t.map((n,a)=>b(c({},n),{id:`o${a}`}))}static in(t=[],n){return[c({types:t},n)]}static ins(t,n=[]){return Array(t).fill(Zt.in(n)).flat()}static out(t=[],n){return[c({types:t},n)]}static outs(t,n=[]){return Array(t).fill(Zt.out(n)).flat()}static outputNumber(t){return b(c({},t),{types:["number"]})}static isDflowNode(d){var h=d,{kind:t,inputs:n=[],outputs:a=[]}=h,r=f(h,["kind","inputs","outputs"]);return v.isDflowItem(r)&&o.isStringNotEmpty(t)&&n.every(p=>Lt.isDflowInput(p))&&a.every(p=>wt.isDflowOutput(p))}get label(){return u(this,Jt)||this.kind}get inputs(){return u(this,T).values()}get outputs(){return u(this,O).values()}get numInputs(){return u(this,T).size}get numOutputs(){return u(this,O).size}clearOutputs(){for(const t of this.outputs)t.clear()}getInputById(t){if(typeof t!="string")throw new TypeError(j("inputId"));const n=u(this,T).get(t);if(n instanceof Lt)return n;throw new Error(es(this.id,"input",t))}input(t){if(typeof t!="number")throw new TypeError(ss("position"));const n=u(this,C)[t];if(o.isUndefined(n))throw new Error(ns(this.id,"input",t));return this.getInputById(n)}getOutputById(t){if(typeof t!="string")throw new TypeError(j("outputId"));const n=u(this,O).get(t);if(n instanceof wt)return n;throw new Error(es(this.id,"output",t))}output(t){if(typeof t!="number")throw new TypeError(ss("position"));const n=u(this,S)[t];if(o.isUndefined(n))throw new Error(ns(this.id,"output",t));return this.getOutputById(n)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),u(this,T).delete(t),u(this,C).splice(u(this,C).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),u(this,O).delete(t),u(this,S).splice(u(this,S).indexOf(t),1)}onCreate(){}newInput(t){const n=o.isDflowId(t.id)?t.id:A(this,Kt,us).call(this),a=new Lt(b(c({},t),{id:n}));return u(this,T).set(n,a),u(this,C).push(n),a}newOutput(t){const n=o.isDflowId(t.id)?t.id:A(this,Ft,rs).call(this),a=new wt(b(c({},t),{id:n}));return u(this,O).set(n,a),u(this,S).push(n),a}run(){}toObject(){const t=b(c({},super.toObject()),{kind:this.kind}),n=[],a=[];for(const r of this.inputs)n.push(r.toObject());n.length>0&&(t.inputs=n);for(const r of this.outputs)a.push(r.toObject());return a.length>0&&(t.outputs=a),t}};let s=Zt;T=new WeakMap,O=new WeakMap,C=new WeakMap,S=new WeakMap,Jt=new WeakMap,Kt=new WeakSet,us=function(t=this.numInputs){const n=`i${t}`;return u(this,T).has(n)?A(this,Kt,us).call(this,t+1):n},Ft=new WeakSet,rs=function(t=this.numOutputs){const n=`o${t}`;return u(this,O).has(n)?A(this,Ft,rs).call(this,t+1):n},i(s,"kind"),i(s,"isAsync"),i(s,"isConstant"),i(s,"label"),i(s,"inputs"),i(s,"outputs");const _t=class extends s{constructor(t,n){super(b(c({},t),{kind:_t.kind}),n)}run(){}};let os=_t;i(os,"kind","Unknown");class ds extends v{constructor(r){var d=r,{source:t,target:n}=d,a=f(d,["source","target"]);super(a);i(this,"source");i(this,"target");const[h,p]=t,[l,y]=n;if(typeof h!="string")throw new TypeError(j("sourceNodeId"));if(typeof p!="string")throw new TypeError(j("sourcePinId"));if(typeof l!="string")throw new TypeError(j("targetNodeId"));if(typeof y!="string")throw new TypeError(j("targetPinId"));this.source=t,this.target=n}static isDflowEdge(d,r){var h=d,{source:t,target:n}=h,a=f(h,["source","target"]);return v.isDflowItem(a)&&Array.isArray(t)&&t.length===2&&r.nodes.find(({id:p,outputs:l=[]})=>p===t[0]&&l.find(({id:y})=>y===t[1]))&&Array.isArray(n)&&n.length===2&&r.nodes.find(({id:p,inputs:l=[]})=>p===n[0]&&l.find(({id:y})=>y===n[1]))}toObject(){return b(c({},super.toObject()),{source:this.source,target:this.target})}}const x=class extends v{constructor(){super(...arguments);m(this,k,new Map);m(this,g,new Map);i(this,"runOptions",{verbose:!1});i(this,"runStatus",null);i(this,"executionReport",null)}static isDflowGraph(t){return t.nodes.every(n=>s.isDflowNode(n))&&t.edges.every(n=>ds.isDflowEdge(n,t))}static childrenOfNodeId(t,n){return n.filter(({sourceId:a})=>t===a).map(({targetId:a})=>a)}static parentsOfNodeId(t,n){return n.filter(({targetId:a})=>t===a).map(({sourceId:a})=>a)}static levelOfNodeId(t,n){const a=x.parentsOfNodeId(t,n);if(a.length===0)return 0;let r=0;for(const d of a){const h=x.levelOfNodeId(d,n);r=Math.max(h,r)}return r+1}static ancestorsOfNodeId(t,n){const a=x.parentsOfNodeId(t,n);return a.length===0?[]:a.reduce((r,d,h,p)=>{const l=x.ancestorsOfNodeId(d,n),y=r.concat(l);return h===p.length-1?Array.from(new Set(p.concat(y))):y},[])}static sort(t,n){const a={};for(const r of t)a[r]=x.levelOfNodeId(r,n);return t.slice().sort((r,d)=>a[r]<=a[d]?-1:1)}get edges(){return u(this,g).values()}get nodes(){return u(this,k).values()}get nodeConnections(){return[...u(this,g).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...u(this,g).keys()]}get nodeIds(){return[...u(this,k).keys()]}get numEdges(){return u(this,g).size}get numNodes(){return u(this,k).size}addEdge(t){if(u(this,g).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);u(this,g).set(t.id,t)}addNode(t){if(u(this,k).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);u(this,k).set(t.id,t)}clear(){u(this,k).clear(),u(this,g).clear()}deleteEdge(t){u(this,g).delete(t)}deleteNode(t){u(this,k).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(j("nodeId"));const n=u(this,k).get(t);if(n instanceof s)return n;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(j("edgeId"));const n=u(this,g).get(t);if(n instanceof ds)return n;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const n=`e${t}`;return u(this,g).has(n)?this.generateEdgeId(t+1):n}generateNodeId(t=this.numNodes){const n=`n${t}`;return u(this,k).has(n)?this.generateNodeId(t+1):n}nodeIdsInsideFunctions(){const t=[];for(const n of this.nodes)n.kind==="return"&&t.push(x.ancestorsOfNodeId(n.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){var r,d;const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const n=this.nodeIdsInsideFunctions(),a=x.sort(this.nodeIds.filter(h=>!n.includes(h)),this.nodeConnections);s:for(const h of a){const p=u(this,k).get(h);try{if(!p.meta.isConstant){let l=!1;t:for(const{data:y,types:Ht,isOptional:P}of p.inputs){if(P&&typeof y>"u")continue t;if(!o.validate(y,Ht)){l=!0;break t}}if(l){for(const y of p.outputs)y.clear();t&&((r=this.executionReport.steps)==null||r.push(as(p.toObject())));continue s}p.meta.isAsync?await p.run():p.run()}t&&((d=this.executionReport.steps)==null||d.push(as(p.toObject())))}catch(l){console.error(l),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=b(c({},super.toObject()),{nodes:[],edges:[]});for(const n of this.nodes)t.nodes.push(n.toObject());for(const n of this.edges)t.edges.push(n.toObject());return t}};let cs=x;k=new WeakMap,g=new WeakMap;class B extends s{}i(B,"kind","argument"),i(B,"isConstant",!0),i(B,"inputs",s.in(["number"],{name:"position",optional:!0})),i(B,"outputs",s.out());class G extends s{run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t:this.output(0).clear()}}i(G,"kind","array"),i(G,"inputs",s.in()),i(G,"outputs",s.out(["array"]));class U extends s{run(){const t=this.input(0).data;typeof t=="boolean"?this.output(0).data=t:this.output(0).clear()}}i(U,"kind","boolean"),i(U,"inputs",s.in()),i(U,"outputs",s.out(["boolean"]));class z extends s{}i(z,"kind","data"),i(z,"isConstant",!0),i(z,"outputs",s.out());class Vt extends s{run(){const t=this.output(0);t.data=this.host.nodeKinds}}i(Vt,"kind","dflow"),i(Vt,"outputs",s.out(["array"],{name:"nodeKinds"}));class R extends s{onCreate(){this.output(0).data=this.id}}i(R,"kind","function"),i(R,"isConstant",!0),i(R,"outputs",s.out(["DflowId"],{name:"id"}));class J extends s{run(){const t=this.input(0).data;typeof t=="number"?this.output(0).data=t:this.output(0).clear()}}i(J,"kind","number"),i(J,"inputs",s.in()),i(J,"outputs",s.out(["number"]));class K extends s{run(){const t=this.input(0).data;typeof t=="object"&&t!==null?this.output(0).data=t:this.output(0).clear()}}i(K,"kind","object"),i(K,"inputs",s.in()),i(K,"outputs",s.out(["object"]));class F extends s{}i(F,"kind","return"),i(F,"isConstant",!0),i(F,"inputs",[...s.in(["DflowId"],{name:"functionId"}),...s.in([],{name:"value"})]);class H extends s{run(){const t=this.input(0).data;typeof t=="string"?this.output(0).data=t:this.output(0).clear()}}i(H,"kind","string"),i(H,"inputs",s.in()),i(H,"outputs",s.out(["string"])),B.kind+"",G.kind+"",U.kind+"",z.kind+"",Vt.kind+"",J.kind+"",K.kind+"",R.kind+"",H.kind+"",F.kind+"";class Q extends s{run(){const t=this.input(0).data,n=this.input(1).data;this.output(0).data=t.at(n)}}i(Q,"kind","arrayAt"),i(Q,"inputs",[...s.in(["array"]),...s.in(["number"],{name:"index"})]),i(Q,"outputs",s.out());class V extends s{run(){this.output(0).data=this.input(0).data.filter((...t)=>this.host.executeFunction(this.input(1).data,t))}}i(V,"kind","arrayFilter"),i(V,"inputs",[...s.in(["array"]),...s.in(["DflowId"],{name:"functionId"})]),i(V,"outputs",s.out(["array"]));class W extends s{run(){this.output(0).data=this.input(0).data.findLastIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}i(W,"kind","arrayFindLastIndex"),i(W,"inputs",[...s.in(["array"]),...s.in(["DflowId"],{name:"functionId"})]),i(W,"outputs",s.out(["number"]));class X extends s{run(){this.output(0).data=this.input(0).data.findIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}i(X,"kind","arrayFindIndex"),i(X,"inputs",[...s.in(["array"]),...s.in(["DflowId"],{name:"functionId"})]),i(X,"outputs",s.out(["number"]));class Y extends s{run(){const t=this.input(0).data,n=this.input(1).data;Array.isArray(t)&&(this.output(0).data=t.includes(n))}}i(Y,"kind","arrayIncludes"),i(Y,"inputs",[...s.in(["array"],{name:"array"}),...s.in(["string"],{name:"element"})]),i(Y,"outputs",s.out(["boolean"]));class Z extends s{run(){this.output(0).data=this.input(0).data.join(this.input(1).data)}}i(Z,"kind","arrayJoin"),i(Z,"inputs",[...s.in(["array"],{name:"array"}),...s.in(["string"],{name:"separator",optional:!0})]),i(Z,"outputs",s.out(["string"]));class q extends s{run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t.length:this.output(0).clear}}i(q,"kind","arrayLength"),i(q,"inputs",s.in(["array"])),i(q,"outputs",s.out(["number"]));class M extends s{run(){this.output(0).data=this.input(0).data.map((...t)=>this.host.executeFunction(this.input(1).data,t))}}i(M,"kind","arrayMap"),i(M,"inputs",[...s.in(["array"]),...s.in(["DflowId"],{name:"functionId"})]),i(M,"outputs",s.out(["array"]));class L extends s{run(){const t=this.input(0).data.slice(),n=t.pop();this.output(0).data=n,this.output(1).data=t}}i(L,"kind","arrayPop"),i(L,"inputs",s.in(["array"])),i(L,"outputs",[...s.out([],{name:"element"}),...s.out(["array"],{name:"rest"})]);class w extends s{run(){const t=this.input(0).data.slice(),n=this.input(1).data;n&&t.push(n),this.output(0).data=t}}i(w,"kind","arrayPush"),i(w,"inputs",[...s.in(["array"]),...s.in([],{name:"element"})]),i(w,"outputs",s.out(["array"]));class _ extends s{run(){const t=this.input(0).data.slice();this.output(0).data=t.reverse()}}i(_,"kind","arrayReverse"),i(_,"inputs",s.in(["array"])),i(_,"outputs",s.in(["array"]));class D extends s{run(){const t=this.input(0).data.slice(),n=t.shift();this.output(0).data=n,this.output(1).data=t}}i(D,"kind","arrayShift"),i(D,"inputs",s.in(["array"])),i(D,"outputs",[...s.out([],{name:"element"}),...s.out(["array"],{name:"rest"})]);class tt extends s{run(){const t=super.input(0).data,n=super.input(1).data,a=super.input(2).data;typeof a=="number"?super.output(0).data=t.slice(n,a):super.output(0).data=t.slice(n)}}i(tt,"kind","arraySlice"),i(tt,"inputs",[...s.in(["array"]),...s.in(["number"],{name:"start"}),...s.in(["number"],{name:"end",optional:!0})]),i(tt,"outputs",s.out(["array"]));const ms={[Q.kind]:Q,[V.kind]:V,[W.kind]:W,[X.kind]:X,[Y.kind]:Y,[Z.kind]:Z,[q.kind]:q,[M.kind]:M,[L.kind]:L,[w.kind]:w,[_.kind]:_,[D.kind]:D,[tt.kind]:tt};class st extends s{run(){this.output(0).data=this.input(0).data?this.input(1).data:this.input(2).data}}i(st,"kind","if"),i(st,"inputs",[...s.in(["boolean"],{name:"condition"}),...s.in([],{name:"then"}),...s.in([],{name:"else"})]),i(st,"outputs",s.out());const ks={[st.kind]:st};class Wt extends s{run(){console.log(this.input(0).data)}}i(Wt,"kind","consoleLog"),i(Wt,"inputs",[...s.in([])]);const gs={[Wt.kind]:Wt},ps=[...s.out(["string"]),...s.out(["number"],{name:"milliseconds"})];class it extends s{run(){const t=this.input(0).data;if(typeof t=="string"||typeof t=="number"){const a=new Date(t),r=a.toJSON();r!==null&&(this.output(0).data=r,this.output(1).data=a.getTime())}const n=new Date;this.output(0).data=n.toJSON(),this.output(1).data=n.getTime()}}i(it,"kind","newDate"),i(it,"inputs",s.in(["string","number"],{optional:!0})),i(it,"outputs",ps);class Xt extends s{run(){const t=Date.now();this.output(0).data=new Date(t).toJSON(),this.output(1).data=t}}i(Xt,"kind","now"),i(Xt,"outputs",ps);const bs={[it.kind]:it,[Xt.kind]:Xt};class nt extends s{run(){const t=this.input(0).data;this.output(0).data=typeof t<"u"}}i(nt,"kind","isDefined"),i(nt,"inputs",s.in()),i(nt,"outputs",s.out(["boolean"]));class et extends s{run(){const t=this.input(0).data;this.output(0).data=typeof t>"u"}}i(et,"kind","isUndefined"),i(et,"inputs",s.in()),i(et,"outputs",s.out(["boolean"]));const fs={[nt.kind]:nt,[et.kind]:et};class at extends s{run(){this.output(0).data=this.input(0).data&&this.input(1).data}}i(at,"kind","and"),i(at,"inputs",s.ins(2,["boolean"])),i(at,"outputs",s.out(["boolean"]));class ut extends s{run(){this.output(0).data=!this.input(0).data}}i(ut,"kind","not"),i(ut,"inputs",s.in(["boolean"])),i(ut,"outputs",s.out(["boolean"]));class rt extends s{run(){this.output(0).data=this.input(0).data||this.input(1).data}}i(rt,"kind","or"),i(rt,"inputs",s.ins(2,["boolean"])),i(rt,"outputs",s.out(["boolean"]));const xs={[at.kind]:at,[ut.kind]:ut,[rt.kind]:rt};class ot extends s{run(){this.output(0).data=Math.abs(this.input(0).data)}}i(ot,"kind","mathAbs"),i(ot,"inputs",s.in(["number"])),i(ot,"outputs",s.out(["number"]));class dt extends s{run(){this.output(0).data=Math.cos(this.input(0).data)}}i(dt,"kind","mathCos"),i(dt,"inputs",s.in(["number"])),i(dt,"outputs",s.out(["number"]));class ct extends s{run(){this.output(0).data=Math.cosh(this.input(0).data)}}i(ct,"kind","mathCosh"),i(ct,"inputs",s.in(["number"])),i(ct,"outputs",s.out(["number"]));class pt extends s{run(){this.output(0).data=Math.floor(this.input(0).data)}}i(pt,"kind","mathFloor"),i(pt,"inputs",s.in(["number"])),i(pt,"outputs",s.out(["number"]));class ht extends s{run(){const t=this.input(0).data,n=Math.max(...t);isNaN(n)?this.output(0).clear():this.output(0).data=n}}i(ht,"kind","mathMax"),i(ht,"inputs",s.in(["array"])),i(ht,"outputs",s.out(["number"]));class lt extends s{run(){const t=this.input(0).data,n=Math.min(...t);isNaN(n)?this.output(0).clear():this.output(0).data=n}}i(lt,"kind","mathMin"),i(lt,"inputs",s.in(["array"])),i(lt,"outputs",s.out(["number"]));class yt extends s{}i(yt,"kind","mathPI"),i(yt,"isConstant",!0),i(yt,"outputs",s.out(["number"],{name:"\u03C0",data:Math.PI}));class mt extends s{run(){this.output(0).data=Math.round(this.input(0).data)}}i(mt,"kind","mathRound"),i(mt,"inputs",s.in(["number"])),i(mt,"outputs",s.out(["number"]));class kt extends s{run(){this.output(0).data=Math.sin(this.input(0).data)}}i(kt,"kind","mathSin"),i(kt,"inputs",s.in(["number"])),i(kt,"outputs",s.out(["number"]));class gt extends s{run(){this.output(0).data=Math.sinh(this.input(0).data)}}i(gt,"kind","mathSinh"),i(gt,"inputs",s.in(["number"])),i(gt,"outputs",s.out(["number"]));const Is={[ot.kind]:ot,[dt.kind]:dt,[ct.kind]:ct,[pt.kind]:pt,[ht.kind]:ht,[lt.kind]:lt,[yt.kind]:yt,[mt.kind]:mt,[kt.kind]:kt,[gt.kind]:gt};class bt extends s{run(){this.output(0).data=Number.isFinite(this.input(0).data)}}i(bt,"kind","isFinite"),i(bt,"inputs",s.in(["number"])),i(bt,"outputs",s.out(["boolean"]));class ft extends s{run(){this.output(0).data=Number.isInteger(this.input(0).data)}}i(ft,"kind","isInteger"),i(ft,"inputs",s.in([])),i(ft,"outputs",s.out(["boolean"]));class xt extends s{run(){this.output(0).data=Number.isNaN(this.input(0).data)}}i(xt,"kind","isNaN"),i(xt,"inputs",s.in([])),i(xt,"outputs",s.out(["boolean"]));class It extends s{run(){this.output(0).data=parseFloat(this.input(0).data)}}i(It,"kind","parseFloat"),i(It,"inputs",s.in(["string"])),i(It,"outputs",s.out(["number"]));class Tt extends s{run(){this.output(0).data=parseInt(this.input(0).data)}}i(Tt,"kind","parseInt"),i(Tt,"inputs",s.in(["number","string"])),i(Tt,"outputs",s.out(["number"]));const Ts={[bt.kind]:bt,[ft.kind]:ft,[xt.kind]:xt,[It.kind]:It,[Tt.kind]:Tt};class Ot extends s{run(){this.output(0).data=Object.keys(this.input(0).data)}}i(Ot,"kind","objectKeys"),i(Ot,"inputs",s.in(["object"])),i(Ot,"outputs",s.out(["array"]));class Et extends s{run(){this.output(0).data=Object.values(this.input(0).data)}}i(Et,"kind","objectValues"),i(Et,"inputs",s.in(["object"])),i(Et,"outputs",s.out(["array"]));const Os={[Ot.kind]:Ot,[Et.kind]:Et};class jt extends s{run(){this.output(0).data=this.input(0).data+this.input(1).data}}i(jt,"kind","addition"),i(jt,"inputs",s.ins(2,["number"])),i(jt,"outputs",s.out(["number"]));class vt extends s{run(){this.input(1).data?this.output(0).data=this.input(0).data/this.input(1).data:this.output(0).clear()}}i(vt,"kind","division"),i(vt,"inputs",s.ins(2,["number"])),i(vt,"outputs",s.out(["number"]));class Nt extends s{run(){this.output(0).data=this.input(0).data==this.input(1).data}}i(Nt,"kind","equality"),i(Nt,"inputs",s.ins(2)),i(Nt,"outputs",s.out(["boolean"]));class $t extends s{run(){this.output(0).data=this.input(0).data<this.input(1).data}}i($t,"kind","lessThan"),i($t,"inputs",s.ins(2,["number"])),i($t,"outputs",s.out(["boolean"]));class Ct extends s{run(){this.output(0).data=this.input(0).data<=this.input(1).data}}i(Ct,"kind","lessThanOrEqual"),i(Ct,"inputs",s.ins(2,["number"])),i(Ct,"outputs",s.out(["boolean"]));class St extends s{run(){this.output(0).data=this.input(0).data>this.input(1).data}}i(St,"kind","greaterThan"),i(St,"inputs",s.ins(2,["number"])),i(St,"outputs",s.out(["boolean"]));class Bt extends s{run(){this.output(0).data=this.input(0).data>=this.input(1).data}}i(Bt,"kind","greaterThanOrEqual"),i(Bt,"inputs",s.ins(2,["number"])),i(Bt,"outputs",s.out(["boolean"]));class Pt extends s{run(){this.output(0).data=this.input(0).data!=this.input(1).data}}i(Pt,"kind","inequality"),i(Pt,"inputs",s.ins(2)),i(Pt,"outputs",s.out(["boolean"]));class At extends s{run(){this.output(0).data=this.input(0).data*this.input(1).data}}i(At,"kind","multiplication"),i(At,"inputs",s.ins(2,["number"])),i(At,"outputs",s.out(["number"]));class Gt extends s{run(){this.output(0).data=this.input(0).data-this.input(1).data}}i(Gt,"kind","subtraction"),i(Gt,"inputs",s.ins(2,["number"])),i(Gt,"outputs",s.out(["number"]));const Es={[jt.kind]:jt,[vt.kind]:vt,[Nt.kind]:Nt,[St.kind]:St,[Bt.kind]:Bt,[$t.kind]:$t,[Ct.kind]:Ct,[Pt.kind]:Pt,[At.kind]:At,[Gt.kind]:Gt};class Ut extends s{run(){this.output(0).data=this.input(0).data.length}}i(Ut,"kind","stringLength"),i(Ut,"inputs",s.in(["string"])),i(Ut,"outputs",s.out(["number"]));class zt extends s{run(){const t=this.input(0).data,n=this.input(1).data,a=this.input(2).data;this.output(0).data=t.substring(n,a)}}i(zt,"kind","substring"),i(zt,"inputs",[...s.in(["string"]),...s.in(["number"],{name:"start"}),...s.in(["number"],{name:"end",optional:!0})]),i(zt,"outputs",s.out(["string"]));const js={[Ut.kind]:Ut,[zt.kind]:zt},vs=c(c(c(c(c(c(c(c(c(c(c({},ms),ks),gs),fs),bs),xs),Is),Ts),Os),Es),js);export{vs as nodesCatalog};
