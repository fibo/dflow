var Bs=Object.defineProperty,Ss=Object.defineProperties;var Ps=Object.getOwnPropertyDescriptors;var is=Object.getOwnPropertySymbols;var xs=Object.prototype.hasOwnProperty,Is=Object.prototype.propertyIsEnumerable;var ps=(i,t,n)=>t in i?Bs(i,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):i[t]=n,g=(i,t)=>{for(var n in t||(t={}))xs.call(t,n)&&ps(i,n,t[n]);if(is)for(var n of is(t))Is.call(t,n)&&ps(i,n,t[n]);return i},v=(i,t)=>Ss(i,Ps(t));var K=(i,t)=>{var n={};for(var e in i)xs.call(i,e)&&t.indexOf(e)<0&&(n[e]=i[e]);if(i!=null&&is)for(var e of is(i))t.indexOf(e)<0&&Is.call(i,e)&&(n[e]=i[e]);return n};var s=(i,t,n)=>(ps(i,typeof t!="symbol"?t+"":t,n),n),hs=(i,t,n)=>{if(!t.has(i))throw TypeError("Cannot "+n)};var r=(i,t,n)=>(hs(i,t,"read from private field"),n?n.call(i):t.get(i)),x=(i,t,n)=>{if(t.has(i))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(i):t.set(i,n)},C=(i,t,n,e)=>(hs(i,t,"write to private field"),e?e.call(i,n):t.set(i,n),n);var G=(i,t,n)=>(hs(i,t,"access private method"),n);var R,ts,Y,z,F,J,W,Z,H,os,Ws,p,ss,js,ns,vs;class es extends Error{constructor(t,n){super(`${t} not found id=${n}`)}}const fs=i=>`${i} must be a string`,Rs=(i,t)=>`${t} pin not found nodeId=${i}`,Os=(i,t,n)=>`${Rs(i,t)} position=${n}`,gs=({id:i,kind:t,outputs:n},e)=>{const u={id:i,kind:t,outputs:n==null?void 0:n.map(({id:c,data:d,name:o})=>({id:c,data:d,name:o}))};return e&&(u.error=e),u};class h{static isArray(t){return!!Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowId(t){return h.isStringNotEmpty(t)}static isObject(t){return!(typeof t!="object"||!t||Array.isArray(t))}static isNumber(t){return typeof t=="number"&&!isNaN(t)}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return h.isString(t)&&t!==""}static validate(t,n){return n.length===0?!0:n.some(e=>{switch(e){case"array":return h.isArray(t);case"boolean":return h.isBoolean(t);case"number":return h.isNumber(t);case"object":return h.isObject(t);case"string":return h.isString(t);case"DflowId":return h.isDflowId(t);default:return!1}},!0)}}class as{constructor({id:t,name:n}){s(this,"id");s(this,"name");this.id=t,this.name=n}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}class ms extends as{constructor(t,u){var c=u,{types:n=[]}=c,e=K(c,["types"]);super(e);s(this,"kind");s(this,"types");this.kind=t,this.types=n}get hasTypeAny(){return this.types.length===0}hasType(t){return this.hasTypeAny||this.types.includes(t)}toObject(){const t=super.toObject();return this.types.length>0&&(t.types=this.types),t}}s(ms,"types",["string","number","boolean","object","array","DflowId"]);class zs extends ms{constructor(u){var c=u,{multi:t,optional:n}=c,e=K(c,["multi","optional"]);super("input",e);x(this,R,void 0);x(this,ts,void 0);x(this,Y,void 0);x(this,z,void 0);C(this,R,t),C(this,ts,n)}get data(){var t,n;if(r(this,R)){const e=Array.from((t=r(this,z))!=null?t:[]);return e.length?e.map(u=>u.data):void 0}else return(n=r(this,Y))==null?void 0:n.data}get isConnected(){var t;return r(this,R)?Array.from((t=r(this,z))!=null?t:[]).length>0:typeof r(this,Y)>"u"}get isMulti(){return r(this,R)}get isOptional(){return r(this,ts)}connectTo(t){const{hasTypeAny:n,types:e}=this,{types:u}=t;if(n||e.some(d=>u.includes(d)))r(this,R)?(r(this,z)||C(this,z,new Set),r(this,z).add(t)):C(this,Y,t);else throw new Error(`mismatching pinTypes, source has types [${u.join()}] and target has types [${e.join()}]`)}disconnect(){var t;r(this,R)?(t=r(this,z))==null||t.clear():C(this,Y,void 0)}toObject(){return super.toObject()}}R=new WeakMap,ts=new WeakMap,Y=new WeakMap,z=new WeakMap;class Fs extends ms{constructor(e){var u=e,{data:t}=u,n=K(u,["data"]);super("output",n);x(this,F,void 0);C(this,F,t)}clear(){C(this,F,void 0)}get data(){return r(this,F)}set data(t){switch(!0){case typeof t>"u":this.clear();break;case this.hasTypeAny:case(this.hasType("string")&&h.isString(t)):case(this.hasType("number")&&h.isNumber(t)):case(this.hasType("boolean")&&h.isBoolean(t)):case(this.hasType("object")&&h.isObject(t)):case(this.hasType("array")&&h.isArray(t)):case(this.hasType("DflowId")&&h.isDflowId(t)):{C(this,F,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof data is ${typeof t}`)}}toObject(){const t=super.toObject();return typeof r(this,F)<"u"&&(t.data=r(this,F)),t}}F=new WeakMap;class a extends as{constructor(f,c,{isAsync:d=!1,isConstant:o=!1}={}){var y=f,{kind:t,inputs:n=[],outputs:e=[]}=y,u=K(y,["kind","inputs","outputs"]);super(u);x(this,J,new Map);x(this,W,new Map);x(this,Z,[]);x(this,H,[]);s(this,"kind");s(this,"meta");s(this,"host");this.host=c,this.kind=t,this.meta={isAsync:d,isConstant:o};for(const b of n)this.newInput(b);for(const b of e)this.newOutput(b)}static input(t=[],n){return g(typeof t=="string"?{types:[t]}:{types:t},n)}static output(t=[],n){return g(typeof t=="string"?{types:[t]}:{types:t},n)}get inputs(){return r(this,J).values()}get outputs(){return r(this,W).values()}clearOutputs(){for(const t of this.outputs)t.clear()}getInputById(t){const n=r(this,J).get(t);if(!n)throw new es("input",t);return n}input(t){const n=r(this,Z)[t];if(!n)throw new Error(Os(this.id,"input",t));return this.getInputById(n)}getOutputById(t){const n=r(this,W).get(t);if(!n)throw new es("output",t);return n}output(t){const n=r(this,H)[t];if(!n)throw new Error(Os(this.id,"output",t));return this.getOutputById(n)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),r(this,J).delete(t),r(this,Z).splice(r(this,Z).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),r(this,W).delete(t),r(this,H).splice(r(this,H).indexOf(t),1)}newInput(t){const n=r(this,J).size,e=(d=n)=>{const o=`i${d}`;return r(this,J).has(o)?e(d+1):o},u=h.isDflowId(t.id)?t.id:e(),c=new zs(v(g({},t),{id:u}));return r(this,J).set(u,c),r(this,Z).push(u),c}newOutput(t){const n=r(this,W).size,e=(d=n)=>{const o=`o${d}`;return r(this,W).has(o)?e(d+1):o},u=h.isDflowId(t.id)?t.id:e(),c=new Fs(v(g({},t),{id:u}));return r(this,W).set(u,c),r(this,H).push(u),c}run(){}toObject(){const t=v(g({},super.toObject()),{kind:this.kind}),n=[],e=[];for(const u of this.inputs)n.push(u.toObject());n.length>0&&(t.inputs=n);for(const u of this.outputs)e.push(u.toObject());return e.length>0&&(t.outputs=e),t}}J=new WeakMap,W=new WeakMap,Z=new WeakMap,H=new WeakMap,s(a,"kind"),s(a,"isAsync"),s(a,"isConstant"),s(a,"inputs"),s(a,"outputs");class Js extends as{constructor(u){var c=u,{source:t,target:n}=c,e=K(c,["source","target"]);super(e);s(this,"source");s(this,"target");this.source=t,this.target=n}toObject(){return v(g({},super.toObject()),{source:this.source,target:this.target})}}const P=class extends as{constructor(){super(...arguments);x(this,os);s(this,"nodes",new Map);s(this,"edges",new Map);s(this,"runOptions",{verbose:!1});s(this,"runStatus",null);s(this,"executionReport",null)}static childrenOfNodeId(t,n){return n.filter(({sourceId:e})=>t===e).map(({targetId:e})=>e)}static parentsOfNodeId(t,n){return n.filter(({targetId:e})=>t===e).map(({sourceId:e})=>e)}static levelOfNodeId(t,n){const e=P.parentsOfNodeId(t,n);if(e.length===0)return 0;let u=0;for(const c of e){const d=P.levelOfNodeId(c,n);u=Math.max(d,u)}return u+1}static ancestorsOfNodeId(t,n){const e=P.parentsOfNodeId(t,n);return e.length===0?[]:e.reduce((u,c,d,o)=>{const f=P.ancestorsOfNodeId(c,n),y=u.concat(f);return d===o.length-1?Array.from(new Set(o.concat(y))):y},[])}static sort(t,n){const e={};for(const u of t)e[u]=P.levelOfNodeId(u,n);return t.slice().sort((u,c)=>e[u]<=e[c]?-1:1)}get nodeConnections(){return[...this.edges.values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}async run(){var u,c;const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const n=G(this,os,Ws).call(this),e=P.sort([...this.nodes.keys()].filter(d=>!n.includes(d)),this.nodeConnections);s:for(const d of e){const o=this.nodes.get(d);try{if(!o.meta.isConstant){let f=!1;t:for(const{id:y,data:b,types:O,isOptional:l}of o.inputs){if(l&&typeof b>"u")continue t;if(!h.validate(b,O)){f=!0,t&&((u=this.executionReport.steps)==null||u.push(gs(o.toObject(),`invalid input data nodeId=${d} inputId=${y} data=${b}`)));break t}}if(f){for(const y of o.outputs)y.clear();continue s}o.meta.isAsync?await o.run():o.run()}t&&((c=this.executionReport.steps)==null||c.push(gs(o.toObject())))}catch(f){console.error(f),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=v(g({},super.toObject()),{nodes:[],edges:[]});for(const n of this.nodes.values())t.nodes.push(n.toObject());for(const n of this.edges.values())t.edges.push(n.toObject());return t}};let L=P;os=new WeakSet,Ws=function(){const t=[];for(const n of[...this.nodes.values()])n.kind==="return"&&t.push(P.ancestorsOfNodeId(n.id,this.nodeConnections));return Array.from(new Set(t.flat()))};const q=class{constructor(t={}){x(this,p,void 0);s(this,"nodesCatalog");s(this,"context");this.nodesCatalog=g(g({},t),Us),C(this,p,new L({id:"g1"})),this.context={}}get executionReport(){return r(this,p).executionReport}get edges(){return Array.from(r(this,p).edges.values())}get nodes(){return r(this,p).nodes}get runStatusIsSuccess(){return r(this,p).runStatus==="success"}get runStatusIsWaiting(){return r(this,p).runStatus==="waiting"}get runStatusIsFailure(){return r(this,p).runStatus==="failure"}set verbose(t){r(this,p).runOptions.verbose=t}clearGraph(){r(this,p).nodes.clear(),r(this,p).edges.clear()}connect(t,n=0){return{to:(e,u=0)=>{const c=t.output(n),d=e.input(u);this.newEdge({source:[t.id,c.id],target:[e.id,d.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(fs("edgeId"));const n=this.getEdgeById(t);if(!n)return;const[e,u]=n.target;this.getNodeById(e).getInputById(u).disconnect(),r(this,p).edges.delete(t)}deleteNode(t){if(typeof t!="string")throw new TypeError(fs("nodeId"));const n=this.getNodeById(t);if(n){for(const e of this.edges){const{source:[u],target:[c]}=e;(u===n.id||c===n.id)&&this.deleteEdge(e.id)}r(this,p).nodes.delete(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,n]){for(const e of this.edges){const[u,c]=e.source,[d,o]=e.target;(u===t&&c===n||d===t&&o===n)&&this.deleteEdge(e.id)}}executeFunction(t,n){var y,b;const{verbose:e}=r(this,p).runOptions,u=r(this,p).nodeConnections,c=L.childrenOfNodeId(t,u),d=[];for(const O of c){const l=this.getNodeById(O);l.kind===V.kind&&d.push(l.id)}const o=d.reduce((O,l,j,T)=>{const Q=L.ancestorsOfNodeId(l,u),A=O.concat(Q);return j===T.length?Array.from(new Set(A)):A},[]),f=L.sort([...d,...o],u);for(const O of f){const l=this.getNodeById(O);try{switch(l.kind){case U.kind:{const j=l.input(0).data,T=typeof j=="number"&&!isNaN(j)?Math.max(j,0):0;l.output(0).data=n[T];break}case V.kind:return l.input(1).data;default:!l.meta.isConstant&&!l.meta.isAsync&&l.run(),e&&((b=(y=this.executionReport)==null?void 0:y.steps)==null||b.push(gs(l.toObject())))}}catch(j){console.error(j)}}}getEdgeById(t){const n=r(this,p).edges.get(t);if(!n)throw new es("edge",t);return n}getNodeById(t){const n=r(this,p).nodes.get(t);if(!n)throw new es("node",t);return n}newNode(t){var b,O,l,j,T,Q,A;const n=r(this,p).nodes.size,e=(ys=n)=>{const bs=`n${ys}`;return r(this,p).nodes.has(bs)?e(ys+1):bs},u=(b=this.nodesCatalog[t.kind])!=null?b:Qs,c=h.isDflowId(t.id)?t.id:e(),d={isAsync:u.isAsync,isConstant:u.isConstant},o=Array.isArray(t.inputs)?G(O=q,ss,js).call(O,t.inputs):G(j=q,ss,js).call(j,(l=u.inputs)!=null?l:[]),f=Array.isArray(t.outputs)?G(T=q,ns,vs).call(T,t.outputs):G(A=q,ns,vs).call(A,(Q=u.outputs)!=null?Q:[]),y=new u(v(g({},t),{id:c,inputs:o,outputs:f}),this,d);return r(this,p).nodes.set(y.id,y),y}newEdge(t){const n=r(this,p).edges.size,e=(T=n)=>{const Q=`e${T}`;return r(this,p).edges.has(Q)?e(T+1):Q},u=h.isDflowId(t.id)?t.id:e(),c=new Js(v(g({},t),{id:u}));r(this,p).edges.set(c.id,c);const[d,o]=c.source,[f,y]=c.target,b=this.getNodeById(d),O=this.getNodeById(f),l=b.getOutputById(o);return O.getInputById(y).connectTo(l),c}newInput(t,n){return this.getNodeById(t).newInput(n)}newOutput(t,n){return this.getNodeById(t).newOutput(n)}toObject(){return r(this,p).toObject()}async run(){await r(this,p).run()}};let ls=q;p=new WeakMap,ss=new WeakSet,js=function(t=[]){return t.map((n,e)=>v(g({},n),{id:h.isDflowId(n.id)?n.id:`i${e}`}))},ns=new WeakSet,vs=function(t=[]){return t.map((n,e)=>v(g({},n),{id:h.isDflowId(n.id)?n.id:`o${e}`}))},x(ls,ss),x(ls,ns);const{input:$,output:B}=a;class U extends a{}s(U,"kind","argument"),s(U,"isConstant",!0),s(U,"inputs",[$("number",{name:"position",optional:!0})]),s(U,"outputs",[B()]);class M extends a{run(){const t=this.input(0).data;h.isArray(t)?this.output(0).data=t:this.output(0).clear()}}s(M,"kind","array"),s(M,"inputs",[$()]),s(M,"outputs",[B("array")]);class _ extends a{run(){const t=this.input(0).data;h.isBoolean(t)?this.output(0).data=t:this.output(0).clear()}}s(_,"kind","boolean"),s(_,"inputs",[$()]),s(_,"outputs",[B("boolean")]);class w extends a{}s(w,"kind","data"),s(w,"isConstant",!0),s(w,"outputs",[B()]);class D extends a{constructor(...t){super(...t);this.output(0).data=this.id}}s(D,"kind","function"),s(D,"isConstant",!0),s(D,"outputs",[B("DflowId",{name:"id"})]);class tt extends a{run(){this.output(0).data=typeof this.input(0).data>"u"}}s(tt,"kind","isUndefined"),s(tt,"inputs",[$()]),s(tt,"outputs",[B("boolean")]);class st extends a{run(){const t=this.input(0).data;h.isNumber(t)?this.output(0).data=t:this.output(0).clear()}}s(st,"kind","number"),s(st,"inputs",[$()]),s(st,"outputs",[B("number")]);class nt extends a{run(){const t=this.input(0).data;h.isObject(t)?this.output(0).data=t:this.output(0).clear()}}s(nt,"kind","object"),s(nt,"inputs",[$()]),s(nt,"outputs",[B("object")]);class V extends a{}s(V,"kind","return"),s(V,"isConstant",!0),s(V,"inputs",[$("DflowId",{name:"functionId"}),$([],{name:"value"})]);class it extends a{run(){const t=this.input(0).data;h.isString(t)?this.output(0).data=t:this.output(0).clear()}}s(it,"kind","string"),s(it,"inputs",[$()]),s(it,"outputs",[B("string")]);class Qs extends a{}const Us={[U.kind]:U,[M.kind]:M,[_.kind]:_,[w.kind]:w,[tt.kind]:tt,[st.kind]:st,[nt.kind]:nt,[D.kind]:D,[it.kind]:it,[V.kind]:V},{input:m,output:I}=a;class et extends a{run(){const t=this.input(0).data,n=this.input(1).data;this.output(0).data=t.at(n)}}s(et,"kind","arrayAt"),s(et,"inputs",[m("array"),m("number",{name:"index"})]),s(et,"outputs",[I()]);class at extends a{run(){this.output(0).data=this.input(0).data.filter((...t)=>this.host.executeFunction(this.input(1).data,t))}}s(at,"kind","arrayFilter"),s(at,"inputs",[m("array"),m("DflowId",{name:"functionId"})]),s(at,"outputs",[I("array")]);class ut extends a{run(){this.output(0).data=this.input(0).data.findLastIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}s(ut,"kind","arrayFindLastIndex"),s(ut,"inputs",[m("array"),m("DflowId",{name:"functionId"})]),s(ut,"outputs",[I("number")]);class rt extends a{run(){this.output(0).data=this.input(0).data.findIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}s(rt,"kind","arrayFindIndex"),s(rt,"inputs",[m("array"),m("DflowId",{name:"functionId"})]),s(rt,"outputs",[I("number")]);class ct extends a{run(){const t=this.input(0).data,n=this.input(1).data;Array.isArray(t)&&(this.output(0).data=t.includes(n))}}s(ct,"kind","arrayIncludes"),s(ct,"inputs",[m("array",{name:"array"}),m("string",{name:"element"})]),s(ct,"outputs",[I("boolean")]);class dt extends a{run(){this.output(0).data=this.input(0).data.join(this.input(1).data)}}s(dt,"kind","arrayJoin"),s(dt,"inputs",[m("array",{name:"array"}),m("string",{name:"separator",optional:!0})]),s(dt,"outputs",[I("string")]);class ot extends a{run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t.length:this.output(0).clear}}s(ot,"kind","arrayLength"),s(ot,"inputs",[m("array")]),s(ot,"outputs",[I("number")]);class pt extends a{run(){this.output(0).data=this.input(0).data.map((...t)=>this.host.executeFunction(this.input(1).data,t))}}s(pt,"kind","arrayMap"),s(pt,"inputs",[m("array"),m("DflowId",{name:"functionId"})]),s(pt,"outputs",[I("array")]);class ht extends a{run(){const t=this.input(0).data.slice(),n=t.pop();this.output(0).data=n,this.output(1).data=t}}s(ht,"kind","arrayPop"),s(ht,"inputs",[m("array")]),s(ht,"outputs",[I([],{name:"element"}),I("array",{name:"rest"})]);class gt extends a{run(){const t=this.input(0).data.slice(),n=this.input(1).data;n&&t.push(n),this.output(0).data=t}}s(gt,"kind","arrayPush"),s(gt,"inputs",[m("array"),m([],{name:"element"})]),s(gt,"outputs",[I("array")]);class mt extends a{run(){const t=this.input(0).data.slice();this.output(0).data=t.reverse()}}s(mt,"kind","arrayReverse"),s(mt,"inputs",[m("array")]),s(mt,"outputs",[m("array")]);class lt extends a{run(){const t=this.input(0).data.slice(),n=t.shift();this.output(0).data=n,this.output(1).data=t}}s(lt,"kind","arrayShift"),s(lt,"inputs",[m("array")]),s(lt,"outputs",[I([],{name:"element"}),I("array",{name:"rest"})]);class kt extends a{run(){const t=super.input(0).data,n=super.input(1).data,e=super.input(2).data;typeof e=="number"?super.output(0).data=t.slice(n,e):super.output(0).data=t.slice(n)}}s(kt,"kind","arraySlice"),s(kt,"inputs",[m("array"),m("number",{name:"start"}),m("number",{name:"end",optional:!0})]),s(kt,"outputs",[I("array")]);const Vs={[et.kind]:et,[at.kind]:at,[ut.kind]:ut,[rt.kind]:rt,[ct.kind]:ct,[dt.kind]:dt,[ot.kind]:ot,[pt.kind]:pt,[ht.kind]:ht,[gt.kind]:gt,[mt.kind]:mt,[lt.kind]:lt,[kt.kind]:kt},{input:ks,output:Xs}=a;class yt extends a{run(){this.output(0).data=this.input(0).data?this.input(1).data:this.input(2).data}}s(yt,"kind","if"),s(yt,"inputs",[ks([],{name:"condition"}),ks([],{name:"then"}),ks([],{name:"else"})]),s(yt,"outputs",[Xs()]);const Ys={[yt.kind]:yt},{input:Zs}=a;class us extends a{run(){console.log(this.input(0).data)}}s(us,"kind","consoleLog"),s(us,"inputs",[Zs()]);const Hs={[us.kind]:us},{input:Ks,output:Cs}=a,Es=[Cs("string"),Cs("number",{name:"milliseconds"})];class bt extends a{run(){const t=this.input(0).data;if(typeof t=="string"||typeof t=="number"){const e=new Date(t),u=e.toJSON();u!==null&&(this.output(0).data=u,this.output(1).data=e.getTime())}const n=new Date;this.output(0).data=n.toJSON(),this.output(1).data=n.getTime()}}s(bt,"kind","newDate"),s(bt,"inputs",[Ks(["string","number"],{optional:!0})]),s(bt,"outputs",Es);class rs extends a{run(){const t=Date.now();this.output(0).data=new Date(t).toJSON(),this.output(1).data=t}}s(rs,"kind","now"),s(rs,"outputs",Es);const Gs={[bt.kind]:bt,[rs.kind]:rs},{input:X,output:cs}=a;class xt extends a{run(){this.output(0).data=this.input(0).data&&this.input(1).data}}s(xt,"kind","and"),s(xt,"inputs",[X("boolean"),X("boolean")]),s(xt,"outputs",[cs("boolean")]);class It extends a{run(){this.output(0).data=!this.input(0).data}}s(It,"kind","not"),s(It,"inputs",[X("boolean")]),s(It,"outputs",[cs("boolean")]);class ft extends a{run(){var t;this.output(0).data=(t=this.input(0).data)!=null?t:this.input(1).data}}s(ft,"kind","??"),s(ft,"inputs",[X(),X()]),s(ft,"outputs",[cs()]);class Ot extends a{run(){this.output(0).data=this.input(0).data||this.input(1).data}}s(Ot,"kind","or"),s(Ot,"inputs",[X("boolean"),X("boolean")]),s(Ot,"outputs",[cs("boolean")]);const qs={[xt.kind]:xt,[It.kind]:It,[ft.kind]:ft,[Ot.kind]:Ot},{input:S,output:E}=a;class jt extends a{run(){this.output(0).data=Math.abs(this.input(0).data)}}s(jt,"kind","mathAbs"),s(jt,"inputs",[S("number")]),s(jt,"outputs",[E("number")]);class vt extends a{run(){this.output(0).data=Math.cos(this.input(0).data)}}s(vt,"kind","mathCos"),s(vt,"inputs",[S("number")]),s(vt,"outputs",[E("number")]);class Ct extends a{run(){this.output(0).data=Math.cosh(this.input(0).data)}}s(Ct,"kind","mathCosh"),s(Ct,"inputs",[S("number")]),s(Ct,"outputs",[E("number")]);class Et extends a{run(){this.output(0).data=Math.floor(this.input(0).data)}}s(Et,"kind","mathFloor"),s(Et,"inputs",[S("number")]),s(Et,"outputs",[E("number")]);class Nt extends a{run(){const t=this.input(0).data,n=Math.max(...t);isNaN(n)?this.output(0).clear():this.output(0).data=n}}s(Nt,"kind","mathMax"),s(Nt,"inputs",[S("array")]),s(Nt,"outputs",[E("number")]);class Tt extends a{run(){const t=this.input(0).data,n=Math.min(...t);isNaN(n)?this.output(0).clear():this.output(0).data=n}}s(Tt,"kind","mathMin"),s(Tt,"inputs",[S("array")]),s(Tt,"outputs",[E("number")]);class $t extends a{}s($t,"kind","mathPI"),s($t,"isConstant",!0),s($t,"outputs",[E("number",{name:"\u03C0",data:Math.PI})]);class Bt extends a{run(){this.output(0).data=Math.round(this.input(0).data)}}s(Bt,"kind","mathRound"),s(Bt,"inputs",[S("number")]),s(Bt,"outputs",[E("number")]);class St extends a{run(){this.output(0).data=Math.sin(this.input(0).data)}}s(St,"kind","mathSin"),s(St,"inputs",[S("number")]),s(St,"outputs",[E("number")]);class Pt extends a{run(){this.output(0).data=Math.sinh(this.input(0).data)}}s(Pt,"kind","mathSinh"),s(Pt,"inputs",[S("number")]),s(Pt,"outputs",[E("number")]);const As={[jt.kind]:jt,[vt.kind]:vt,[Ct.kind]:Ct,[Et.kind]:Et,[Nt.kind]:Nt,[Tt.kind]:Tt,[$t.kind]:$t,[Bt.kind]:Bt,[St.kind]:St,[Pt.kind]:Pt},{input:Rt,output:zt}=a;class Ft extends a{run(){this.output(0).data=Number.isFinite(this.input(0).data)}}s(Ft,"kind","isFinite"),s(Ft,"inputs",[Rt("number")]),s(Ft,"outputs",[zt("boolean")]);class Jt extends a{run(){this.output(0).data=Number.isInteger(this.input(0).data)}}s(Jt,"kind","isInteger"),s(Jt,"inputs",[Rt()]),s(Jt,"outputs",[zt("boolean")]);class Wt extends a{run(){this.output(0).data=Number.isNaN(this.input(0).data)}}s(Wt,"kind","isNaN"),s(Wt,"inputs",[Rt()]),s(Wt,"outputs",[zt("boolean")]);class Qt extends a{run(){this.output(0).data=parseFloat(this.input(0).data)}}s(Qt,"kind","parseFloat"),s(Qt,"inputs",[Rt("string")]),s(Qt,"outputs",[zt("number")]);class Ut extends a{run(){this.output(0).data=parseInt(this.input(0).data)}}s(Ut,"kind","parseInt"),s(Ut,"inputs",[Rt(["number","string"])]),s(Ut,"outputs",[zt("number")]);const Ls={[Ft.kind]:Ft,[Jt.kind]:Jt,[Wt.kind]:Wt,[Qt.kind]:Qt,[Ut.kind]:Ut},{input:Ns,output:Ts}=a;class Vt extends a{run(){this.output(0).data=Object.keys(this.input(0).data)}}s(Vt,"kind","objectKeys"),s(Vt,"inputs",[Ns("object")]),s(Vt,"outputs",[Ts("array")]);class Xt extends a{run(){this.output(0).data=Object.values(this.input(0).data)}}s(Xt,"kind","objectValues"),s(Xt,"inputs",[Ns("object")]),s(Xt,"outputs",[Ts("array")]);const Ms={[Vt.kind]:Vt,[Xt.kind]:Xt},{input:k,output:N}=a;class Yt extends a{run(){this.output(0).data=this.input(0).data+this.input(1).data}}s(Yt,"kind","addition"),s(Yt,"inputs",[k("number"),k("number")]),s(Yt,"outputs",[N("number")]);class Zt extends a{run(){this.input(1).data?this.output(0).data=this.input(0).data/this.input(1).data:this.output(0).clear()}}s(Zt,"kind","division"),s(Zt,"inputs",[k("number"),k("number")]),s(Zt,"outputs",[N("number")]);class Ht extends a{run(){this.output(0).data=this.input(0).data==this.input(1).data}}s(Ht,"kind","equality"),s(Ht,"inputs",[k(),k()]),s(Ht,"outputs",[N("boolean")]);class Kt extends a{run(){this.output(0).data=this.input(0).data<this.input(1).data}}s(Kt,"kind","lessThan"),s(Kt,"inputs",[k("number"),k("number")]),s(Kt,"outputs",[N("boolean")]);class Gt extends a{run(){this.output(0).data=this.input(0).data<=this.input(1).data}}s(Gt,"kind","lessThanOrEqual"),s(Gt,"inputs",[k("number"),k("number")]),s(Gt,"outputs",[N("boolean")]);class qt extends a{run(){this.output(0).data=this.input(0).data>this.input(1).data}}s(qt,"kind","greaterThan"),s(qt,"inputs",[k("number"),k("number")]),s(qt,"outputs",[N("boolean")]);class At extends a{run(){this.output(0).data=this.input(0).data>=this.input(1).data}}s(At,"kind","greaterThanOrEqual"),s(At,"inputs",[k("number"),k("number")]),s(At,"outputs",[N("boolean")]);class Lt extends a{run(){this.output(0).data=this.input(0).data!=this.input(1).data}}s(Lt,"kind","inequality"),s(Lt,"inputs",[k(),k()]),s(Lt,"outputs",[N("boolean")]);class Mt extends a{run(){this.output(0).data=this.input(0).data*this.input(1).data}}s(Mt,"kind","multiplication"),s(Mt,"inputs",[k("number"),k("number")]),s(Mt,"outputs",[N("number")]);class _t extends a{run(){this.output(0).data=this.input(0).data-this.input(1).data}}s(_t,"kind","subtraction"),s(_t,"inputs",[k("number"),k("number")]),s(_t,"outputs",[N("number")]);const _s={[Yt.kind]:Yt,[Zt.kind]:Zt,[Ht.kind]:Ht,[qt.kind]:qt,[At.kind]:At,[Kt.kind]:Kt,[Gt.kind]:Gt,[Lt.kind]:Lt,[Mt.kind]:Mt,[_t.kind]:_t},{input:ds,output:$s}=a;class wt extends a{run(){this.output(0).data=this.input(0).data.length}}s(wt,"kind","stringLength"),s(wt,"inputs",[ds("string")]),s(wt,"outputs",[$s("number")]);class Dt extends a{run(){const t=this.input(0).data,n=this.input(1).data,e=this.input(2).data;this.output(0).data=t.substring(n,e)}}s(Dt,"kind","substring"),s(Dt,"inputs",[ds("string"),ds("number",{name:"start"}),ds("number",{name:"end",optional:!0})]),s(Dt,"outputs",[$s("string")]);const ws={[Dt.kind]:Dt,[wt.kind]:wt},Ds=g(g(g(g(g(g(g(g(g(g({},Vs),Ys),Hs),Gs),qs),As),Ls),Ms),_s),ws);export{Ds as nodesCatalog};
