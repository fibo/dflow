var Ns=Object.defineProperty,Ts=Object.defineProperties;var js=Object.getOwnPropertyDescriptors;var Ht=Object.getOwnPropertySymbols;var ps=Object.prototype.hasOwnProperty,hs=Object.prototype.propertyIsEnumerable;var es=(e,t,s)=>t in e?Ns(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,g=(e,t)=>{for(var s in t||(t={}))ps.call(t,s)&&es(e,s,t[s]);if(Ht)for(var s of Ht(t))hs.call(t,s)&&es(e,s,t[s]);return e},O=(e,t)=>Ts(e,js(t));var j=(e,t)=>{var s={};for(var u in e)ps.call(e,u)&&t.indexOf(u)<0&&(s[u]=e[u]);if(e!=null&&Ht)for(var u of Ht(e))t.indexOf(u)<0&&hs.call(e,u)&&(s[u]=e[u]);return s};var i=(e,t,s)=>(es(e,typeof t!="symbol"?t+"":t,s),s),us=(e,t,s)=>{if(!t.has(e))throw TypeError("Cannot "+s)};var a=(e,t,s)=>(us(e,t,"read from private field"),s?s.call(e):t.get(e)),I=(e,t,s)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,s)},C=(e,t,s,u)=>(us(e,t,"write to private field"),u?u.call(e,s):t.set(e,s),s);var U=(e,t,s)=>(us(e,t,"access private method"),s);var R,Yt,P,$,B,W,Q,Zt,bs,At,Is,f,x,h,ts,$s,ss,Bs;const E=e=>`${e} must be a string`,gs=(e,t)=>`${t} pin not found nodeId=${e}`,ls=(e,t,s)=>`${gs(e,t)} position=${s}`,ms=(e,t,s)=>`${gs(e,t)} pinId=${s}`,as=({id:e,kind:t,outputs:s},u)=>{const r={id:e,kind:t,outputs:s==null?void 0:s.map(({id:c,data:p,name:d})=>({id:c,data:p,name:d}))};return u&&(r.error=u),r};class o{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowId(t){return o.isStringNotEmpty(t)}static isObject(t){return!o.isUndefined(t)&&!o.isNull(t)&&!o.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"&&!isNaN(t)}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return o.isString(t)&&t.length>0}static isUndefined(t){return typeof t>"u"}static validate(t,s){return s.length===0?!0:s.some(u=>{switch(u){case"array":return o.isArray(t);case"boolean":return o.isBoolean(t);case"null":return o.isNull(t);case"number":return o.isNumber(t);case"object":return o.isObject(t);case"string":return o.isString(t);case"DflowId":return o.isDflowId(t);default:return!1}},!0)}}class F{constructor({id:t,name:s}){i(this,"id");i(this,"name");this.id=t,this.name=s}static isDflowItem({id:t,name:s}){return o.isDflowId(t)&&(o.isUndefined(s)||o.isStringNotEmpty(s))}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const Xt=class extends F{constructor(t,r){var c=r,{types:s=[]}=c,u=j(c,["types"]);super(u);i(this,"kind");i(this,"types");this.kind=t,this.types=s}static isDflowPin(u){var r=u,{types:t=[]}=r,s=j(r,["types"]);return F.isDflowItem(s)&&Xt.isDflowPinTypes(t)}static isDflowPinType(t){return typeof t!="string"?!1:Xt.types.includes(t)}static isDflowPinTypes(t){return Array.isArray(t)?t.every(s=>Xt.isDflowPinType(s)):!1}get hasTypeAny(){return this.types.length===0}hasType(t){return this.hasTypeAny||this.types.includes(t)}toObject(){const t=super.toObject();return this.types.length>0&&(t.types=this.types),t}};let N=Xt;i(N,"types",["string","number","boolean","null","object","array","DflowId"]);class ys extends N{constructor(u){var r=u,{optional:t}=r,s=j(r,["optional"]);super("input",s);I(this,R,void 0);I(this,Yt,void 0);C(this,Yt,t)}static isDflowInput({id:t,types:s}){return N.isDflowPin({id:t,types:s})}get data(){var t,s;return console.log("get data",this.toObject()),console.log("source",(t=a(this,R))==null?void 0:t.toObject()),(s=a(this,R))==null?void 0:s.data}get isConnected(){return typeof a(this,R)>"u"}get isOptional(){return a(this,Yt)}connectTo(t){const{hasTypeAny:s,types:u}=this,{types:r}=t;if(s||u.some(c=>r.includes(c)))C(this,R,t);else throw new Error(`mismatching pinTypes, source has types [${r.join()}] and target has types [${u.join()}]`)}disconnect(){C(this,R,void 0)}toObject(){return super.toObject()}}R=new WeakMap,Yt=new WeakMap;class ks extends N{constructor(u){var r=u,{data:t}=r,s=j(r,["data"]);super("output",s);I(this,P,void 0);C(this,P,t)}static isDflowOutput({id:t,data:s,types:u=[]}){return N.isDflowPin({id:t,types:u})&&o.validate(s,u)}clear(){C(this,P,void 0)}get data(){return a(this,P)}set data(t){switch(!0){case o.isUndefined(t):this.clear();break;case this.hasTypeAny:case(o.isDflowId(t)&&this.hasType("DflowId")):case(o.isString(t)&&this.hasType("string")):case(o.isNumber(t)&&this.hasType("number")):case(o.isBoolean(t)&&this.hasType("boolean")):case(o.isNull(t)&&this.hasType("null")):case(o.isObject(t)&&this.hasType("object")):case(o.isArray(t)&&this.hasType("array")):{C(this,P,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=super.toObject();return typeof a(this,P)<"u"&&(t.data=a(this,P)),t}}P=new WeakMap;class n extends F{constructor(m,c,{isAsync:p=!1,isConstant:d=!1}={}){var l=m,{kind:t,inputs:s=[],outputs:u=[]}=l,r=j(l,["kind","inputs","outputs"]);super(r);I(this,Zt);I(this,At);I(this,$,new Map);I(this,B,new Map);I(this,W,[]);I(this,Q,[]);i(this,"kind");i(this,"meta");i(this,"host");this.host=c,this.kind=t,this.meta={isAsync:p,isConstant:d};for(const k of s)this.newInput(k);for(const k of u)this.newOutput(k)}static input(t=[],s){if(N.isDflowPinType(t))return g({types:[t]},s);if(N.isDflowPinTypes(t))return g({types:t},s);throw new TypeError("invalid input definition")}static output(t=[],s){if(N.isDflowPinType(t))return g({types:[t]},s);if(N.isDflowPinTypes(t))return g({types:t},s);throw new TypeError("invalid output definition")}static in(t=[],s){return[g({types:t},s)]}static out(t=[],s){return[g({types:t},s)]}static isDflowNode(c){var p=c,{kind:t,inputs:s=[],outputs:u=[]}=p,r=j(p,["kind","inputs","outputs"]);return F.isDflowItem(r)&&o.isStringNotEmpty(t)&&s.every(d=>ys.isDflowInput(d))&&u.every(d=>ks.isDflowOutput(d))}get inputs(){return a(this,$).values()}get outputs(){return a(this,B).values()}get numInputs(){return a(this,$).size}get numOutputs(){return a(this,B).size}clearOutputs(){for(const t of this.outputs)t.clear()}getInputById(t){if(typeof t!="string")throw new TypeError(E("inputId"));const s=a(this,$).get(t);if(s)return s;throw new Error(ms(this.id,"input",t))}input(t){const s=a(this,W)[t];if(!s)throw new Error(ls(this.id,"input",t));return this.getInputById(s)}getOutputById(t){if(typeof t!="string")throw new TypeError(E("outputId"));const s=a(this,B).get(t);if(s)return s;throw new Error(ms(this.id,"output",t))}output(t){const s=a(this,Q)[t];if(!s)throw new Error(ls(this.id,"output",t));return this.getOutputById(s)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),a(this,$).delete(t),a(this,W).splice(a(this,W).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),a(this,B).delete(t),a(this,Q).splice(a(this,Q).indexOf(t),1)}newInput(t){const s=o.isDflowId(t.id)?t.id:U(this,Zt,bs).call(this),u=new ys(O(g({},t),{id:s}));return a(this,$).set(s,u),a(this,W).push(s),u}newOutput(t){const s=o.isDflowId(t.id)?t.id:U(this,At,Is).call(this),u=new ks(O(g({},t),{id:s}));return a(this,B).set(s,u),a(this,Q).push(s),u}run(){}toObject(){const t=O(g({},super.toObject()),{kind:this.kind}),s=[],u=[];for(const r of this.inputs)s.push(r.toObject());s.length>0&&(t.inputs=s);for(const r of this.outputs)u.push(r.toObject());return u.length>0&&(t.outputs=u),t}}$=new WeakMap,B=new WeakMap,W=new WeakMap,Q=new WeakMap,Zt=new WeakSet,bs=function(t=this.numInputs){const s=`i${t}`;return a(this,$).has(s)?U(this,Zt,bs).call(this,t+1):s},At=new WeakSet,Is=function(t=this.numOutputs){const s=`o${t}`;return a(this,B).has(s)?U(this,At,Is).call(this,t+1):s},i(n,"kind"),i(n,"isAsync"),i(n,"isConstant"),i(n,"inputs"),i(n,"outputs");const ds=class extends n{constructor(t,s){super(O(g({},t),{kind:ds.kind}),s)}run(){}};let rs=ds;i(rs,"kind","Unknown");class vs extends F{constructor(r){var c=r,{source:t,target:s}=c,u=j(c,["source","target"]);super(u);i(this,"source");i(this,"target");const[p,d]=t,[m,l]=s;if(typeof p!="string")throw new TypeError(E("sourceNodeId"));if(typeof d!="string")throw new TypeError(E("sourcePinId"));if(typeof m!="string")throw new TypeError(E("targetNodeId"));if(typeof l!="string")throw new TypeError(E("targetPinId"));this.source=t,this.target=s}static isDflowEdge(c,r){var p=c,{source:t,target:s}=p,u=j(p,["source","target"]);return F.isDflowItem(u)&&Array.isArray(t)&&t.length===2&&r.nodes.find(({id:d,outputs:m=[]})=>d===t[0]&&m.find(({id:l})=>l===t[1]))&&Array.isArray(s)&&s.length===2&&r.nodes.find(({id:d,inputs:m=[]})=>d===s[0]&&m.find(({id:l})=>l===s[1]))}toObject(){return O(g({},super.toObject()),{source:this.source,target:this.target})}}const v=class extends F{constructor(){super(...arguments);I(this,f,new Map);I(this,x,new Map);i(this,"runOptions",{verbose:!1});i(this,"runStatus",null);i(this,"executionReport",null)}static childrenOfNodeId(t,s){return s.filter(({sourceId:u})=>t===u).map(({targetId:u})=>u)}static parentsOfNodeId(t,s){return s.filter(({targetId:u})=>t===u).map(({sourceId:u})=>u)}static levelOfNodeId(t,s){const u=v.parentsOfNodeId(t,s);if(u.length===0)return 0;let r=0;for(const c of u){const p=v.levelOfNodeId(c,s);r=Math.max(p,r)}return r+1}static ancestorsOfNodeId(t,s){const u=v.parentsOfNodeId(t,s);return u.length===0?[]:u.reduce((r,c,p,d)=>{const m=v.ancestorsOfNodeId(c,s),l=r.concat(m);return p===d.length-1?Array.from(new Set(d.concat(l))):l},[])}static sort(t,s){const u={};for(const r of t)u[r]=v.levelOfNodeId(r,s);return t.slice().sort((r,c)=>u[r]<=u[c]?-1:1)}get edges(){return a(this,x).values()}get nodes(){return a(this,f).values()}get nodeConnections(){return[...a(this,x).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...a(this,x).keys()]}get nodeIds(){return[...a(this,f).keys()]}get numEdges(){return a(this,x).size}get numNodes(){return a(this,f).size}addEdge(t){if(a(this,x).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);a(this,x).set(t.id,t)}addNode(t){if(a(this,f).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);a(this,f).set(t.id,t)}clear(){a(this,f).clear(),a(this,x).clear()}deleteEdge(t){a(this,x).delete(t)}deleteNode(t){a(this,f).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(E("nodeId"));const s=a(this,f).get(t);if(s)return s;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(E("edgeId"));const s=a(this,x).get(t);if(s)return s;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const s=`e${t}`;return a(this,x).has(s)?this.generateEdgeId(t+1):s}generateNodeId(t=this.numNodes){const s=`n${t}`;return a(this,f).has(s)?this.generateNodeId(t+1):s}nodeIdsInsideFunctions(){const t=[];for(const s of this.nodes)s.kind==="return"&&t.push(v.ancestorsOfNodeId(s.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){var r,c;const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const s=this.nodeIdsInsideFunctions(),u=v.sort(this.nodeIds.filter(p=>!s.includes(p)),this.nodeConnections);s:for(const p of u){const d=a(this,f).get(p);try{if(!d.meta.isConstant){let m=!1;t:for(const{id:l,data:k,types:S,isOptional:b}of d.inputs){if(b&&typeof k>"u")continue t;if(!o.validate(k,S)){m=!0,t&&((r=this.executionReport.steps)==null||r.push(as(d.toObject(),`invalid input data nodeId=${p} inputId=${l} data=${k}`)));break t}}if(m){for(const l of d.outputs)l.clear();continue s}d.meta.isAsync?await d.run():d.run()}t&&((c=this.executionReport.steps)==null||c.push(as(d.toObject())))}catch(m){console.error(m),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=O(g({},super.toObject()),{nodes:[],edges:[]});for(const s of this.nodes)t.nodes.push(s.toObject());for(const s of this.edges)t.edges.push(s.toObject());return t}};let V=v;f=new WeakMap,x=new WeakMap;const{input:fs,output:xs}=n;class J extends n{}i(J,"kind","argument"),i(J,"isConstant",!0),i(J,"inputs",[fs("number",{name:"position",optional:!0})]),i(J,"outputs",[xs()]);class X extends n{run(){const t=this.input(0).data;o.isArray(t)?this.output(0).data=t:this.output(0).clear()}}i(X,"kind","array"),i(X,"inputs",n.in()),i(X,"outputs",n.out(["array"]));class Y extends n{run(){const t=this.input(0).data;o.isBoolean(t)?this.output(0).data=t:this.output(0).clear()}}i(Y,"kind","boolean"),i(Y,"inputs",[fs()]),i(Y,"outputs",[xs("boolean")]);class Z extends n{}i(Z,"kind","data"),i(Z,"isConstant",!0),i(Z,"outputs",n.out());class A extends n{constructor(...t){super(...t);this.output(0).data=this.id}}i(A,"kind","function"),i(A,"isConstant",!0),i(A,"outputs",n.out(["DflowId"],{name:"id"}));class wt extends n{run(){const t=this.output(0);t.data=this.host.nodeKinds}}i(wt,"kind","dflow"),i(wt,"outputs",n.out(["array"],{name:"nodeKinds"}));class H extends n{run(){this.output(0).data=o.isUndefined(this.input(0).data)}}i(H,"kind","isUndefined"),i(H,"inputs",n.in()),i(H,"outputs",n.out(["boolean"]));class w extends n{run(){const t=this.input(0).data;o.isNumber(t)?this.output(0).data=t:this.output(0).clear()}}i(w,"kind","number"),i(w,"inputs",n.in()),i(w,"outputs",n.out(["number"]));class G extends n{run(){const t=this.input(0).data;o.isObject(t)?this.output(0).data=t:this.output(0).clear()}}i(G,"kind","object"),i(G,"inputs",n.in()),i(G,"outputs",n.out(["object"]));class K extends n{}i(K,"kind","return"),i(K,"isConstant",!0),i(K,"inputs",[...n.in(["DflowId"],{name:"functionId"}),...n.in([],{name:"value"})]);class q extends n{run(){const t=this.input(0).data;o.isString(t)?this.output(0).data=t:this.output(0).clear()}}i(q,"kind","string"),i(q,"inputs",n.in()),i(q,"outputs",n.out(["string"]));const Ps={[J.kind]:J,[X.kind]:X,[Y.kind]:Y,[Z.kind]:Z,[wt.kind]:wt,[H.kind]:H,[w.kind]:w,[G.kind]:G,[A.kind]:A,[q.kind]:q,[K.kind]:K},is=class{constructor(t={}){I(this,h,void 0);i(this,"nodesCatalog");i(this,"context");this.nodesCatalog=g(g({},t),Ps),C(this,h,new V({id:"g1"})),this.context={}}get executionReport(){return a(this,h).executionReport}get edges(){return a(this,h).edges}get nodes(){return a(this,h).nodes}get numEdges(){return a(this,h).numEdges}get numNodes(){return a(this,h).numNodes}get nodeKinds(){return Object.keys(this.nodesCatalog)}get runStatusIsSuccess(){return a(this,h).runStatus==="success"}get runStatusIsWaiting(){return a(this,h).runStatus==="waiting"}get runStatusIsFailure(){return a(this,h).runStatus==="failure"}set verbose(t){a(this,h).runOptions.verbose=t}clearGraph(){a(this,h).clear()}connect(t,s=0){return{to:(u,r=0)=>{const c=a(this,h).generateEdgeId(),p=t.output(s),d=u.input(r);this.newEdge({id:c,source:[t.id,p.id],target:[u.id,d.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(E("edgeId"));const s=a(this,h).getEdgeById(t);if(s){const[u,r]=s.target;this.getNodeById(u).getInputById(r).disconnect(),a(this,h).deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(E("nodeId"));const s=this.getNodeById(t);if(s){for(const u of a(this,h).edges){const{source:[r],target:[c]}=u;(r===s.id||c===s.id)&&this.deleteEdge(u.id)}a(this,h).deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,s]){for(const u of this.edges){const[r,c]=u.source,[p,d]=u.target;(r===t&&c===s||p===t&&d===s)&&this.deleteEdge(u.id)}}executeFunction(t,s){var l,k;const{verbose:u}=a(this,h).runOptions,r=a(this,h).nodeConnections,c=V.childrenOfNodeId(t,r),p=[];for(const S of c){const b=this.getNodeById(S);b.kind===K.kind&&p.push(b.id)}const d=p.reduce((S,b,z,ns)=>{const Es=V.ancestorsOfNodeId(b,r),cs=S.concat(Es);return z===ns.length?Array.from(new Set(cs)):cs},[]),m=V.sort([...p,...d],r);for(const S of m){const b=this.getNodeById(S);try{switch(b.kind){case J.kind:{const z=b.input(0).data,ns=typeof z=="number"&&!isNaN(z)?Math.max(z,0):0;b.output(0).data=s[ns];break}case K.kind:return b.input(1).data;default:!b.meta.isConstant&&!b.meta.isAsync&&b.run(),u&&((k=(l=this.executionReport)==null?void 0:l.steps)==null||k.push(as(b.toObject())))}}catch(z){console.error(z)}}}getEdgeById(t){return a(this,h).getEdgeById(t)}getNodeById(t){return a(this,h).getNodeById(t)}newNode(t){var m,l,k;const s=(m=this.nodesCatalog[t.kind])!=null?m:rs,u=o.isDflowId(t.id)?t.id:a(this,h).generateNodeId(),r={isAsync:s.isAsync,isConstant:s.isConstant},c=Array.isArray(t.inputs)?t.inputs:U(l=is,ts,$s).call(l,s.inputs),p=Array.isArray(t.outputs)?t.outputs:U(k=is,ss,Bs).call(k,s.outputs),d=new s(O(g({},t),{id:u,inputs:c,outputs:p}),this,r);return a(this,h).addNode(d),d}newEdge(t){const s=o.isDflowId(t.id)?t.id:a(this,h).generateEdgeId(),u=new vs(O(g({},t),{id:s}));a(this,h).addEdge(u);const[r,c]=u.source,[p,d]=u.target,m=a(this,h).getNodeById(r),l=a(this,h).getNodeById(p),k=m.getOutputById(c);return l.getInputById(d).connectTo(k),u}newInput(t,s){return a(this,h).getNodeById(t).newInput(s)}newOutput(t,s){return a(this,h).getNodeById(t).newOutput(s)}toObject(){return a(this,h).toObject()}async run(){await a(this,h).run()}};let os=is;h=new WeakMap,ts=new WeakSet,$s=function(t=[]){return t.map((s,u)=>O(g({},s),{id:`i${u}`}))},ss=new WeakSet,Bs=function(t=[]){return t.map((s,u)=>O(g({},s),{id:`o${u}`}))},I(os,ts),I(os,ss);class L extends n{run(){const t=this.input(0).data,s=this.input(1).data;this.output(0).data=t.at(s)}}i(L,"kind","arrayAt"),i(L,"inputs",[...n.in(["array"]),...n.in(["number"],{name:"index"})]),i(L,"outputs",n.out());class M extends n{run(){this.output(0).data=this.input(0).data.filter((...t)=>this.host.executeFunction(this.input(1).data,t))}}i(M,"kind","arrayFilter"),i(M,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),i(M,"outputs",n.out(["array"]));class _ extends n{run(){this.output(0).data=this.input(0).data.findLastIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}i(_,"kind","arrayFindLastIndex"),i(_,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),i(_,"outputs",n.out(["number"]));class D extends n{run(){this.output(0).data=this.input(0).data.findIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}i(D,"kind","arrayFindIndex"),i(D,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),i(D,"outputs",n.out(["number"]));class tt extends n{run(){const t=this.input(0).data,s=this.input(1).data;Array.isArray(t)&&(this.output(0).data=t.includes(s))}}i(tt,"kind","arrayIncludes"),i(tt,"inputs",[...n.in(["array"],{name:"array"}),...n.in(["string"],{name:"element"})]),i(tt,"outputs",n.out(["boolean"]));class st extends n{run(){this.output(0).data=this.input(0).data.join(this.input(1).data)}}i(st,"kind","arrayJoin"),i(st,"inputs",[...n.in(["array"],{name:"array"}),...n.in(["string"],{name:"separator",optional:!0})]),i(st,"outputs",n.out(["string"]));class it extends n{run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t.length:this.output(0).clear}}i(it,"kind","arrayLength"),i(it,"inputs",n.in(["array"])),i(it,"outputs",n.out(["number"]));class nt extends n{run(){this.output(0).data=this.input(0).data.map((...t)=>this.host.executeFunction(this.input(1).data,t))}}i(nt,"kind","arrayMap"),i(nt,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),i(nt,"outputs",n.out(["array"]));class et extends n{run(){const t=this.input(0).data.slice(),s=t.pop();this.output(0).data=s,this.output(1).data=t}}i(et,"kind","arrayPop"),i(et,"inputs",n.in(["array"])),i(et,"outputs",[...n.out([],{name:"element"}),...n.out(["array"],{name:"rest"})]);class ut extends n{run(){const t=this.input(0).data.slice(),s=this.input(1).data;s&&t.push(s),this.output(0).data=t}}i(ut,"kind","arrayPush"),i(ut,"inputs",[...n.in(["array"]),...n.in([],{name:"element"})]),i(ut,"outputs",n.out(["array"]));class at extends n{run(){const t=this.input(0).data.slice();this.output(0).data=t.reverse()}}i(at,"kind","arrayReverse"),i(at,"inputs",n.in(["array"])),i(at,"outputs",n.in(["array"]));class rt extends n{run(){const t=this.input(0).data.slice(),s=t.shift();this.output(0).data=s,this.output(1).data=t}}i(rt,"kind","arrayShift"),i(rt,"inputs",n.in(["array"])),i(rt,"outputs",[...n.out([],{name:"element"}),...n.out(["array"],{name:"rest"})]);class ot extends n{run(){const t=super.input(0).data,s=super.input(1).data,u=super.input(2).data;typeof u=="number"?super.output(0).data=t.slice(s,u):super.output(0).data=t.slice(s)}}i(ot,"kind","arraySlice"),i(ot,"inputs",[...n.in(["array"]),...n.in(["number"],{name:"start"}),...n.in(["number"],{name:"end",optional:!0})]),i(ot,"outputs",n.out(["array"]));const Ss={[L.kind]:L,[M.kind]:M,[_.kind]:_,[D.kind]:D,[tt.kind]:tt,[st.kind]:st,[it.kind]:it,[nt.kind]:nt,[et.kind]:et,[ut.kind]:ut,[at.kind]:at,[rt.kind]:rt,[ot.kind]:ot};class dt extends n{run(){this.output(0).data=this.input(0).data?this.input(1).data:this.input(2).data}}i(dt,"kind","if"),i(dt,"inputs",[...n.in([],{name:"condition"}),...n.in([],{name:"then"}),...n.in([],{name:"else"})]),i(dt,"outputs",n.out());const Cs={[dt.kind]:dt};class Gt extends n{run(){console.log(this.input(0).data)}}i(Gt,"kind","consoleLog"),i(Gt,"inputs",[...n.in([])]);const Rs={[Gt.kind]:Gt},Os=[...n.out(["string"]),...n.out(["number"],{name:"milliseconds"})];class ct extends n{run(){const t=this.input(0).data;if(typeof t=="string"||typeof t=="number"){const u=new Date(t),r=u.toJSON();r!==null&&(this.output(0).data=r,this.output(1).data=u.getTime())}const s=new Date;this.output(0).data=s.toJSON(),this.output(1).data=s.getTime()}}i(ct,"kind","newDate"),i(ct,"inputs",n.in(["string","number"],{optional:!0})),i(ct,"outputs",Os);class qt extends n{run(){const t=Date.now();this.output(0).data=new Date(t).toJSON(),this.output(1).data=t}}i(qt,"kind","now"),i(qt,"outputs",Os);const zs={[ct.kind]:ct,[qt.kind]:qt},{input:Lt,output:Us}=n;class pt extends n{run(){this.output(0).data=this.input(0).data&&this.input(1).data}}i(pt,"kind","and"),i(pt,"inputs",[Lt("boolean"),Lt("boolean")]),i(pt,"outputs",[Us("boolean")]);class ht extends n{run(){this.output(0).data=!this.input(0).data}}i(ht,"kind","not"),i(ht,"inputs",n.in(["boolean"])),i(ht,"outputs",n.out(["boolean"]));class gt extends n{run(){var t;this.output(0).data=(t=this.input(0).data)!=null?t:this.input(1).data}}i(gt,"kind","??"),i(gt,"inputs",[...n.in(),...n.in()]),i(gt,"outputs",n.out());class lt extends n{run(){this.output(0).data=this.input(0).data||this.input(1).data}}i(lt,"kind","or"),i(lt,"inputs",[Lt("boolean"),Lt("boolean")]),i(lt,"outputs",n.out(["boolean"]));const Fs={[pt.kind]:pt,[ht.kind]:ht,[gt.kind]:gt,[lt.kind]:lt},{input:Js,output:Ks}=n;class mt extends n{run(){this.output(0).data=Math.abs(this.input(0).data)}}i(mt,"kind","mathAbs"),i(mt,"inputs",n.in(["number"])),i(mt,"outputs",n.out(["number"]));class yt extends n{run(){this.output(0).data=Math.cos(this.input(0).data)}}i(yt,"kind","mathCos"),i(yt,"inputs",[Js("number")]),i(yt,"outputs",n.out(["number"]));class kt extends n{run(){this.output(0).data=Math.cosh(this.input(0).data)}}i(kt,"kind","mathCosh"),i(kt,"inputs",n.in(["number"])),i(kt,"outputs",n.out(["number"]));class bt extends n{run(){this.output(0).data=Math.floor(this.input(0).data)}}i(bt,"kind","mathFloor"),i(bt,"inputs",n.in(["number"])),i(bt,"outputs",n.out(["number"]));class It extends n{run(){const t=this.input(0).data,s=Math.max(...t);isNaN(s)?this.output(0).clear():this.output(0).data=s}}i(It,"kind","mathMax"),i(It,"inputs",n.in(["array"])),i(It,"outputs",n.out(["number"]));class ft extends n{run(){const t=this.input(0).data,s=Math.min(...t);isNaN(s)?this.output(0).clear():this.output(0).data=s}}i(ft,"kind","mathMin"),i(ft,"inputs",n.in(["array"])),i(ft,"outputs",n.out(["number"]));class xt extends n{}i(xt,"kind","mathPI"),i(xt,"isConstant",!0),i(xt,"outputs",[Ks("number",{name:"\u03C0",data:Math.PI})]);class Ot extends n{run(){this.output(0).data=Math.round(this.input(0).data)}}i(Ot,"kind","mathRound"),i(Ot,"inputs",n.in(["number"])),i(Ot,"outputs",n.out(["number"]));class Et extends n{run(){this.output(0).data=Math.sin(this.input(0).data)}}i(Et,"kind","mathSin"),i(Et,"inputs",n.in(["number"])),i(Et,"outputs",n.out(["number"]));class Nt extends n{run(){this.output(0).data=Math.sinh(this.input(0).data)}}i(Nt,"kind","mathSinh"),i(Nt,"inputs",n.in(["number"])),i(Nt,"outputs",n.out(["number"]));const Ws={[mt.kind]:mt,[yt.kind]:yt,[kt.kind]:kt,[bt.kind]:bt,[It.kind]:It,[ft.kind]:ft,[xt.kind]:xt,[Ot.kind]:Ot,[Et.kind]:Et,[Nt.kind]:Nt};class Tt extends n{run(){this.output(0).data=Number.isFinite(this.input(0).data)}}i(Tt,"kind","isFinite"),i(Tt,"inputs",n.in(["number"])),i(Tt,"outputs",n.out(["boolean"]));class jt extends n{run(){this.output(0).data=Number.isInteger(this.input(0).data)}}i(jt,"kind","isInteger"),i(jt,"inputs",n.in([])),i(jt,"outputs",n.out(["boolean"]));class vt extends n{run(){this.output(0).data=Number.isNaN(this.input(0).data)}}i(vt,"kind","isNaN"),i(vt,"inputs",n.in([])),i(vt,"outputs",n.out(["boolean"]));class Pt extends n{run(){this.output(0).data=parseFloat(this.input(0).data)}}i(Pt,"kind","parseFloat"),i(Pt,"inputs",n.in(["string"])),i(Pt,"outputs",n.out(["number"]));class $t extends n{run(){this.output(0).data=parseInt(this.input(0).data)}}i($t,"kind","parseInt"),i($t,"inputs",n.in(["number","string"])),i($t,"outputs",n.out(["number"]));const Qs={[Tt.kind]:Tt,[jt.kind]:jt,[vt.kind]:vt,[Pt.kind]:Pt,[$t.kind]:$t};class Bt extends n{run(){this.output(0).data=Object.keys(this.input(0).data)}}i(Bt,"kind","objectKeys"),i(Bt,"inputs",n.in(["object"])),i(Bt,"outputs",n.out(["array"]));class St extends n{run(){this.output(0).data=Object.values(this.input(0).data)}}i(St,"kind","objectValues"),i(St,"inputs",n.in(["object"])),i(St,"outputs",n.out(["array"]));const Vs={[Bt.kind]:Bt,[St.kind]:St},{input:y,output:T}=n;class Ct extends n{run(){this.output(0).data=this.input(0).data+this.input(1).data}}i(Ct,"kind","addition"),i(Ct,"inputs",[y("number"),y("number")]),i(Ct,"outputs",[T("number")]);class Rt extends n{run(){this.input(1).data?this.output(0).data=this.input(0).data/this.input(1).data:this.output(0).clear()}}i(Rt,"kind","division"),i(Rt,"inputs",[y("number"),y("number")]),i(Rt,"outputs",[T("number")]);class zt extends n{run(){this.output(0).data=this.input(0).data==this.input(1).data}}i(zt,"kind","equality"),i(zt,"inputs",[y(),y()]),i(zt,"outputs",[T("boolean")]);class Ut extends n{run(){this.output(0).data=this.input(0).data<this.input(1).data}}i(Ut,"kind","lessThan"),i(Ut,"inputs",[y("number"),y("number")]),i(Ut,"outputs",[T("boolean")]);class Ft extends n{run(){this.output(0).data=this.input(0).data<=this.input(1).data}}i(Ft,"kind","lessThanOrEqual"),i(Ft,"inputs",[y("number"),y("number")]),i(Ft,"outputs",[T("boolean")]);class Jt extends n{run(){this.output(0).data=this.input(0).data>this.input(1).data}}i(Jt,"kind","greaterThan"),i(Jt,"inputs",[y("number"),y("number")]),i(Jt,"outputs",[T("boolean")]);class Kt extends n{run(){this.output(0).data=this.input(0).data>=this.input(1).data}}i(Kt,"kind","greaterThanOrEqual"),i(Kt,"inputs",[y("number"),y("number")]),i(Kt,"outputs",[T("boolean")]);class Wt extends n{run(){this.output(0).data=this.input(0).data!=this.input(1).data}}i(Wt,"kind","inequality"),i(Wt,"inputs",[y(),y()]),i(Wt,"outputs",[T("boolean")]);class Qt extends n{run(){this.output(0).data=this.input(0).data*this.input(1).data}}i(Qt,"kind","multiplication"),i(Qt,"inputs",[y("number"),y("number")]),i(Qt,"outputs",[T("number")]);class Vt extends n{run(){this.output(0).data=this.input(0).data-this.input(1).data}}i(Vt,"kind","subtraction"),i(Vt,"inputs",[y("number"),y("number")]),i(Vt,"outputs",[T("number")]);const Xs={[Ct.kind]:Ct,[Rt.kind]:Rt,[zt.kind]:zt,[Jt.kind]:Jt,[Kt.kind]:Kt,[Ut.kind]:Ut,[Ft.kind]:Ft,[Wt.kind]:Wt,[Qt.kind]:Qt,[Vt.kind]:Vt},{input:Mt,output:Ys}=n;class _t extends n{run(){this.output(0).data=this.input(0).data.length}}i(_t,"kind","stringLength"),i(_t,"inputs",[Mt("string")]),i(_t,"outputs",[Ys("number")]);class Dt extends n{run(){const t=this.input(0).data,s=this.input(1).data,u=this.input(2).data;this.output(0).data=t.substring(s,u)}}i(Dt,"kind","substring"),i(Dt,"inputs",[Mt("string"),Mt("number",{name:"start"}),Mt("number",{name:"end",optional:!0})]),i(Dt,"outputs",n.out(["string"]));const Zs={DflowNodeStringLength:_t,DflowNodeSubstring:Dt},As=Object.values(Zs).reduce((e,t)=>g({[t.kind]:t},e),{}),Hs=g(g(g(g(g(g(g(g(g(g({},Ss),Cs),Rs),zs),Fs),Ws),Qs),Vs),Xs),As);export{Hs as nodesCatalog};
