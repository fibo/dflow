var vs=Object.defineProperty,Ps=Object.defineProperties;var js=Object.getOwnPropertyDescriptors;var Yt=Object.getOwnPropertySymbols;var ps=Object.prototype.hasOwnProperty,hs=Object.prototype.propertyIsEnumerable;var es=(e,t,s)=>t in e?vs(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,h=(e,t)=>{for(var s in t||(t={}))ps.call(t,s)&&es(e,s,t[s]);if(Yt)for(var s of Yt(t))hs.call(t,s)&&es(e,s,t[s]);return e},O=(e,t)=>Ps(e,js(t));var v=(e,t)=>{var s={};for(var u in e)ps.call(e,u)&&t.indexOf(u)<0&&(s[u]=e[u]);if(e!=null&&Yt)for(var u of Yt(e))t.indexOf(u)<0&&hs.call(e,u)&&(s[u]=e[u]);return s};var i=(e,t,s)=>(es(e,typeof t!="symbol"?t+"":t,s),s),us=(e,t,s)=>{if(!t.has(e))throw TypeError("Cannot "+s)};var a=(e,t,s)=>(us(e,t,"read from private field"),s?s.call(e):t.get(e)),k=(e,t,s)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,s)},C=(e,t,s,u)=>(us(e,t,"write to private field"),u?u.call(e,s):t.set(e,s),s);var R=(e,t,s)=>(us(e,t,"access private method"),s);var A,Qt,j,B,$,F,J,Vt,fs,Xt,Is,I,x,p,ts,$s,ss,Ss;const T=e=>`${e} must be a string`,ls=e=>`${e} must be a number`,gs=(e,t)=>`${t} pin not found nodeId=${e}`,ys=(e,t,s)=>`${gs(e,t)} position=${s}`,ms=(e,t,s)=>`${gs(e,t)} pinId=${s}`,as=({id:e,kind:t,outputs:s})=>({id:e,kind:t,outputs:s==null?void 0:s.map(({id:u,data:r,name:d})=>({id:u,data:r,name:d}))});class o{static isArray(t){return Array.isArray(t)}static isBoolean(t){return typeof t=="boolean"}static isDflowGraph(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)&&Array.isArray(t.nodes)&&Array.isArray(t.edges)&&K.isDflowGraph(t)}static isDflowId(t){return o.isStringNotEmpty(t)}static isDflowType(t){return typeof t=="string"&&E.types.includes(t)}static isObject(t){return!o.isUndefined(t)&&!o.isNull(t)&&!o.isArray(t)&&typeof t=="object"}static isNull(t){return t===null}static isNumber(t){return typeof t=="number"&&!isNaN(t)}static isString(t){return typeof t=="string"}static isStringNotEmpty(t){return o.isString(t)&&t.length>0}static isUndefined(t){return typeof t>"u"}static validate(t,s){return s.length===0?!0:s.some(u=>{switch(u){case"array":return o.isArray(t);case"boolean":return o.isBoolean(t);case"null":return o.isNull(t);case"number":return o.isNumber(t);case"object":return o.isObject(t);case"string":return o.isString(t);case"DflowGraph":return o.isDflowGraph(t);case"DflowId":return o.isDflowId(t);case"DflowType":return o.isDflowType(t);default:return!1}},!0)}}class U{constructor({id:t,name:s}){i(this,"id");i(this,"name");this.id=t,this.name=s}static isDflowItem({id:t,name:s}){return o.isDflowId(t)&&(o.isUndefined(s)||o.isStringNotEmpty(s))}toObject(){const t={id:this.id};return typeof this.name=="string"&&(t.name=this.name),t}}const Wt=class extends U{constructor(t,r){var d=r,{types:s=[]}=d,u=v(d,["types"]);super(u);i(this,"kind");i(this,"types");this.kind=t,this.types=s}static isDflowPin(u){var r=u,{types:t=[]}=r,s=v(r,["types"]);return U.isDflowItem(s)&&Wt.isDflowPinTypes(t)}static isDflowPinType(t){return typeof t!="string"?!1:Wt.types.includes(t)}static isDflowPinTypes(t){return Array.isArray(t)?t.every(s=>Wt.isDflowPinType(s)):!1}get hasTypeAny(){return this.types.length===0}hasType(t){return this.hasTypeAny||this.types.includes(t)}};let E=Wt;i(E,"types",["string","number","boolean","null","object","array","DflowId","DflowGraph","DflowType"]);class ks extends E{constructor(u){var r=u,{optional:t}=r,s=v(r,["optional"]);super("input",s);k(this,A,void 0);k(this,Qt,void 0);C(this,Qt,t)}static isDflowInput({id:t,types:s}){return E.isDflowPin({id:t,types:s})}get data(){var t;return(t=a(this,A))==null?void 0:t.data}get isConnected(){return typeof a(this,A)>"u"}get isOptional(){return a(this,Qt)}connectTo(t){const{hasTypeAny:s,types:u}=this,{types:r}=t;if(s||u.some(d=>r.includes(d)))C(this,A,t);else throw new Error(`mismatching pinTypes, source has types [${r.join()}] and target has types [${u.join()}]`)}disconnect(){C(this,A,void 0)}toObject(){const t={id:this.id};return this.types.length>0&&(t.types=this.types),t}}A=new WeakMap,Qt=new WeakMap;class bs extends E{constructor(u){var r=u,{data:t}=r,s=v(r,["data"]);super("output",s);k(this,j,void 0);C(this,j,t)}static isDflowOutput({id:t,data:s,types:u=[]}){return E.isDflowPin({id:t,types:u})&&o.validate(s,u)}clear(){C(this,j,void 0)}get data(){return a(this,j)}set data(t){switch(!0){case o.isUndefined(t):this.clear();break;case this.hasTypeAny:case(o.isDflowGraph(t)&&this.hasType("DflowGraph")):case(o.isDflowId(t)&&this.hasType("DflowId")):case(o.isString(t)&&this.hasType("string")):case(o.isNumber(t)&&this.hasType("number")):case(o.isBoolean(t)&&this.hasType("boolean")):case(o.isNull(t)&&this.hasType("null")):case(o.isObject(t)&&this.hasType("object")):case(o.isArray(t)&&this.hasType("array")):{C(this,j,t);break}default:throw new Error(`could not set data pinTypes=${JSON.stringify(this.types)} typeof=${typeof t}`)}}toObject(){const t=h({},super.toObject());return o.isUndefined(a(this,j))||(t.data=a(this,j)),this.types.length>0&&(t.types=this.types),t}}j=new WeakMap;class n extends U{constructor(y,d,{isAsync:l=!1,isConstant:c=!1}={}){var g=y,{kind:t,inputs:s=[],outputs:u=[]}=g,r=v(g,["kind","inputs","outputs"]);super(r);k(this,Vt);k(this,Xt);k(this,B,new Map);k(this,$,new Map);k(this,F,[]);k(this,J,[]);i(this,"kind");i(this,"meta");i(this,"host");this.host=d,this.kind=t,this.meta={isAsync:l,isConstant:c};for(const b of s)this.newInput(b);for(const b of u)this.newOutput(b)}static input(t=[],s){if(E.isDflowPinType(t))return h({types:[t]},s);if(E.isDflowPinTypes(t))return h({types:t},s);throw new TypeError("invalid input definition")}static output(t=[],s){if(E.isDflowPinType(t))return h({types:[t]},s);if(E.isDflowPinTypes(t))return h({types:t},s);throw new TypeError("invalid output definition")}static in(t=[],s){return[h({types:t},s)]}static out(t=[],s){return[h({types:t},s)]}static isDflowNode(d){var l=d,{kind:t,inputs:s=[],outputs:u=[]}=l,r=v(l,["kind","inputs","outputs"]);return U.isDflowItem(r)&&o.isStringNotEmpty(t)&&s.every(c=>ks.isDflowInput(c))&&u.every(c=>bs.isDflowOutput(c))}get inputs(){return a(this,B).values()}get outputs(){return a(this,$).values()}get numInputs(){return a(this,B).size}get numOutputs(){return a(this,$).size}clearOutputs(){for(const t of this.outputs)t.clear()}getInputById(t){if(typeof t!="string")throw new TypeError(T("inputId"));const s=a(this,B).get(t);if(s)return s;throw new Error(ms(this.id,"input",t))}input(t){if(typeof t!="number")throw new TypeError(ls("position"));const s=a(this,F)[t];if(o.isUndefined(s))throw new Error(ys(this.id,"input",t));return this.getInputById(s)}getOutputById(t){if(typeof t!="string")throw new TypeError(T("outputId"));const s=a(this,$).get(t);if(s)return s;throw new Error(ms(this.id,"output",t))}output(t){if(typeof t!="number")throw new TypeError(ls("position"));const s=a(this,J)[t];if(o.isUndefined(s))throw new Error(ys(this.id,"output",t));return this.getOutputById(s)}deleteInput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),a(this,B).delete(t),a(this,F).splice(a(this,F).indexOf(t),1)}deleteOutput(t){this.host.deleteEdgesConnectedToPin([this.id,t]),a(this,$).delete(t),a(this,J).splice(a(this,J).indexOf(t),1)}newInput(t){const s=o.isDflowId(t.id)?t.id:R(this,Vt,fs).call(this),u=new ks(O(h({},t),{id:s}));return a(this,B).set(s,u),a(this,F).push(s),u}newOutput(t){const s=o.isDflowId(t.id)?t.id:R(this,Xt,Is).call(this),u=new bs(O(h({},t),{id:s}));return a(this,$).set(s,u),a(this,J).push(s),u}run(){}toObject(){const t=O(h({},super.toObject()),{kind:this.kind}),s=[],u=[];for(const r of this.inputs)s.push(r.toObject());s.length>0&&(t.inputs=s);for(const r of this.outputs)u.push(r.toObject());return u.length>0&&(t.outputs=u),t}}B=new WeakMap,$=new WeakMap,F=new WeakMap,J=new WeakMap,Vt=new WeakSet,fs=function(t=this.numInputs){const s=`i${t}`;return a(this,B).has(s)?R(this,Vt,fs).call(this,t+1):s},Xt=new WeakSet,Is=function(t=this.numOutputs){const s=`o${t}`;return a(this,$).has(s)?R(this,Xt,Is).call(this,t+1):s},i(n,"kind"),i(n,"isAsync"),i(n,"isConstant"),i(n,"inputs"),i(n,"outputs");const ds=class extends n{constructor(t,s){super(O(h({},t),{kind:ds.kind}),s)}run(){}};let rs=ds;i(rs,"kind","Unknown");class xs extends U{constructor(r){var d=r,{source:t,target:s}=d,u=v(d,["source","target"]);super(u);i(this,"source");i(this,"target");const[l,c]=t,[y,g]=s;if(typeof l!="string")throw new TypeError(T("sourceNodeId"));if(typeof c!="string")throw new TypeError(T("sourcePinId"));if(typeof y!="string")throw new TypeError(T("targetNodeId"));if(typeof g!="string")throw new TypeError(T("targetPinId"));this.source=t,this.target=s}static isDflowEdge(d,r){var l=d,{source:t,target:s}=l,u=v(l,["source","target"]);return U.isDflowItem(u)&&Array.isArray(t)&&t.length===2&&r.nodes.find(({id:c,outputs:y=[]})=>c===t[0]&&y.find(({id:g})=>g===t[1]))&&Array.isArray(s)&&s.length===2&&r.nodes.find(({id:c,inputs:y=[]})=>c===s[0]&&y.find(({id:g})=>g===s[1]))}toObject(){return O(h({},super.toObject()),{source:this.source,target:this.target})}}const P=class extends U{constructor(){super(...arguments);k(this,I,new Map);k(this,x,new Map);i(this,"runOptions",{verbose:!1});i(this,"runStatus",null);i(this,"executionReport",null)}static isDflowGraph(t){return t.nodes.every(s=>n.isDflowNode(s))&&t.edges.every(s=>xs.isDflowEdge(s,t))}static childrenOfNodeId(t,s){return s.filter(({sourceId:u})=>t===u).map(({targetId:u})=>u)}static parentsOfNodeId(t,s){return s.filter(({targetId:u})=>t===u).map(({sourceId:u})=>u)}static levelOfNodeId(t,s){const u=P.parentsOfNodeId(t,s);if(u.length===0)return 0;let r=0;for(const d of u){const l=P.levelOfNodeId(d,s);r=Math.max(l,r)}return r+1}static ancestorsOfNodeId(t,s){const u=P.parentsOfNodeId(t,s);return u.length===0?[]:u.reduce((r,d,l,c)=>{const y=P.ancestorsOfNodeId(d,s),g=r.concat(y);return l===c.length-1?Array.from(new Set(c.concat(g))):g},[])}static sort(t,s){const u={};for(const r of t)u[r]=P.levelOfNodeId(r,s);return t.slice().sort((r,d)=>u[r]<=u[d]?-1:1)}get edges(){return a(this,x).values()}get nodes(){return a(this,I).values()}get nodeConnections(){return[...a(this,x).values()].map(t=>({sourceId:t.source[0],targetId:t.target[0]}))}get edgeIds(){return[...a(this,x).keys()]}get nodeIds(){return[...a(this,I).keys()]}get numEdges(){return a(this,x).size}get numNodes(){return a(this,I).size}addEdge(t){if(a(this,x).has(t.id))throw new Error(`cannot overwrite edge, id=${t.id}`);a(this,x).set(t.id,t)}addNode(t){if(a(this,I).has(t.id))throw new Error(`cannot overwrite node, id=${t.id}`);a(this,I).set(t.id,t)}clear(){a(this,I).clear(),a(this,x).clear()}deleteEdge(t){a(this,x).delete(t)}deleteNode(t){a(this,I).delete(t)}getNodeById(t){if(typeof t!="string")throw new TypeError(T("nodeId"));const s=a(this,I).get(t);if(s)return s;throw new Error(`DflowNode not found, id=${t}`)}getEdgeById(t){if(typeof t!="string")throw new TypeError(T("edgeId"));const s=a(this,x).get(t);if(s)return s;throw new Error(`DflowEdge not found, id=${t}`)}generateEdgeId(t=this.numEdges){const s=`e${t}`;return a(this,x).has(s)?this.generateEdgeId(t+1):s}generateNodeId(t=this.numNodes){const s=`n${t}`;return a(this,I).has(s)?this.generateNodeId(t+1):s}nodeIdsInsideFunctions(){const t=[];for(const s of this.nodes)s.kind==="return"&&t.push(P.ancestorsOfNodeId(s.id,this.nodeConnections));return Array.from(new Set(t.flat()))}async run(){var r,d;const{verbose:t}=this.runOptions;this.runStatus="waiting",this.executionReport={status:this.runStatus,start:new Date},t&&(this.executionReport.steps=[]);const s=this.nodeIdsInsideFunctions(),u=P.sort(this.nodeIds.filter(l=>!s.includes(l)),this.nodeConnections);s:for(const l of u){const c=a(this,I).get(l);try{if(!c.meta.isConstant){let y=!1;t:for(const{data:g,types:b,isOptional:S}of c.inputs){if(S&&typeof g>"u")continue t;if(!o.validate(g,b)){y=!0;break t}}if(y){for(const g of c.outputs)g.clear();t&&((r=this.executionReport.steps)==null||r.push(as(c.toObject())));continue s}c.meta.isAsync?await c.run():c.run()}t&&((d=this.executionReport.steps)==null||d.push(as(c.toObject())))}catch(y){console.error(y),this.runStatus="failure"}}this.runStatus==="waiting"&&(this.runStatus="success"),this.executionReport.status=this.runStatus,this.executionReport.end=new Date}toObject(){const t=O(h({},super.toObject()),{nodes:[],edges:[]});for(const s of this.nodes)t.nodes.push(s.toObject());for(const s of this.edges)t.edges.push(s.toObject());return t}};let K=P;I=new WeakMap,x=new WeakMap;const{input:Os,output:Es}=n;class z extends n{}i(z,"kind","argument"),i(z,"isConstant",!0),i(z,"inputs",[Os("number",{name:"position",optional:!0})]),i(z,"outputs",[Es()]);class W extends n{run(){const t=this.input(0).data;o.isArray(t)?this.output(0).data=t:this.output(0).clear()}}i(W,"kind","array"),i(W,"inputs",n.in()),i(W,"outputs",n.out(["array"]));class Q extends n{run(){const t=this.input(0).data;o.isBoolean(t)?this.output(0).data=t:this.output(0).clear()}}i(Q,"kind","boolean"),i(Q,"inputs",[Os()]),i(Q,"outputs",[Es("boolean")]);class V extends n{}i(V,"kind","data"),i(V,"isConstant",!0),i(V,"outputs",n.out());class X extends n{constructor(...t){super(...t);this.output(0).data=this.id}}i(X,"kind","function"),i(X,"isConstant",!0),i(X,"outputs",n.out(["DflowId"],{name:"id"}));class Zt extends n{run(){const t=this.output(0);t.data=this.host.nodeKinds}}i(Zt,"kind","dflow"),i(Zt,"outputs",n.out(["array"],{name:"nodeKinds"}));class Y extends n{run(){this.output(0).data=o.isUndefined(this.input(0).data)}}i(Y,"kind","isUndefined"),i(Y,"inputs",n.in()),i(Y,"outputs",n.out(["boolean"]));class Z extends n{run(){const t=this.input(0).data;o.isNumber(t)?this.output(0).data=t:this.output(0).clear()}}i(Z,"kind","number"),i(Z,"inputs",n.in()),i(Z,"outputs",n.out(["number"]));class H extends n{run(){const t=this.input(0).data;o.isObject(t)?this.output(0).data=t:this.output(0).clear()}}i(H,"kind","object"),i(H,"inputs",n.in()),i(H,"outputs",n.out(["object"]));class G extends n{}i(G,"kind","return"),i(G,"isConstant",!0),i(G,"inputs",[...n.in(["DflowId"],{name:"functionId"}),...n.in([],{name:"value"})]);class q extends n{run(){const t=this.input(0).data;o.isString(t)?this.output(0).data=t:this.output(0).clear()}}i(q,"kind","string"),i(q,"inputs",n.in()),i(q,"outputs",n.out(["string"]));const Bs={[z.kind]:z,[W.kind]:W,[Q.kind]:Q,[V.kind]:V,[Zt.kind]:Zt,[Y.kind]:Y,[Z.kind]:Z,[H.kind]:H,[X.kind]:X,[q.kind]:q,[G.kind]:G},is=class{constructor(t={}){k(this,p,void 0);i(this,"nodesCatalog");i(this,"context");this.nodesCatalog=h(h({},t),Bs),C(this,p,new K({id:"g1"})),this.context={}}get executionReport(){return a(this,p).executionReport}get edges(){return a(this,p).edges}get nodes(){return a(this,p).nodes}get numEdges(){return a(this,p).numEdges}get numNodes(){return a(this,p).numNodes}get nodeKinds(){return Object.keys(this.nodesCatalog)}get runStatusIsSuccess(){return a(this,p).runStatus==="success"}get runStatusIsWaiting(){return a(this,p).runStatus==="waiting"}get runStatusIsFailure(){return a(this,p).runStatus==="failure"}set verbose(t){a(this,p).runOptions.verbose=t}clearGraph(){a(this,p).clear()}connect(t,s=0){return{to:(u,r=0)=>{const d=a(this,p).generateEdgeId(),l=t.output(s),c=u.input(r);this.newEdge({id:d,source:[t.id,l.id],target:[u.id,c.id]})}}}deleteEdge(t){if(typeof t!="string")throw new TypeError(T("edgeId"));const s=a(this,p).getEdgeById(t);if(s){const[u,r]=s.target;this.getNodeById(u).getInputById(r).disconnect(),a(this,p).deleteEdge(t)}else throw new Error(`DflowEdge not found, id=${t}`)}deleteNode(t){if(typeof t!="string")throw new TypeError(T("nodeId"));const s=this.getNodeById(t);if(s){for(const u of a(this,p).edges){const{source:[r],target:[d]}=u;(r===s.id||d===s.id)&&this.deleteEdge(u.id)}a(this,p).deleteNode(t)}else throw new Error(`DflowNode not found, id=${t}`)}deleteEdgesConnectedToPin([t,s]){for(const u of this.edges){const[r,d]=u.source,[l,c]=u.target;(r===t&&d===s||l===t&&c===s)&&this.deleteEdge(u.id)}}executeFunction(t,s){var g,b;const{verbose:u}=a(this,p).runOptions,r=a(this,p).nodeConnections,d=K.childrenOfNodeId(t,r),l=[];for(const S of d){const f=this.getNodeById(S);f.kind===G.kind&&l.push(f.id)}const c=l.reduce((S,f,w,ns)=>{const Ns=K.ancestorsOfNodeId(f,r),cs=S.concat(Ns);return w===ns.length?Array.from(new Set(cs)):cs},[]),y=K.sort([...l,...c],r);for(const S of y){const f=this.getNodeById(S);try{switch(f.kind){case z.kind:{const w=f.input(0).data,ns=typeof w=="number"&&!isNaN(w)?Math.max(w,0):0;f.output(0).data=s[ns];break}case G.kind:return f.input(1).data;default:!f.meta.isConstant&&!f.meta.isAsync&&f.run(),u&&((b=(g=this.executionReport)==null?void 0:g.steps)==null||b.push(as(f.toObject())))}}catch(w){console.error(w)}}}getEdgeById(t){return a(this,p).getEdgeById(t)}getNodeById(t){return a(this,p).getNodeById(t)}newNode(t){var y,g,b;const s=(y=this.nodesCatalog[t.kind])!=null?y:rs,u=o.isDflowId(t.id)?t.id:a(this,p).generateNodeId(),r={isAsync:s.isAsync,isConstant:s.isConstant},d=Array.isArray(t.inputs)?t.inputs:R(g=is,ts,$s).call(g,s.inputs),l=Array.isArray(t.outputs)?t.outputs:R(b=is,ss,Ss).call(b,s.outputs),c=new s(O(h({},t),{id:u,inputs:d,outputs:l}),this,r);return a(this,p).addNode(c),c}newEdge(t){const s=o.isDflowId(t.id)?t.id:a(this,p).generateEdgeId(),u=new xs(O(h({},t),{id:s}));a(this,p).addEdge(u);const[r,d]=u.source,[l,c]=u.target,y=a(this,p).getNodeById(r),g=a(this,p).getNodeById(l),b=y.getOutputById(d);return g.getInputById(c).connectTo(b),u}newInput(t,s){return a(this,p).getNodeById(t).newInput(s)}newOutput(t,s){return a(this,p).getNodeById(t).newOutput(s)}toObject(){return a(this,p).toObject()}async run(){await a(this,p).run()}};let os=is;p=new WeakMap,ts=new WeakSet,$s=function(t=[]){return t.map((s,u)=>O(h({},s),{id:`i${u}`}))},ss=new WeakSet,Ss=function(t=[]){return t.map((s,u)=>O(h({},s),{id:`o${u}`}))},k(os,ts),k(os,ss);class L extends n{run(){const t=this.input(0).data,s=this.input(1).data;this.output(0).data=t.at(s)}}i(L,"kind","arrayAt"),i(L,"inputs",[...n.in(["array"]),...n.in(["number"],{name:"index"})]),i(L,"outputs",n.out());class M extends n{run(){this.output(0).data=this.input(0).data.filter((...t)=>this.host.executeFunction(this.input(1).data,t))}}i(M,"kind","arrayFilter"),i(M,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),i(M,"outputs",n.out(["array"]));class _ extends n{run(){this.output(0).data=this.input(0).data.findLastIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}i(_,"kind","arrayFindLastIndex"),i(_,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),i(_,"outputs",n.out(["number"]));class D extends n{run(){this.output(0).data=this.input(0).data.findIndex((...t)=>this.host.executeFunction(this.input(1).data,t))}}i(D,"kind","arrayFindIndex"),i(D,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),i(D,"outputs",n.out(["number"]));class tt extends n{run(){const t=this.input(0).data,s=this.input(1).data;Array.isArray(t)&&(this.output(0).data=t.includes(s))}}i(tt,"kind","arrayIncludes"),i(tt,"inputs",[...n.in(["array"],{name:"array"}),...n.in(["string"],{name:"element"})]),i(tt,"outputs",n.out(["boolean"]));class st extends n{run(){this.output(0).data=this.input(0).data.join(this.input(1).data)}}i(st,"kind","arrayJoin"),i(st,"inputs",[...n.in(["array"],{name:"array"}),...n.in(["string"],{name:"separator",optional:!0})]),i(st,"outputs",n.out(["string"]));class it extends n{run(){const t=this.input(0).data;Array.isArray(t)?this.output(0).data=t.length:this.output(0).clear}}i(it,"kind","arrayLength"),i(it,"inputs",n.in(["array"])),i(it,"outputs",n.out(["number"]));class nt extends n{run(){this.output(0).data=this.input(0).data.map((...t)=>this.host.executeFunction(this.input(1).data,t))}}i(nt,"kind","arrayMap"),i(nt,"inputs",[...n.in(["array"]),...n.in(["DflowId"],{name:"functionId"})]),i(nt,"outputs",n.out(["array"]));class et extends n{run(){const t=this.input(0).data.slice(),s=t.pop();this.output(0).data=s,this.output(1).data=t}}i(et,"kind","arrayPop"),i(et,"inputs",n.in(["array"])),i(et,"outputs",[...n.out([],{name:"element"}),...n.out(["array"],{name:"rest"})]);class ut extends n{run(){const t=this.input(0).data.slice(),s=this.input(1).data;s&&t.push(s),this.output(0).data=t}}i(ut,"kind","arrayPush"),i(ut,"inputs",[...n.in(["array"]),...n.in([],{name:"element"})]),i(ut,"outputs",n.out(["array"]));class at extends n{run(){const t=this.input(0).data.slice();this.output(0).data=t.reverse()}}i(at,"kind","arrayReverse"),i(at,"inputs",n.in(["array"])),i(at,"outputs",n.in(["array"]));class rt extends n{run(){const t=this.input(0).data.slice(),s=t.shift();this.output(0).data=s,this.output(1).data=t}}i(rt,"kind","arrayShift"),i(rt,"inputs",n.in(["array"])),i(rt,"outputs",[...n.out([],{name:"element"}),...n.out(["array"],{name:"rest"})]);class ot extends n{run(){const t=super.input(0).data,s=super.input(1).data,u=super.input(2).data;typeof u=="number"?super.output(0).data=t.slice(s,u):super.output(0).data=t.slice(s)}}i(ot,"kind","arraySlice"),i(ot,"inputs",[...n.in(["array"]),...n.in(["number"],{name:"start"}),...n.in(["number"],{name:"end",optional:!0})]),i(ot,"outputs",n.out(["array"]));const Cs={[L.kind]:L,[M.kind]:M,[_.kind]:_,[D.kind]:D,[tt.kind]:tt,[st.kind]:st,[it.kind]:it,[nt.kind]:nt,[et.kind]:et,[ut.kind]:ut,[at.kind]:at,[rt.kind]:rt,[ot.kind]:ot};class dt extends n{run(){this.output(0).data=this.input(0).data?this.input(1).data:this.input(2).data}}i(dt,"kind","if"),i(dt,"inputs",[...n.in([],{name:"condition"}),...n.in([],{name:"then"}),...n.in([],{name:"else"})]),i(dt,"outputs",n.out());const ws={[dt.kind]:dt};class Ht extends n{run(){console.log(this.input(0).data)}}i(Ht,"kind","consoleLog"),i(Ht,"inputs",[...n.in([])]);const Rs={[Ht.kind]:Ht},Ts=[...n.out(["string"]),...n.out(["number"],{name:"milliseconds"})];class ct extends n{run(){const t=this.input(0).data;if(typeof t=="string"||typeof t=="number"){const u=new Date(t),r=u.toJSON();r!==null&&(this.output(0).data=r,this.output(1).data=u.getTime())}const s=new Date;this.output(0).data=s.toJSON(),this.output(1).data=s.getTime()}}i(ct,"kind","newDate"),i(ct,"inputs",n.in(["string","number"],{optional:!0})),i(ct,"outputs",Ts);class qt extends n{run(){const t=Date.now();this.output(0).data=new Date(t).toJSON(),this.output(1).data=t}}i(qt,"kind","now"),i(qt,"outputs",Ts);const Us={[ct.kind]:ct,[qt.kind]:qt},{input:Lt,output:zs}=n;class pt extends n{run(){this.output(0).data=this.input(0).data&&this.input(1).data}}i(pt,"kind","and"),i(pt,"inputs",[Lt("boolean"),Lt("boolean")]),i(pt,"outputs",[zs("boolean")]);class ht extends n{run(){this.output(0).data=!this.input(0).data}}i(ht,"kind","not"),i(ht,"inputs",n.in(["boolean"])),i(ht,"outputs",n.out(["boolean"]));class lt extends n{run(){var t;this.output(0).data=(t=this.input(0).data)!=null?t:this.input(1).data}}i(lt,"kind","??"),i(lt,"inputs",[...n.in(),...n.in()]),i(lt,"outputs",n.out());class gt extends n{run(){this.output(0).data=this.input(0).data||this.input(1).data}}i(gt,"kind","or"),i(gt,"inputs",[Lt("boolean"),Lt("boolean")]),i(gt,"outputs",n.out(["boolean"]));const Gs={[pt.kind]:pt,[ht.kind]:ht,[lt.kind]:lt,[gt.kind]:gt},{input:As}=n;class yt extends n{run(){this.output(0).data=Math.abs(this.input(0).data)}}i(yt,"kind","mathAbs"),i(yt,"inputs",n.in(["number"])),i(yt,"outputs",n.out(["number"]));class mt extends n{run(){this.output(0).data=Math.cos(this.input(0).data)}}i(mt,"kind","mathCos"),i(mt,"inputs",[As("number")]),i(mt,"outputs",n.out(["number"]));class kt extends n{run(){this.output(0).data=Math.cosh(this.input(0).data)}}i(kt,"kind","mathCosh"),i(kt,"inputs",n.in(["number"])),i(kt,"outputs",n.out(["number"]));class bt extends n{run(){this.output(0).data=Math.floor(this.input(0).data)}}i(bt,"kind","mathFloor"),i(bt,"inputs",n.in(["number"])),i(bt,"outputs",n.out(["number"]));class ft extends n{run(){const t=this.input(0).data,s=Math.max(...t);isNaN(s)?this.output(0).clear():this.output(0).data=s}}i(ft,"kind","mathMax"),i(ft,"inputs",n.in(["array"])),i(ft,"outputs",n.out(["number"]));class It extends n{run(){const t=this.input(0).data,s=Math.min(...t);isNaN(s)?this.output(0).clear():this.output(0).data=s}}i(It,"kind","mathMin"),i(It,"inputs",n.in(["array"])),i(It,"outputs",n.out(["number"]));class xt extends n{}i(xt,"kind","mathPI"),i(xt,"isConstant",!0),i(xt,"outputs",n.out(["number"],{name:"\u03C0",data:Math.PI}));class Ot extends n{run(){this.output(0).data=Math.round(this.input(0).data)}}i(Ot,"kind","mathRound"),i(Ot,"inputs",n.in(["number"])),i(Ot,"outputs",n.out(["number"]));class Et extends n{run(){this.output(0).data=Math.sin(this.input(0).data)}}i(Et,"kind","mathSin"),i(Et,"inputs",n.in(["number"])),i(Et,"outputs",n.out(["number"]));class Tt extends n{run(){this.output(0).data=Math.sinh(this.input(0).data)}}i(Tt,"kind","mathSinh"),i(Tt,"inputs",n.in(["number"])),i(Tt,"outputs",n.out(["number"]));const Fs={[yt.kind]:yt,[mt.kind]:mt,[kt.kind]:kt,[bt.kind]:bt,[ft.kind]:ft,[It.kind]:It,[xt.kind]:xt,[Ot.kind]:Ot,[Et.kind]:Et,[Tt.kind]:Tt};class Nt extends n{run(){this.output(0).data=Number.isFinite(this.input(0).data)}}i(Nt,"kind","isFinite"),i(Nt,"inputs",n.in(["number"])),i(Nt,"outputs",n.out(["boolean"]));class vt extends n{run(){this.output(0).data=Number.isInteger(this.input(0).data)}}i(vt,"kind","isInteger"),i(vt,"inputs",n.in([])),i(vt,"outputs",n.out(["boolean"]));class Pt extends n{run(){this.output(0).data=Number.isNaN(this.input(0).data)}}i(Pt,"kind","isNaN"),i(Pt,"inputs",n.in([])),i(Pt,"outputs",n.out(["boolean"]));class jt extends n{run(){this.output(0).data=parseFloat(this.input(0).data)}}i(jt,"kind","parseFloat"),i(jt,"inputs",n.in(["string"])),i(jt,"outputs",n.out(["number"]));class Bt extends n{run(){this.output(0).data=parseInt(this.input(0).data)}}i(Bt,"kind","parseInt"),i(Bt,"inputs",n.in(["number","string"])),i(Bt,"outputs",n.out(["number"]));const Js={[Nt.kind]:Nt,[vt.kind]:vt,[Pt.kind]:Pt,[jt.kind]:jt,[Bt.kind]:Bt};class $t extends n{run(){this.output(0).data=Object.keys(this.input(0).data)}}i($t,"kind","objectKeys"),i($t,"inputs",n.in(["object"])),i($t,"outputs",n.out(["array"]));class St extends n{run(){this.output(0).data=Object.values(this.input(0).data)}}i(St,"kind","objectValues"),i(St,"inputs",n.in(["object"])),i(St,"outputs",n.out(["array"]));const Ks={[$t.kind]:$t,[St.kind]:St},{input:m,output:N}=n;class Ct extends n{run(){this.output(0).data=this.input(0).data+this.input(1).data}}i(Ct,"kind","addition"),i(Ct,"inputs",[m("number"),m("number")]),i(Ct,"outputs",[N("number")]);class wt extends n{run(){this.input(1).data?this.output(0).data=this.input(0).data/this.input(1).data:this.output(0).clear()}}i(wt,"kind","division"),i(wt,"inputs",[m("number"),m("number")]),i(wt,"outputs",[N("number")]);class Rt extends n{run(){this.output(0).data=this.input(0).data==this.input(1).data}}i(Rt,"kind","equality"),i(Rt,"inputs",[m(),m()]),i(Rt,"outputs",[N("boolean")]);class Ut extends n{run(){this.output(0).data=this.input(0).data<this.input(1).data}}i(Ut,"kind","lessThan"),i(Ut,"inputs",[m("number"),m("number")]),i(Ut,"outputs",[N("boolean")]);class zt extends n{run(){this.output(0).data=this.input(0).data<=this.input(1).data}}i(zt,"kind","lessThanOrEqual"),i(zt,"inputs",[m("number"),m("number")]),i(zt,"outputs",[N("boolean")]);class Gt extends n{run(){this.output(0).data=this.input(0).data>this.input(1).data}}i(Gt,"kind","greaterThan"),i(Gt,"inputs",[m("number"),m("number")]),i(Gt,"outputs",[N("boolean")]);class At extends n{run(){this.output(0).data=this.input(0).data>=this.input(1).data}}i(At,"kind","greaterThanOrEqual"),i(At,"inputs",[m("number"),m("number")]),i(At,"outputs",[N("boolean")]);class Ft extends n{run(){this.output(0).data=this.input(0).data!=this.input(1).data}}i(Ft,"kind","inequality"),i(Ft,"inputs",[m(),m()]),i(Ft,"outputs",[N("boolean")]);class Jt extends n{run(){this.output(0).data=this.input(0).data*this.input(1).data}}i(Jt,"kind","multiplication"),i(Jt,"inputs",[m("number"),m("number")]),i(Jt,"outputs",[N("number")]);class Kt extends n{run(){this.output(0).data=this.input(0).data-this.input(1).data}}i(Kt,"kind","subtraction"),i(Kt,"inputs",[m("number"),m("number")]),i(Kt,"outputs",[N("number")]);const Ws={[Ct.kind]:Ct,[wt.kind]:wt,[Rt.kind]:Rt,[Gt.kind]:Gt,[At.kind]:At,[Ut.kind]:Ut,[zt.kind]:zt,[Ft.kind]:Ft,[Jt.kind]:Jt,[Kt.kind]:Kt},{input:Mt,output:Qs}=n;class _t extends n{run(){this.output(0).data=this.input(0).data.length}}i(_t,"kind","stringLength"),i(_t,"inputs",[Mt("string")]),i(_t,"outputs",[Qs("number")]);class Dt extends n{run(){const t=this.input(0).data,s=this.input(1).data,u=this.input(2).data;this.output(0).data=t.substring(s,u)}}i(Dt,"kind","substring"),i(Dt,"inputs",[Mt("string"),Mt("number",{name:"start"}),Mt("number",{name:"end",optional:!0})]),i(Dt,"outputs",n.out(["string"]));const Vs={DflowNodeStringLength:_t,DflowNodeSubstring:Dt},Xs=Object.values(Vs).reduce((e,t)=>h({[t.kind]:t},e),{}),Ys=h(h(h(h(h(h(h(h(h(h({},Cs),ws),Rs),Us),Gs),Fs),Js),Ks),Ws),Xs);export{Ys as nodesCatalog};
